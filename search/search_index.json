{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Modern C++: Snippets and Examples GitHub Pages with snippets for Modern C++ We often need to copy and paste some snippets to code more productively. Snippets can help us when it's not easy to remember all high levels features Modern C++ has to offer. This repository contains lots of organized, reusable, and safe snippets for Modern C++. All snippets are available in GitHub pages in a convenient way for copying and pasting.","title":"Home"},{"location":"#modern-c-snippets-and-examples","text":"GitHub Pages with snippets for Modern C++ We often need to copy and paste some snippets to code more productively. Snippets can help us when it's not easy to remember all high levels features Modern C++ has to offer. This repository contains lots of organized, reusable, and safe snippets for Modern C++. All snippets are available in GitHub pages in a convenient way for copying and pasting.","title":"Modern C++: Snippets and Examples"},{"location":"cmake-functions/","text":"CMake functions Some useful CMake functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 # Enable exceptions for the target function ( target_exception_options TARGET_NAME ) if ( MSVC ) # MSVC requires this flag if the code uses C++ exception handling target_compile_options ( ${ TARGET_NAME } PRIVATE /EHsc ) endif () endfunction () # Enable big object files for the target function ( target_bigobj_options TARGET_NAME ) if ( MSVC ) # MSVC requires this flag if the file has a lot of code target_compile_options ( ${ TARGET_NAME } PRIVATE /bigobj ) endif () endfunction () # Enable pedantic warnings for the target function ( target_pedantic_options TARGET_NAME ) # Set warning levels to about the same level for MSVC, GCC, and Clang if ( BUILD_WITH_PEDANTIC_WARNINGS ) if ( MSVC ) target_compile_options ( ${ TARGET_NAME } PRIVATE /W4 /WX ) else () target_compile_options ( ${ TARGET_NAME } PRIVATE -Wall -Wextra -pedantic -Werror ) endif () endif () endfunction () # Enable compile options for MSVC only function ( target_msvc_compile_options TARGET_NAME DEFINITION ) if ( MSVC ) target_compile_options ( ${ TARGET_NAME } PUBLIC ${ DEFINITION } ) endif () endfunction () # Set variable indicating if this is a master project function ( set_master_project_booleans ) if ( ${ CMAKE_CURRENT_SOURCE_DIR } STREQUAL ${ CMAKE_SOURCE_DIR } ) set ( MASTER_PROJECT ON PARENT_SCOPE ) else () set ( MASTER_PROJECT OFF PARENT_SCOPE ) endif () endfunction () # Set variables indicating if Debug/Release function ( set_debug_booleans ) if ( CMAKE_BUILD_TYPE STREQUAL \"Debug\" ) set ( DEBUG_MODE ON PARENT_SCOPE ) set ( NOT_DEBUG_MODE OFF PARENT_SCOPE ) set ( RELEASE_MODE OFF PARENT_SCOPE ) set ( NOT_RELEASE_MODE ON PARENT_SCOPE ) else () set ( DEBUG_MODE OFF PARENT_SCOPE ) set ( NOT_DEBUG_MODE ON PARENT_SCOPE ) set ( RELEASE_MODE ON PARENT_SCOPE ) set ( NOT_RELEASE_MODE OFF PARENT_SCOPE ) endif () endfunction () # Add sanitizer flag for Clang and GCC # You shouldn't use sanitizers in Release Mode macro ( add_sanitizer flag ) if ( CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" OR CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\" ) set ( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fsanitize=${flag} -fno-omit-frame-pointer\" ) set ( DCMAKE_C_FLAGS \"${DCMAKE_C_FLAGS} -fsanitize=${flag} -fno-omit-frame-pointer\" ) set ( CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -fsanitize=${flag}\" ) set ( DCMAKE_MODULE_LINKER_FLAGS \"${DCMAKE_MODULE_LINKER_FLAGS} -fsanitize=${flag}\" ) endif () endmacro () # Add address sanitizer # You shouldn't use sanitizers in Release Mode macro ( add_address_sanitizer ) add_sanitizer ( \"address\" ) endmacro () # Add thread sanitizer # You shouldn't use sanitizers in Release Mode macro ( add_thread_sanitizer ) add_sanitizer ( \"thread\" ) endmacro () # Add undefined sanitizer # You shouldn't use sanitizers in Release Mode macro ( add_undefined_sanitizer ) add_sanitizer ( \"undefined\" ) endmacro () # Add memory sanitizer # You shouldn't use sanitizers in Release Mode macro ( add_memory_sanitizer ) add_sanitizer ( \"memory\" ) endmacro () # Add leak sanitizer # You shouldn't use sanitizers in Release Mode macro ( add_leak_sanitizer ) add_sanitizer ( \"leak\" ) endmacro () # Add all sanitizers # You shouldn't use sanitizers in Release Mode macro ( add_all_sanitizers ) add_address_sanitizer () add_leak_sanitizer () add_undefined_sanitizer () # add_thread_sanitizer() # not allowed with address # add_memory_sanitizer() # not supported with darwin20.1.0 endmacro ()","title":"CMake functions"},{"location":"cmake-functions/#cmake-functions","text":"Some useful CMake functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 # Enable exceptions for the target function ( target_exception_options TARGET_NAME ) if ( MSVC ) # MSVC requires this flag if the code uses C++ exception handling target_compile_options ( ${ TARGET_NAME } PRIVATE /EHsc ) endif () endfunction () # Enable big object files for the target function ( target_bigobj_options TARGET_NAME ) if ( MSVC ) # MSVC requires this flag if the file has a lot of code target_compile_options ( ${ TARGET_NAME } PRIVATE /bigobj ) endif () endfunction () # Enable pedantic warnings for the target function ( target_pedantic_options TARGET_NAME ) # Set warning levels to about the same level for MSVC, GCC, and Clang if ( BUILD_WITH_PEDANTIC_WARNINGS ) if ( MSVC ) target_compile_options ( ${ TARGET_NAME } PRIVATE /W4 /WX ) else () target_compile_options ( ${ TARGET_NAME } PRIVATE -Wall -Wextra -pedantic -Werror ) endif () endif () endfunction () # Enable compile options for MSVC only function ( target_msvc_compile_options TARGET_NAME DEFINITION ) if ( MSVC ) target_compile_options ( ${ TARGET_NAME } PUBLIC ${ DEFINITION } ) endif () endfunction () # Set variable indicating if this is a master project function ( set_master_project_booleans ) if ( ${ CMAKE_CURRENT_SOURCE_DIR } STREQUAL ${ CMAKE_SOURCE_DIR } ) set ( MASTER_PROJECT ON PARENT_SCOPE ) else () set ( MASTER_PROJECT OFF PARENT_SCOPE ) endif () endfunction () # Set variables indicating if Debug/Release function ( set_debug_booleans ) if ( CMAKE_BUILD_TYPE STREQUAL \"Debug\" ) set ( DEBUG_MODE ON PARENT_SCOPE ) set ( NOT_DEBUG_MODE OFF PARENT_SCOPE ) set ( RELEASE_MODE OFF PARENT_SCOPE ) set ( NOT_RELEASE_MODE ON PARENT_SCOPE ) else () set ( DEBUG_MODE OFF PARENT_SCOPE ) set ( NOT_DEBUG_MODE ON PARENT_SCOPE ) set ( RELEASE_MODE ON PARENT_SCOPE ) set ( NOT_RELEASE_MODE OFF PARENT_SCOPE ) endif () endfunction () # Add sanitizer flag for Clang and GCC # You shouldn't use sanitizers in Release Mode macro ( add_sanitizer flag ) if ( CMAKE_CXX_COMPILER_ID MATCHES \"Clang\" OR CMAKE_CXX_COMPILER_ID STREQUAL \"GNU\" ) set ( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -fsanitize=${flag} -fno-omit-frame-pointer\" ) set ( DCMAKE_C_FLAGS \"${DCMAKE_C_FLAGS} -fsanitize=${flag} -fno-omit-frame-pointer\" ) set ( CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -fsanitize=${flag}\" ) set ( DCMAKE_MODULE_LINKER_FLAGS \"${DCMAKE_MODULE_LINKER_FLAGS} -fsanitize=${flag}\" ) endif () endmacro () # Add address sanitizer # You shouldn't use sanitizers in Release Mode macro ( add_address_sanitizer ) add_sanitizer ( \"address\" ) endmacro () # Add thread sanitizer # You shouldn't use sanitizers in Release Mode macro ( add_thread_sanitizer ) add_sanitizer ( \"thread\" ) endmacro () # Add undefined sanitizer # You shouldn't use sanitizers in Release Mode macro ( add_undefined_sanitizer ) add_sanitizer ( \"undefined\" ) endmacro () # Add memory sanitizer # You shouldn't use sanitizers in Release Mode macro ( add_memory_sanitizer ) add_sanitizer ( \"memory\" ) endmacro () # Add leak sanitizer # You shouldn't use sanitizers in Release Mode macro ( add_leak_sanitizer ) add_sanitizer ( \"leak\" ) endmacro () # Add all sanitizers # You shouldn't use sanitizers in Release Mode macro ( add_all_sanitizers ) add_address_sanitizer () add_leak_sanitizer () add_undefined_sanitizer () # add_thread_sanitizer() # not allowed with address # add_memory_sanitizer() # not supported with darwin20.1.0 endmacro ()","title":"CMake functions"},{"location":"faq/","text":"FAQ Where are the examples? Are the snippets examples? The complete examples are in the examples directory, but they not explicitly replicated in the docs because they are much longer than the snippets. What's the difference between snippets and examples? Examples are often long and don't represent independent tasks you can copy and paste. Snippets represent independent tasks between pairs of comments that you can copy and paste. Shouldn't the snippet files be short files? The snippets could go into a new category level and we could separate them at their lowest level by file, but that would make them difficult to explore if the resolution is too high, like 3-4 lines of code per file. Also, because snippets have pre-conditions and post-conditions, it would make it much harder to test all snippets. Why not get my snippets directly from cppreference or cplusplus.com? The cppreference is not meant for snippets and this repository is not meant to be a reference for the C++ standard. Some implications are: The snippets: Meant to list the commands you most often need in a library. Lots of independent tasks for copying and pasting Include corresponding build scripts when something more complex is required Include external libraries when it's existing practice Organized roughly in the order someone learning C++ might need them The examples in cppreference or cplusplus.com: Meant to make points about the internals of the libraries. A single task meant to prove a point Has nothing to do with build scripts Has nothing to do with external libraries Mix simple and complex concepts to make a point Why do you use std::endl so much in the snippets? Isn't it evil? The snippets usually use std::endl instead of '\\n' : Flushing does have a semantic meaning different from '\\n which is a nice convention for small snippets (please show me what's in the buffer vs. put a newline in the buffer) Most snippets require creating variables first and using them later so that we can test the snippets with GitHub Actions. The flushing part is not what you are going to copy and paste in a snippet. The time difference of flushing std::cout to the console (not files!) is negligible Almost no application is spending more time flushing than calculating things to flush. Unless it's a flushing benchmark.","title":"FAQ"},{"location":"faq/#faq","text":"Where are the examples? Are the snippets examples? The complete examples are in the examples directory, but they not explicitly replicated in the docs because they are much longer than the snippets. What's the difference between snippets and examples? Examples are often long and don't represent independent tasks you can copy and paste. Snippets represent independent tasks between pairs of comments that you can copy and paste. Shouldn't the snippet files be short files? The snippets could go into a new category level and we could separate them at their lowest level by file, but that would make them difficult to explore if the resolution is too high, like 3-4 lines of code per file. Also, because snippets have pre-conditions and post-conditions, it would make it much harder to test all snippets. Why not get my snippets directly from cppreference or cplusplus.com? The cppreference is not meant for snippets and this repository is not meant to be a reference for the C++ standard. Some implications are: The snippets: Meant to list the commands you most often need in a library. Lots of independent tasks for copying and pasting Include corresponding build scripts when something more complex is required Include external libraries when it's existing practice Organized roughly in the order someone learning C++ might need them The examples in cppreference or cplusplus.com: Meant to make points about the internals of the libraries. A single task meant to prove a point Has nothing to do with build scripts Has nothing to do with external libraries Mix simple and complex concepts to make a point Why do you use std::endl so much in the snippets? Isn't it evil? The snippets usually use std::endl instead of '\\n' : Flushing does have a semantic meaning different from '\\n which is a nice convention for small snippets (please show me what's in the buffer vs. put a newline in the buffer) Most snippets require creating variables first and using them later so that we can test the snippets with GitHub Actions. The flushing part is not what you are going to copy and paste in a snippet. The time difference of flushing std::cout to the console (not files!) is negligible Almost no application is spending more time flushing than calculating things to flush. Unless it's a flushing benchmark.","title":"FAQ"},{"location":"get-involved/","text":"Get involved After getting started with this library, please complete this survey to let us know how we can improve your experience. Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If you are a programmer with good ideas, please share these ideas with us. Academic collaboration is more than welcome. Contributing Feel free to contribute with new snippets to this repository. For complex features and changes, consider getting feedback from the community first. There are many ways in which you can contribute to this library: Testing the library in new environments Contributing with interesting snippets and examples Finding problems in the documentation Finding bugs in general Whatever idea seems interesting to you The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are: \"I don't like this optional feature so I removed/deprecated it\" \"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative. This repository is focused on Modern C++. \"I removed this feature so I don't have to install/update ______\" but have not provided an equivalent alternative \"I'm creating this high-cost promise that we'll support _ _ forever\" but I'm not sticking around to keep that promise In doubt, please open a discussion first. Guidelines If contributing with code, please leave the pedantic mode ON ( -DBUILD_WITH_PEDANTIC_WARNINGS=ON ), use cppcheck , and clang-format . Example: CLion If contributing to the documentation, please edit README.md directly, as the files in this documentation are automatically generated with mdsplit .","title":"Get involved"},{"location":"get-involved/#get-involved","text":"After getting started with this library, please complete this survey to let us know how we can improve your experience. Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If you are a programmer with good ideas, please share these ideas with us. Academic collaboration is more than welcome. Contributing Feel free to contribute with new snippets to this repository. For complex features and changes, consider getting feedback from the community first. There are many ways in which you can contribute to this library: Testing the library in new environments Contributing with interesting snippets and examples Finding problems in the documentation Finding bugs in general Whatever idea seems interesting to you The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are: \"I don't like this optional feature so I removed/deprecated it\" \"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative. This repository is focused on Modern C++. \"I removed this feature so I don't have to install/update ______\" but have not provided an equivalent alternative \"I'm creating this high-cost promise that we'll support _ _ forever\" but I'm not sticking around to keep that promise In doubt, please open a discussion first. Guidelines If contributing with code, please leave the pedantic mode ON ( -DBUILD_WITH_PEDANTIC_WARNINGS=ON ), use cppcheck , and clang-format . Example: CLion If contributing to the documentation, please edit README.md directly, as the files in this documentation are automatically generated with mdsplit .","title":"Get involved"},{"location":"quick-start/","text":"Quick Start This is how this repository works: The snippets directory has lots of short programs with useful C++20 snippets The examples directory has lots of short tasks using these snippets GitHub actions ensures all snippets are working on GCC, MSVC, and Clang We generate GitHub pages with all snippets by groups of tasks using mkdocs material and mdsplit Libraries We give preference to libraries in this order: Libraries supported by most C++ compilers Libraries accepted into the C++ standard Libraries likely to be accepted into the next C++ standard Libraries representative of existing practice External Libraries For external libraries, we also include a short CMake snippet in the build script with: find_package to find, setup, and link the large external libraries FetchContents to download, build, and link the external library Snippets and Examples The snippets, as they are, might seem like they are examples in the sense that they are in long files sometimes. What makes them snippets is that, at the source file level, they represent lots of independent short tasks separated by comments. Unlike in the examples, the tasks separated by comments are unrelated. You can just copy and paste the snippets between pairs of comments. GitHub Pages We generate GitHub pages with all snippets: The GitHub pages are generated with mkdocs material and mdsplit Snippets organized are categorized by groups of tasks Sections are easy to explore, copy, and paste","title":"Quick Start"},{"location":"quick-start/#quick-start","text":"This is how this repository works: The snippets directory has lots of short programs with useful C++20 snippets The examples directory has lots of short tasks using these snippets GitHub actions ensures all snippets are working on GCC, MSVC, and Clang We generate GitHub pages with all snippets by groups of tasks using mkdocs material and mdsplit Libraries We give preference to libraries in this order: Libraries supported by most C++ compilers Libraries accepted into the C++ standard Libraries likely to be accepted into the next C++ standard Libraries representative of existing practice External Libraries For external libraries, we also include a short CMake snippet in the build script with: find_package to find, setup, and link the large external libraries FetchContents to download, build, and link the external library Snippets and Examples The snippets, as they are, might seem like they are examples in the sense that they are in long files sometimes. What makes them snippets is that, at the source file level, they represent lots of independent short tasks separated by comments. Unlike in the examples, the tasks separated by comments are unrelated. You can just copy and paste the snippets between pairs of comments. GitHub Pages We generate GitHub pages with all snippets: The GitHub pages are generated with mkdocs material and mdsplit Snippets organized are categorized by groups of tasks Sections are easy to explore, copy, and paste","title":"Quick Start"},{"location":"algorithms--data-structures/algorithm/basic-algorithms/","text":"Basic Algorithms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 #include <iostream> #include <numeric> #include <random> #include <vector> #include <algorithm> #include <iterator> int main () { std :: random_device rd ; std :: mt19937 generator { rd ()}; std :: uniform_int_distribution < int > distribution ( 1 , 30 ); std :: cout << \"Non-modifying sequence operations:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Counting std :: cout << \"There are \" << std :: count ( v . begin (), v . end (), 10 ) << \" tens\" << std :: endl ; // Comparing sequences auto v2 = v ; if ( std :: equal ( v . begin (), v . end (), v2 . begin ())) { std :: cout << \"v and v2 are the same\" << std :: endl ; } // Finding elements std :: vector < int >:: iterator position = std :: find ( v . begin (), v . end (), 10 ); if ( position != v . end ()) { std :: cout << \"A ten was found in position \" << position - v . begin () << std :: endl ; } else { std :: cout << \"A ten was not found in any position\" << std :: endl ; } // Finding elements from a set std :: vector < int > set = { 16 , 15 , 14 }; std :: vector < int >:: iterator position2 = std :: find_first_of ( v . begin (), v . end (), set . begin (), set . end ()); if ( position2 != v . end ()) { std :: cout << \"An element from the set was found in position \" << position2 - v . begin () << std :: endl ; } else { std :: cout << \"An element from the set was not found in any position\" << std :: endl ; } // Finding mismatches v2 [ v2 . size () / 3 ] ++ ; auto mpair = std :: mismatch ( v . begin (), v . end (), v2 . begin ()); std :: cout << \"Elements \" << * mpair . first << \" and \" << * mpair . second << \" mismatched at position \" << mpair . first - v . begin () << std :: endl ; // Adjacent elements auto i1 = std :: adjacent_find ( v . begin (), v . end ()); if ( i1 == v . end ()) { std :: cout << \"No matching adjacent elements\" << std :: endl ; } else { std :: cout << \"The first adjacent pair of equal elements at: \" << std :: distance ( v . begin (), i1 ) << std :: endl ; } // Find subsequence std :: vector < int > target = { v [ 30 ], v [ 31 ], v [ 32 ]}; auto result = std :: search ( v . begin (), v . end (), target . begin (), target . end ()); if ( result == v . end ()) { std :: cout << \"Subsequence not found\" << std :: endl ; } else { std :: cout << \"First subsequence is at: \" << std :: distance ( v . begin (), result ) << std :: endl ; } std :: vector < int > v3 = { v [ 30 ], v [ 31 ], v [ 32 ]}; auto result2 = std :: find_end ( v . begin (), v . end (), v3 . begin (), v3 . end ()); if ( result2 == v . end ()) { std :: cout << \"Subsequence not found\" << std :: endl ; } else { std :: cout << \"Last subsequence is at: \" << std :: distance ( v . begin (), result2 ) << std :: endl ; } } std :: cout << \"Modifying sequence operations:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; std :: vector < int > v2 ( 100 ); std :: generate ( v2 . begin (), v2 . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Copying std :: copy ( v . begin (), v . end (), v2 . begin ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Filling std :: fill ( v2 . begin (), v2 . end (), 0 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Removing elements v2 = v ; auto last_removed = std :: remove ( v2 . begin (), v2 . end (), 10 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; v2 . erase ( last_removed , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; v2 . resize ( 100 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Replacing elements std :: replace ( v2 . begin (), v2 . end (), 0 , 100 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Swapping std :: swap ( v , v2 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Swapping ranges std :: swap_ranges ( v . begin (), v . end (), v2 . begin ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Reverse std :: reverse ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Rotate left std :: rotate ( v2 . begin (), v2 . begin () + 5 , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Rotate right std :: rotate ( v2 . rbegin (), v2 . rbegin () + 5 , v2 . rend ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Shuffle std :: shuffle ( v2 . begin (), v2 . end (), generator ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Sample std :: sample ( v . begin (), v . end (), v2 . begin (), v . size (), generator ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Remove duplicates std :: sort ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; auto last_unique = std :: unique ( v2 . begin (), v2 . end ()); v2 . erase ( last_unique , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; } std :: cout << \"Sorting:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; std :: vector < int > v2 ( 100 ); std :: generate ( v2 . begin (), v2 . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Sorting (Usually Introsort = Quicksort + Heapsort) std :: sort ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Checking if sorted if ( std :: is_sorted ( v2 . begin (), v2 . end ())) { std :: cout << \"The vector is sorted\" << std :: endl ; } // Sorting partially v2 = v ; std :: partial_sort ( v2 . begin (), v2 . begin () + 15 , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Sorting (stable) std :: stable_sort ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Median and percentiles v2 = v ; std :: nth_element ( v2 . begin (), v2 . begin () + v2 . size () / 2 , v . end ()); std :: cout << \"The median is \" << v [ v . size () / 2 ] << '\\n' ; std :: nth_element ( v2 . begin (), v2 . begin () + 1 , v2 . end ()); std :: cout << \"The second smallest element is \" << v2 [ 1 ] << '\\n' ; } std :: cout << \"Binary search:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: sort ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Binary search if ( std :: binary_search ( v . begin (), v . end (), 15 )) { std :: cout << \"Element 15 found\" << std :: endl ; } else { std :: cout << \"Element 15 not found\" << std :: endl ; } // Lower bound auto lower = std :: lower_bound ( v . begin (), v . end (), 15 ); if ( lower != v . end ()) { std :: cout << \"First 15 at position \" << lower - v . begin () << std :: endl ; } else { std :: cout << \"15 not found\" << std :: endl ; } // Upper bound auto upper = std :: upper_bound ( v . begin (), v . end (), 15 ); if ( upper != v . end ()) { std :: cout << \"Last 15 at position \" << upper - v . begin () << std :: endl ; } else { std :: cout << \"Last 15 not found\" << std :: endl ; } // Equal range auto range = std :: equal_range ( v . begin (), v . end (), 15 ); if ( range . first != v . end ()) { std :: cout << \"15 from positions \" << range . first - v . begin () << \" to \" << range . second - v . begin () << std :: endl ; } } std :: cout << \"Heap:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Creating heaps std :: make_heap ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; std :: cout << \"The largest element is \" << v . front () << std :: endl ; // Pushing elements to heap v . push_back ( 31 ); std :: push_heap ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Popping elements from heap std :: pop_heap ( v . begin (), v . end ()); v . pop_back (); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Sorting heap std :: sort_heap ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; } std :: cout << \"Minimum/maximum operations:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Max/min std :: cout << \"min: \" << std :: min ( 9 , 3 ) << \", max = \" << std :: max ( 9 , 3 ) << std :: endl ; std :: pair < int , int > bounds = std :: minmax ( std :: rand () % v . size (), std :: rand () % v . size ()); std :: cout << \"v[\" << bounds . first << \",\" << bounds . second << \"]: \" ; for ( int i = bounds . first ; i < bounds . second ; ++ i ) { std :: cout << v [ i ] << ' ' ; } std :: cout << std :: endl ; // Max/min elements auto max_i = std :: max_element ( v . begin (), v . end ()); std :: cout << \"Max element at: \" << std :: distance ( v . begin (), max_i ) << std :: endl ; auto min_i = std :: min_element ( v . begin (), v . end ()); std :: cout << \"Min element at: \" << std :: distance ( v . begin (), min_i ) << std :: endl ; auto result = std :: minmax_element ( v . begin (), v . end ()); std :: cout << \"min element at: \" << ( result . first - v . begin ()) << '\\n' ; std :: cout << \"max element at: \" << ( result . second - v . begin ()) << '\\n' ; } std :: cout << \"Permutations:\" << std :: endl ; { std :: vector < int > v1 { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v2 { 3 , 5 , 4 , 1 , 2 }; std :: cout << \"3,5,4,1,2 is a permutation of 1,2,3,4,5? \" << std :: boolalpha << std :: is_permutation ( v1 . begin (), v1 . end (), v2 . begin ()) << '\\n' ; std :: vector < int > v3 { 1 , 2 , 3 }; do { std :: for_each ( v3 . begin (), v3 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; } while ( std :: next_permutation ( v3 . begin (), v3 . end ())); } std :: cout << \"Numeric:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Sequentially increasing values std :: iota ( v . begin (), v . end (), 0 ); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Accumulating std :: cout << \"Total \" << std :: accumulate ( v . begin (), v . end (), 0 ) << std :: endl ; // Inner product std :: vector < int > a { 0 , 1 , 2 , 3 , 4 }; std :: vector < int > b { 5 , 4 , 2 , 3 , 1 }; int r1 = std :: inner_product ( a . begin (), a . end (), b . begin (), 0 ); std :: cout << \"Inner product of a and b: \" << r1 << '\\n' ; // Adjacent difference std :: vector < int > x { 1 , 4 , 7 , 8 , 11 , 11 , 14 , 15 , 19 , 22 }; std :: adjacent_difference ( x . begin (), x . end (), x . begin ()); std :: for_each ( x . begin (), x . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Partial sum std :: partial_sum ( x . begin (), x . end (), std :: ostream_iterator < int > ( std :: cout , \" \" )); std :: cout << '\\n' ; } return 0 ; }","title":"Basic Algorithms"},{"location":"algorithms--data-structures/algorithm/basic-algorithms/#basic-algorithms","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 #include <iostream> #include <numeric> #include <random> #include <vector> #include <algorithm> #include <iterator> int main () { std :: random_device rd ; std :: mt19937 generator { rd ()}; std :: uniform_int_distribution < int > distribution ( 1 , 30 ); std :: cout << \"Non-modifying sequence operations:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Counting std :: cout << \"There are \" << std :: count ( v . begin (), v . end (), 10 ) << \" tens\" << std :: endl ; // Comparing sequences auto v2 = v ; if ( std :: equal ( v . begin (), v . end (), v2 . begin ())) { std :: cout << \"v and v2 are the same\" << std :: endl ; } // Finding elements std :: vector < int >:: iterator position = std :: find ( v . begin (), v . end (), 10 ); if ( position != v . end ()) { std :: cout << \"A ten was found in position \" << position - v . begin () << std :: endl ; } else { std :: cout << \"A ten was not found in any position\" << std :: endl ; } // Finding elements from a set std :: vector < int > set = { 16 , 15 , 14 }; std :: vector < int >:: iterator position2 = std :: find_first_of ( v . begin (), v . end (), set . begin (), set . end ()); if ( position2 != v . end ()) { std :: cout << \"An element from the set was found in position \" << position2 - v . begin () << std :: endl ; } else { std :: cout << \"An element from the set was not found in any position\" << std :: endl ; } // Finding mismatches v2 [ v2 . size () / 3 ] ++ ; auto mpair = std :: mismatch ( v . begin (), v . end (), v2 . begin ()); std :: cout << \"Elements \" << * mpair . first << \" and \" << * mpair . second << \" mismatched at position \" << mpair . first - v . begin () << std :: endl ; // Adjacent elements auto i1 = std :: adjacent_find ( v . begin (), v . end ()); if ( i1 == v . end ()) { std :: cout << \"No matching adjacent elements\" << std :: endl ; } else { std :: cout << \"The first adjacent pair of equal elements at: \" << std :: distance ( v . begin (), i1 ) << std :: endl ; } // Find subsequence std :: vector < int > target = { v [ 30 ], v [ 31 ], v [ 32 ]}; auto result = std :: search ( v . begin (), v . end (), target . begin (), target . end ()); if ( result == v . end ()) { std :: cout << \"Subsequence not found\" << std :: endl ; } else { std :: cout << \"First subsequence is at: \" << std :: distance ( v . begin (), result ) << std :: endl ; } std :: vector < int > v3 = { v [ 30 ], v [ 31 ], v [ 32 ]}; auto result2 = std :: find_end ( v . begin (), v . end (), v3 . begin (), v3 . end ()); if ( result2 == v . end ()) { std :: cout << \"Subsequence not found\" << std :: endl ; } else { std :: cout << \"Last subsequence is at: \" << std :: distance ( v . begin (), result2 ) << std :: endl ; } } std :: cout << \"Modifying sequence operations:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; std :: vector < int > v2 ( 100 ); std :: generate ( v2 . begin (), v2 . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Copying std :: copy ( v . begin (), v . end (), v2 . begin ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Filling std :: fill ( v2 . begin (), v2 . end (), 0 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Removing elements v2 = v ; auto last_removed = std :: remove ( v2 . begin (), v2 . end (), 10 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; v2 . erase ( last_removed , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; v2 . resize ( 100 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Replacing elements std :: replace ( v2 . begin (), v2 . end (), 0 , 100 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Swapping std :: swap ( v , v2 ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Swapping ranges std :: swap_ranges ( v . begin (), v . end (), v2 . begin ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Reverse std :: reverse ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Rotate left std :: rotate ( v2 . begin (), v2 . begin () + 5 , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Rotate right std :: rotate ( v2 . rbegin (), v2 . rbegin () + 5 , v2 . rend ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Shuffle std :: shuffle ( v2 . begin (), v2 . end (), generator ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Sample std :: sample ( v . begin (), v . end (), v2 . begin (), v . size (), generator ); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Remove duplicates std :: sort ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; auto last_unique = std :: unique ( v2 . begin (), v2 . end ()); v2 . erase ( last_unique , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; } std :: cout << \"Sorting:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; std :: vector < int > v2 ( 100 ); std :: generate ( v2 . begin (), v2 . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Sorting (Usually Introsort = Quicksort + Heapsort) std :: sort ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Checking if sorted if ( std :: is_sorted ( v2 . begin (), v2 . end ())) { std :: cout << \"The vector is sorted\" << std :: endl ; } // Sorting partially v2 = v ; std :: partial_sort ( v2 . begin (), v2 . begin () + 15 , v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Sorting (stable) std :: stable_sort ( v2 . begin (), v2 . end ()); std :: for_each ( v2 . begin (), v2 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << \"(\" << v2 . size () << \")\" << std :: endl ; // Median and percentiles v2 = v ; std :: nth_element ( v2 . begin (), v2 . begin () + v2 . size () / 2 , v . end ()); std :: cout << \"The median is \" << v [ v . size () / 2 ] << '\\n' ; std :: nth_element ( v2 . begin (), v2 . begin () + 1 , v2 . end ()); std :: cout << \"The second smallest element is \" << v2 [ 1 ] << '\\n' ; } std :: cout << \"Binary search:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: sort ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Binary search if ( std :: binary_search ( v . begin (), v . end (), 15 )) { std :: cout << \"Element 15 found\" << std :: endl ; } else { std :: cout << \"Element 15 not found\" << std :: endl ; } // Lower bound auto lower = std :: lower_bound ( v . begin (), v . end (), 15 ); if ( lower != v . end ()) { std :: cout << \"First 15 at position \" << lower - v . begin () << std :: endl ; } else { std :: cout << \"15 not found\" << std :: endl ; } // Upper bound auto upper = std :: upper_bound ( v . begin (), v . end (), 15 ); if ( upper != v . end ()) { std :: cout << \"Last 15 at position \" << upper - v . begin () << std :: endl ; } else { std :: cout << \"Last 15 not found\" << std :: endl ; } // Equal range auto range = std :: equal_range ( v . begin (), v . end (), 15 ); if ( range . first != v . end ()) { std :: cout << \"15 from positions \" << range . first - v . begin () << \" to \" << range . second - v . begin () << std :: endl ; } } std :: cout << \"Heap:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Creating heaps std :: make_heap ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; std :: cout << \"The largest element is \" << v . front () << std :: endl ; // Pushing elements to heap v . push_back ( 31 ); std :: push_heap ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Popping elements from heap std :: pop_heap ( v . begin (), v . end ()); v . pop_back (); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Sorting heap std :: sort_heap ( v . begin (), v . end ()); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; } std :: cout << \"Minimum/maximum operations:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Max/min std :: cout << \"min: \" << std :: min ( 9 , 3 ) << \", max = \" << std :: max ( 9 , 3 ) << std :: endl ; std :: pair < int , int > bounds = std :: minmax ( std :: rand () % v . size (), std :: rand () % v . size ()); std :: cout << \"v[\" << bounds . first << \",\" << bounds . second << \"]: \" ; for ( int i = bounds . first ; i < bounds . second ; ++ i ) { std :: cout << v [ i ] << ' ' ; } std :: cout << std :: endl ; // Max/min elements auto max_i = std :: max_element ( v . begin (), v . end ()); std :: cout << \"Max element at: \" << std :: distance ( v . begin (), max_i ) << std :: endl ; auto min_i = std :: min_element ( v . begin (), v . end ()); std :: cout << \"Min element at: \" << std :: distance ( v . begin (), min_i ) << std :: endl ; auto result = std :: minmax_element ( v . begin (), v . end ()); std :: cout << \"min element at: \" << ( result . first - v . begin ()) << '\\n' ; std :: cout << \"max element at: \" << ( result . second - v . begin ()) << '\\n' ; } std :: cout << \"Permutations:\" << std :: endl ; { std :: vector < int > v1 { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v2 { 3 , 5 , 4 , 1 , 2 }; std :: cout << \"3,5,4,1,2 is a permutation of 1,2,3,4,5? \" << std :: boolalpha << std :: is_permutation ( v1 . begin (), v1 . end (), v2 . begin ()) << '\\n' ; std :: vector < int > v3 { 1 , 2 , 3 }; do { std :: for_each ( v3 . begin (), v3 . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; } while ( std :: next_permutation ( v3 . begin (), v3 . end ())); } std :: cout << \"Numeric:\" << std :: endl ; { std :: vector < int > v ( 100 ); std :: generate ( v . begin (), v . end (), [ & ] { return distribution ( generator ); }); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Sequentially increasing values std :: iota ( v . begin (), v . end (), 0 ); std :: for_each ( v . begin (), v . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Accumulating std :: cout << \"Total \" << std :: accumulate ( v . begin (), v . end (), 0 ) << std :: endl ; // Inner product std :: vector < int > a { 0 , 1 , 2 , 3 , 4 }; std :: vector < int > b { 5 , 4 , 2 , 3 , 1 }; int r1 = std :: inner_product ( a . begin (), a . end (), b . begin (), 0 ); std :: cout << \"Inner product of a and b: \" << r1 << '\\n' ; // Adjacent difference std :: vector < int > x { 1 , 4 , 7 , 8 , 11 , 11 , 14 , 15 , 19 , 22 }; std :: adjacent_difference ( x . begin (), x . end (), x . begin ()); std :: for_each ( x . begin (), x . end (), []( const int c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Partial sum std :: partial_sum ( x . begin (), x . end (), std :: ostream_iterator < int > ( std :: cout , \" \" )); std :: cout << '\\n' ; } return 0 ; }","title":"Basic Algorithms"},{"location":"algorithms--data-structures/algorithm/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 add_executable ( algorithms algorithms.cpp ) # Ranges in C++20: https://en.cppreference.com/w/cpp/ranges # Use range-v3 for now: https://github.com/ericniebler/range-v3 FetchContent_Declare ( range-v3 URL https://github.com/ericniebler/range-v3/archive/0.11.0.zip ) FetchContent_GetProperties ( range-v3 ) if ( NOT range-v3_POPULATED ) FetchContent_Populate ( range-v3 ) add_library ( range-v3 INTERFACE IMPORTED ) target_include_directories ( range-v3 INTERFACE \"${range-v3_SOURCE_DIR}/include\" ) endif () add_executable ( ranges ranges.cpp ) target_link_libraries ( ranges PUBLIC range-v3 ) add_executable ( searching searching.cpp ) add_executable ( sorting sorting.cpp )","title":"Build script"},{"location":"algorithms--data-structures/algorithm/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 add_executable ( algorithms algorithms.cpp ) # Ranges in C++20: https://en.cppreference.com/w/cpp/ranges # Use range-v3 for now: https://github.com/ericniebler/range-v3 FetchContent_Declare ( range-v3 URL https://github.com/ericniebler/range-v3/archive/0.11.0.zip ) FetchContent_GetProperties ( range-v3 ) if ( NOT range-v3_POPULATED ) FetchContent_Populate ( range-v3 ) add_library ( range-v3 INTERFACE IMPORTED ) target_include_directories ( range-v3 INTERFACE \"${range-v3_SOURCE_DIR}/include\" ) endif () add_executable ( ranges ranges.cpp ) target_link_libraries ( ranges PUBLIC range-v3 ) add_executable ( searching searching.cpp ) add_executable ( sorting sorting.cpp )","title":"Build script"},{"location":"algorithms--data-structures/algorithm/ranges/","text":"Ranges 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include <iostream> #include <map> #include <numeric> #include <random> #include <range/v3/all.hpp> #include <regex> #include <string> #include <vector> int main () { using std :: array ; using std :: cout ; using std :: endl ; using std :: map ; using std :: regex ; using std :: string ; using std :: vector ; using namespace ranges ; std :: random_device rd ; std :: mt19937 generator { rd ()}; std :: uniform_int_distribution < int > distribution ( 1 , 30 ); // Algorithms vector < double > v ( 30 ); iota ( v , 1 ); cout << count ( v , 0 ) << endl ; cout << accumulate ( v , 0 ) << endl ; sort ( v ); cout << binary_search ( v , 15 ) << endl ; cout << is_sorted ( v ) << endl ; for_each ( v , []( const int c ) { cout << c << \" \" ; }); cout << endl ; // Range views array < int , 6 > a {{ 0 , 5 , 2 , 1 , 3 , 4 }}; auto filtered_range = views :: filter ( a , []( int i ) { return i > 2 ; }); vector < int > v2 ; copy ( filtered_range , back_inserter ( v2 )); auto reversed_range = views :: reverse ( a ); copy ( reversed_range , ostream_iterator < int > { cout , \" \" }); sort ( a ); auto unique_range = views :: unique ( a ); copy ( unique_range , ostream_iterator < int > { cout , \" \" }); map < string , int > m ; m [ \"a\" ] = 0 ; m [ \"b\" ] = 1 ; m [ \"c\" ] = 2 ; auto map_keys = views :: keys ( m ); copy ( map_keys , ostream_iterator < string > { cout , \",\" }); string s = \"The range v3 library\" ; regex expr { \"[ \\\\ w+]+\" }; auto tokenizer = views :: tokenize ( s , expr , 0 , std :: regex_constants :: match_default ); copy ( tokenizer , ostream_iterator < string > { cout , \",\" }); auto ir = views :: ints ( 0 , 3 ); copy ( ir , ostream_iterator < int > { cout , \",\" }); return 0 ; }","title":"Ranges"},{"location":"algorithms--data-structures/algorithm/ranges/#ranges","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include <iostream> #include <map> #include <numeric> #include <random> #include <range/v3/all.hpp> #include <regex> #include <string> #include <vector> int main () { using std :: array ; using std :: cout ; using std :: endl ; using std :: map ; using std :: regex ; using std :: string ; using std :: vector ; using namespace ranges ; std :: random_device rd ; std :: mt19937 generator { rd ()}; std :: uniform_int_distribution < int > distribution ( 1 , 30 ); // Algorithms vector < double > v ( 30 ); iota ( v , 1 ); cout << count ( v , 0 ) << endl ; cout << accumulate ( v , 0 ) << endl ; sort ( v ); cout << binary_search ( v , 15 ) << endl ; cout << is_sorted ( v ) << endl ; for_each ( v , []( const int c ) { cout << c << \" \" ; }); cout << endl ; // Range views array < int , 6 > a {{ 0 , 5 , 2 , 1 , 3 , 4 }}; auto filtered_range = views :: filter ( a , []( int i ) { return i > 2 ; }); vector < int > v2 ; copy ( filtered_range , back_inserter ( v2 )); auto reversed_range = views :: reverse ( a ); copy ( reversed_range , ostream_iterator < int > { cout , \" \" }); sort ( a ); auto unique_range = views :: unique ( a ); copy ( unique_range , ostream_iterator < int > { cout , \" \" }); map < string , int > m ; m [ \"a\" ] = 0 ; m [ \"b\" ] = 1 ; m [ \"c\" ] = 2 ; auto map_keys = views :: keys ( m ); copy ( map_keys , ostream_iterator < string > { cout , \",\" }); string s = \"The range v3 library\" ; regex expr { \"[ \\\\ w+]+\" }; auto tokenizer = views :: tokenize ( s , expr , 0 , std :: regex_constants :: match_default ); copy ( tokenizer , ostream_iterator < string > { cout , \",\" }); auto ir = views :: ints ( 0 , 3 ); copy ( ir , ostream_iterator < int > { cout , \",\" }); return 0 ; }","title":"Ranges"},{"location":"algorithms--data-structures/algorithm/searching/","text":"Searching 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #include <algorithm> #include <array> #include <iomanip> #include <iostream> #include <memory> #include <random> #include <vector> using namespace std ; // Usual implementation based on subscripts // - What you would probably learn in school size_t sequential_find ( const vector < int > & v , const int key ) { for ( size_t i = 0 ; i < v . size (); ++ i ) { if ( v [ i ] == key ) { return i ; } } // return a sentinel return v . size (); } // Implementation based on iterators // - Example only. Use std::find instead. // - What works for more container types. template < class It , class T > constexpr It sequential_find ( It first , It last , const T & value ) { for (; first != last ; ++ first ) { if ( * first == value ) { return first ; } } // return a sentinel return last ; } // Usual implementation based on subscripts // - What you would probably learn in school size_t binary_find ( const vector < int > & v , const int key ) { size_t left_idx = 0 ; size_t right_idx = v . size () - 1 ; size_t i ; do { i = ( left_idx + right_idx ) / 2 ; if ( v [ i ] < key ) { left_idx = i + 1 ; } else { right_idx = i - 1 ; } } while ( v [ i ] != key && left_idx <= right_idx ); return v [ i ] == key ? i : v . size (); } // Example only. Use std::lower_bound instead. template < class It , class T > It binary_find ( It first , It last , const T & value ) { typename std :: iterator_traits < It >:: difference_type count , step ; It it ; count = std :: distance ( first , last ); while ( count > 0 ) { it = first ; step = count / 2 ; std :: advance ( it , step ); if ( * it < value ) { first = ++ it ; count -= step + 1 ; } else { count = step ; } } return first ; } int main () { // Create vector for searching vector v = { 5 , 4 , 9 , 8 , 6 , 3 }; // Sequential search (std library) auto i1 = find ( v . begin (), v . end (), 6 ); if ( i1 != v . end ()) { cout << \"*i1: \" << * i1 << '\\n' ; } cout << \"position: \" << i1 - v . begin () << '\\n' ; // Sequential search (vector / the textbook convention) size_t pos1 = sequential_find ( v , 6 ); if ( pos1 != v . size ()) { cout << \"value: \" << v [ pos1 ] << '\\n' ; } cout << \"position: \" << pos1 << '\\n' ; // Sequential search (iterators / the C++ convention) auto it1 = sequential_find ( v . begin (), v . end (), 6 ); if ( it1 != v . end ()) { cout << \"*it1: \" << * it1 << '\\n' ; } cout << \"position: \" << it1 - v . begin () << '\\n' ; // Prepare vector for binary search sort ( v . begin (), v . end ()); // Binary search (std library) auto i2 = lower_bound ( v . begin (), v . end (), 6 ); if ( i2 != v . end ()) { cout << \"*i2: \" << * i2 << '\\n' ; } cout << \"position: \" << i2 - v . begin () << '\\n' ; // Binary search (vector / the textbook convention) size_t pos2 = binary_find ( v , 6 ); if ( pos2 != v . size ()) { cout << \"value: \" << v [ pos2 ] << '\\n' ; } cout << \"position: \" << pos2 << '\\n' ; // Binary search (iterators / the C++ convention) auto it2 = binary_find ( v . begin (), v . end (), 6 ); if ( it2 != v . end ()) { cout << \"*it2: \" << * it2 << '\\n' ; } cout << \"position: \" << it2 - v . begin () << '\\n' ; return 0 ; }","title":"Searching"},{"location":"algorithms--data-structures/algorithm/searching/#searching","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #include <algorithm> #include <array> #include <iomanip> #include <iostream> #include <memory> #include <random> #include <vector> using namespace std ; // Usual implementation based on subscripts // - What you would probably learn in school size_t sequential_find ( const vector < int > & v , const int key ) { for ( size_t i = 0 ; i < v . size (); ++ i ) { if ( v [ i ] == key ) { return i ; } } // return a sentinel return v . size (); } // Implementation based on iterators // - Example only. Use std::find instead. // - What works for more container types. template < class It , class T > constexpr It sequential_find ( It first , It last , const T & value ) { for (; first != last ; ++ first ) { if ( * first == value ) { return first ; } } // return a sentinel return last ; } // Usual implementation based on subscripts // - What you would probably learn in school size_t binary_find ( const vector < int > & v , const int key ) { size_t left_idx = 0 ; size_t right_idx = v . size () - 1 ; size_t i ; do { i = ( left_idx + right_idx ) / 2 ; if ( v [ i ] < key ) { left_idx = i + 1 ; } else { right_idx = i - 1 ; } } while ( v [ i ] != key && left_idx <= right_idx ); return v [ i ] == key ? i : v . size (); } // Example only. Use std::lower_bound instead. template < class It , class T > It binary_find ( It first , It last , const T & value ) { typename std :: iterator_traits < It >:: difference_type count , step ; It it ; count = std :: distance ( first , last ); while ( count > 0 ) { it = first ; step = count / 2 ; std :: advance ( it , step ); if ( * it < value ) { first = ++ it ; count -= step + 1 ; } else { count = step ; } } return first ; } int main () { // Create vector for searching vector v = { 5 , 4 , 9 , 8 , 6 , 3 }; // Sequential search (std library) auto i1 = find ( v . begin (), v . end (), 6 ); if ( i1 != v . end ()) { cout << \"*i1: \" << * i1 << '\\n' ; } cout << \"position: \" << i1 - v . begin () << '\\n' ; // Sequential search (vector / the textbook convention) size_t pos1 = sequential_find ( v , 6 ); if ( pos1 != v . size ()) { cout << \"value: \" << v [ pos1 ] << '\\n' ; } cout << \"position: \" << pos1 << '\\n' ; // Sequential search (iterators / the C++ convention) auto it1 = sequential_find ( v . begin (), v . end (), 6 ); if ( it1 != v . end ()) { cout << \"*it1: \" << * it1 << '\\n' ; } cout << \"position: \" << it1 - v . begin () << '\\n' ; // Prepare vector for binary search sort ( v . begin (), v . end ()); // Binary search (std library) auto i2 = lower_bound ( v . begin (), v . end (), 6 ); if ( i2 != v . end ()) { cout << \"*i2: \" << * i2 << '\\n' ; } cout << \"position: \" << i2 - v . begin () << '\\n' ; // Binary search (vector / the textbook convention) size_t pos2 = binary_find ( v , 6 ); if ( pos2 != v . size ()) { cout << \"value: \" << v [ pos2 ] << '\\n' ; } cout << \"position: \" << pos2 << '\\n' ; // Binary search (iterators / the C++ convention) auto it2 = binary_find ( v . begin (), v . end (), 6 ); if ( it2 != v . end ()) { cout << \"*it2: \" << * it2 << '\\n' ; } cout << \"position: \" << it2 - v . begin () << '\\n' ; return 0 ; }","title":"Searching"},{"location":"algorithms--data-structures/algorithm/sorting/","text":"Sorting 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 #include <algorithm> #include <array> #include <functional> #include <iomanip> #include <iostream> #include <memory> #include <random> #include <string> #include <vector> using namespace std ; // Selection sort template < class It , class C > void selection_sort ( It first , It last , C comp ) { for ( auto it = first ; it != last - 1 ; ++ it ) { iter_swap ( it , min_element ( it , last , comp )); } } template < class It > void selection_sort ( It first , It last ) { selection_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } // Insertion sort template < class It , class C > void insertion_sort ( It first , It last , C comp ) { for ( auto i = first ; i != last ; ++ i ) { rotate ( upper_bound ( first , i , * i , comp ), i , i + 1 ); } } template < class It > void insertion_sort ( It first , It last ) { insertion_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } // Mergesort template < class It , class C > void merge_sort ( It first , It last , C comp ) { if ( last - first > 1 ) { It middle = first + ( last - first ) / 2 ; merge_sort ( first , middle , comp ); merge_sort ( middle , last , comp ); inplace_merge ( first , middle , last , comp ); } } template < class It > void merge_sort ( It first , It last ) { merge_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } // Helper function for median of three values template < typename T , class C > constexpr T median ( T t1 , T t2 , T t3 , C comp ) { return ( comp ( t1 , t2 )) ? (( comp ( t2 , t3 )) ? t2 : (( comp ( t1 , t3 )) ? t3 : t1 )) : (( comp ( t1 , t3 )) ? t1 : (( comp ( t2 , t3 )) ? t3 : t2 )); } template < class It > void median ( It first , It last ) { median ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } // Quicksort template < class It , class C > void quick_sort ( It first , It last , C comp ) { if ( first != last && std :: next ( first ) != last ) { It middle = first + ( last - first ) / 2 ; auto pivot = median ( * first , * middle , * std :: prev ( last ), comp ); It split1 = partition ( first , last , [ & ]( auto x ) { return comp ( x , pivot ); }); It split2 = partition ( split1 , last , [ & ]( auto x ) { return ! comp ( pivot , x ); }); quick_sort ( first , split1 , comp ); quick_sort ( split2 , last , comp ); } } template < class It > void quick_sort ( It first , It last ) { quick_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } int main () { // Create vector for searching vector v = { 5 , 4 , 9 , 8 , 6 , 3 }; // Sort sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), ostream_iterator < int > { cout , \" \" }); cout << endl ; v = { 5 , 4 , 9 , 8 , 6 , 3 }; // Selection sort selection_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), ostream_iterator < int > { cout , \" \" }); cout << endl ; v = { 5 , 4 , 9 , 8 , 6 , 3 }; // Insertion sort insertion_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), ostream_iterator < int > { cout , \" \" }); cout << endl ; v = { 5 , 4 , 9 , 8 , 6 , 3 }; // Mergesort merge_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), ostream_iterator < int > { cout , \" \" }); cout << endl ; v = { 5 , 4 , 9 , 8 , 6 , 3 }; // Quicksort quick_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), ostream_iterator < int > { cout , \" \" }); cout << endl ; return 0 ; }","title":"Sorting"},{"location":"algorithms--data-structures/algorithm/sorting/#sorting","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 #include <algorithm> #include <array> #include <functional> #include <iomanip> #include <iostream> #include <memory> #include <random> #include <string> #include <vector> using namespace std ; // Selection sort template < class It , class C > void selection_sort ( It first , It last , C comp ) { for ( auto it = first ; it != last - 1 ; ++ it ) { iter_swap ( it , min_element ( it , last , comp )); } } template < class It > void selection_sort ( It first , It last ) { selection_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } // Insertion sort template < class It , class C > void insertion_sort ( It first , It last , C comp ) { for ( auto i = first ; i != last ; ++ i ) { rotate ( upper_bound ( first , i , * i , comp ), i , i + 1 ); } } template < class It > void insertion_sort ( It first , It last ) { insertion_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } // Mergesort template < class It , class C > void merge_sort ( It first , It last , C comp ) { if ( last - first > 1 ) { It middle = first + ( last - first ) / 2 ; merge_sort ( first , middle , comp ); merge_sort ( middle , last , comp ); inplace_merge ( first , middle , last , comp ); } } template < class It > void merge_sort ( It first , It last ) { merge_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } // Helper function for median of three values template < typename T , class C > constexpr T median ( T t1 , T t2 , T t3 , C comp ) { return ( comp ( t1 , t2 )) ? (( comp ( t2 , t3 )) ? t2 : (( comp ( t1 , t3 )) ? t3 : t1 )) : (( comp ( t1 , t3 )) ? t1 : (( comp ( t2 , t3 )) ? t3 : t2 )); } template < class It > void median ( It first , It last ) { median ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } // Quicksort template < class It , class C > void quick_sort ( It first , It last , C comp ) { if ( first != last && std :: next ( first ) != last ) { It middle = first + ( last - first ) / 2 ; auto pivot = median ( * first , * middle , * std :: prev ( last ), comp ); It split1 = partition ( first , last , [ & ]( auto x ) { return comp ( x , pivot ); }); It split2 = partition ( split1 , last , [ & ]( auto x ) { return ! comp ( pivot , x ); }); quick_sort ( first , split1 , comp ); quick_sort ( split2 , last , comp ); } } template < class It > void quick_sort ( It first , It last ) { quick_sort ( first , last , std :: less < std :: decay_t < decltype ( * first ) >> ()); } int main () { // Create vector for searching vector v = { 5 , 4 , 9 , 8 , 6 , 3 }; // Sort sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), ostream_iterator < int > { cout , \" \" }); cout << endl ; v = { 5 , 4 , 9 , 8 , 6 , 3 }; // Selection sort selection_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), ostream_iterator < int > { cout , \" \" }); cout << endl ; v = { 5 , 4 , 9 , 8 , 6 , 3 }; // Insertion sort insertion_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), ostream_iterator < int > { cout , \" \" }); cout << endl ; v = { 5 , 4 , 9 , 8 , 6 , 3 }; // Mergesort merge_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), ostream_iterator < int > { cout , \" \" }); cout << endl ; v = { 5 , 4 , 9 , 8 , 6 , 3 }; // Quicksort quick_sort ( v . begin (), v . end ()); copy ( v . begin (), v . end (), ostream_iterator < int > { cout , \" \" }); cout << endl ; return 0 ; }","title":"Sorting"},{"location":"algorithms--data-structures/data-structures/associative-containers/","text":"Associative Containers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include <iostream> #include <map> #include <set> #include <string> #include <unordered_map> #include <unordered_set> template < class CONTAINER > void print_container_size ( const CONTAINER & c ) { if ( c . empty ()) { std :: cout << \"Empty container\" << std :: endl ; } else { std :: cout << \"The container has \" << c . size () << \" elements\" << std :: endl ; } } void print_container ( const std :: set < int > & c ) { typename std :: set < int >:: const_iterator i ; for ( i = c . begin (); i != c . end (); ++ i ) { std :: cout << * i << \" \" ; } std :: cout << std :: endl ; } void print_container ( const std :: map < std :: string , double > & c ) { typename std :: map < std :: string , double >:: const_iterator i ; for ( i = c . begin (); i != c . end (); ++ i ) { std :: cout << i -> first << \": \" << i -> second << \" \" ; } std :: cout << std :: endl ; } void print_container ( const std :: unordered_set < int > & c ) { typename std :: unordered_set < int >:: const_iterator i ; for ( i = c . begin (); i != c . end (); ++ i ) { std :: cout << * i << \" \" ; } std :: cout << std :: endl ; } void print_container ( const std :: unordered_map < std :: string , double > & c ) { typename std :: unordered_map < std :: string , double >:: const_iterator i ; for ( i = c . begin (); i != c . end (); ++ i ) { std :: cout << i -> first << \": \" << i -> second << \" \" ; } std :: cout << std :: endl ; } int main () { using namespace std ; std :: set < int > a = { 1 , 2 , 3 , 4 , 5 }; std :: unordered_set < int > a2 = { 1 , 2 , 3 , 4 , 5 }; std :: map < string , double > m ; m [ \"PI\" ] = 3.14 ; m [ \"ZERO\" ] = 0.0 ; m [ \"IRPF\" ] = 0.15 ; std :: unordered_map < string , double > m2 ; m2 [ \"PI\" ] = 3.14 ; m2 [ \"ZERO\" ] = 0.0 ; m2 [ \"IRPF\" ] = 0.15 ; std :: cout << \"Print sizes:\" << std :: endl ; print_container_size ( a ); print_container_size ( a2 ); print_container_size ( m ); print_container_size ( m2 ); std :: cout << \"Insertion:\" << std :: endl ; a . insert ( 8 ); a2 . insert ( 8 ); m [ \"CEM\" ] = 100.0 ; m . insert ( std :: make_pair ( \"MIL\" , 1000.0 )); m2 [ \"CEM\" ] = 100.0 ; m2 . insert ( std :: make_pair ( \"MIL\" , 1000.0 )); std :: cout << \"Print containers\" << std :: endl ; print_container ( a ); print_container ( a2 ); print_container ( m ); print_container ( m2 ); std :: cout << \"Removal:\" << std :: endl ; a . erase ( 2 ); a2 . erase ( 2 ); m . erase ( \"MIL\" ); m2 . erase ( \"MIL\" ); std :: cout << \"Print containers\" << std :: endl ; print_container ( a ); print_container ( a2 ); print_container ( m ); print_container ( m2 ); }","title":"Associative Containers"},{"location":"algorithms--data-structures/data-structures/associative-containers/#associative-containers","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 #include <iostream> #include <map> #include <set> #include <string> #include <unordered_map> #include <unordered_set> template < class CONTAINER > void print_container_size ( const CONTAINER & c ) { if ( c . empty ()) { std :: cout << \"Empty container\" << std :: endl ; } else { std :: cout << \"The container has \" << c . size () << \" elements\" << std :: endl ; } } void print_container ( const std :: set < int > & c ) { typename std :: set < int >:: const_iterator i ; for ( i = c . begin (); i != c . end (); ++ i ) { std :: cout << * i << \" \" ; } std :: cout << std :: endl ; } void print_container ( const std :: map < std :: string , double > & c ) { typename std :: map < std :: string , double >:: const_iterator i ; for ( i = c . begin (); i != c . end (); ++ i ) { std :: cout << i -> first << \": \" << i -> second << \" \" ; } std :: cout << std :: endl ; } void print_container ( const std :: unordered_set < int > & c ) { typename std :: unordered_set < int >:: const_iterator i ; for ( i = c . begin (); i != c . end (); ++ i ) { std :: cout << * i << \" \" ; } std :: cout << std :: endl ; } void print_container ( const std :: unordered_map < std :: string , double > & c ) { typename std :: unordered_map < std :: string , double >:: const_iterator i ; for ( i = c . begin (); i != c . end (); ++ i ) { std :: cout << i -> first << \": \" << i -> second << \" \" ; } std :: cout << std :: endl ; } int main () { using namespace std ; std :: set < int > a = { 1 , 2 , 3 , 4 , 5 }; std :: unordered_set < int > a2 = { 1 , 2 , 3 , 4 , 5 }; std :: map < string , double > m ; m [ \"PI\" ] = 3.14 ; m [ \"ZERO\" ] = 0.0 ; m [ \"IRPF\" ] = 0.15 ; std :: unordered_map < string , double > m2 ; m2 [ \"PI\" ] = 3.14 ; m2 [ \"ZERO\" ] = 0.0 ; m2 [ \"IRPF\" ] = 0.15 ; std :: cout << \"Print sizes:\" << std :: endl ; print_container_size ( a ); print_container_size ( a2 ); print_container_size ( m ); print_container_size ( m2 ); std :: cout << \"Insertion:\" << std :: endl ; a . insert ( 8 ); a2 . insert ( 8 ); m [ \"CEM\" ] = 100.0 ; m . insert ( std :: make_pair ( \"MIL\" , 1000.0 )); m2 [ \"CEM\" ] = 100.0 ; m2 . insert ( std :: make_pair ( \"MIL\" , 1000.0 )); std :: cout << \"Print containers\" << std :: endl ; print_container ( a ); print_container ( a2 ); print_container ( m ); print_container ( m2 ); std :: cout << \"Removal:\" << std :: endl ; a . erase ( 2 ); a2 . erase ( 2 ); m . erase ( \"MIL\" ); m2 . erase ( \"MIL\" ); std :: cout << \"Print containers\" << std :: endl ; print_container ( a ); print_container ( a2 ); print_container ( m ); print_container ( m2 ); }","title":"Associative Containers"},{"location":"algorithms--data-structures/data-structures/bitset/","text":"Bitset 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include <bitset> #include <iostream> #include <cstddef> using namespace std ; int main () { // Get type size cout << \"sizeof(char) = \" << sizeof ( char ) << \" bytes\" << endl ; cout << \"sizeof(unsigned char) = \" << sizeof ( unsigned char ) << \" bytes\" << endl ; cout << \"sizeof(short) = \" << sizeof ( short ) << \" bytes\" << endl ; cout << \"sizeof(int) = \" << sizeof ( int ) << \" bytes\" << endl ; cout << \"sizeof(long) = \" << sizeof ( long ) << \" bytes\" << endl ; cout << \"sizeof(size_t) = \" << sizeof ( size_t ) << \" bytes\" << endl ; cout << \"sizeof(double) = \" << sizeof ( double ) << \" bytes\" << endl << endl ; // Binary literals uint32_t r = 0b111111110100010001100110 ; cout << r << endl ; // Bitsets cout << \"r = \" << bitset < 32 > ( r ) << endl << endl ; // Operators const uint32_t unit = 0x01 ; cout << \"unit << 0 = \" << bitset < 32 > ( unit << 0 ) << endl ; cout << \"~(unit << 0) = \" << bitset < 32 > ( ~ ( unit << 0 )) << endl ; cout << \"r & (~(unit << 0)) = \" << bitset < 32 > ( r & ( ~ ( unit << 0 ))) << endl << endl ; cout << \"unit << 1 = \" << bitset < 32 > ( unit << 1 ) << endl ; cout << \"~(unit << 1) = \" << bitset < 32 > ( ~ ( unit << 1 )) << endl ; cout << \"r & (~(unit << 1)) = \" << bitset < 32 > ( r & ( ~ ( unit << 1 ))) << endl << endl ; cout << \"unit << 2 = \" << bitset < 32 > ( unit << 2 ) << endl ; cout << \"~(unit << 2) = \" << bitset < 32 > ( ~ ( unit << 2 )) << endl ; cout << \"r & (~(unit << 2)) = \" << bitset < 32 > ( r & ( ~ ( unit << 2 ))) << endl << endl ; cout << \"unit << 3 = \" << bitset < 32 > ( unit << 3 ) << endl ; cout << \"~(unit << 3) = \" << bitset < 32 > ( ~ ( unit << 3 )) << endl ; cout << \"r & (~(unit << 3)) = \" << bitset < 32 > ( r & ( ~ ( unit << 3 ))) << endl << endl ; cout << \"unit << 4 = \" << bitset < 32 > ( unit << 4 ) << endl ; cout << \"~(unit << 4) = \" << bitset < 32 > ( ~ ( unit << 4 )) << endl ; cout << \"r & (~(unit << 4)) = \" << bitset < 32 > ( r & ( ~ ( unit << 4 ))) << endl << endl ; cout << \"unit << 5 = \" << bitset < 32 > ( unit << 5 ) << endl ; cout << \"~(unit << 5) = \" << bitset < 32 > ( ~ ( unit << 5 )) << endl ; cout << \"r & (~(unit << 5)) = \" << bitset < 32 > ( r & ( ~ ( unit << 5 ))) << endl << endl ; cout << \"unit << 6 = \" << bitset < 32 > ( unit << 6 ) << endl ; cout << \"~(unit << 6) = \" << bitset < 32 > ( ~ ( unit << 6 )) << endl ; cout << \"r & (~(unit << 6)) = \" << bitset < 32 > ( r & ( ~ ( unit << 6 ))) << endl << endl ; cout << \"unit << 7 = \" << bitset < 32 > ( unit << 7 ) << endl ; cout << \"~(unit << 7) = \" << bitset < 32 > ( ~ ( unit << 7 )) << endl ; cout << \"r & (~(unit << 7)) = \" << bitset < 32 > ( r & ( ~ ( unit << 7 ))) << endl << endl ; cout << \"unit << 8 = \" << bitset < 32 > ( unit << 8 ) << endl ; cout << \"~(unit << 8) = \" << bitset < 32 > ( ~ ( unit << 8 )) << endl ; cout << \"r & (~(unit << 8)) = \" << bitset < 32 > ( r & ( ~ ( unit << 8 ))) << endl << endl ; std :: bitset < 8 > b ( 20 ); std :: cout << \"b: \" << b << std :: endl ; std :: cout << \"b: \" << b . to_ulong () << std :: endl ; std :: cout << \"b: \" << b . to_string () << std :: endl ; for ( size_t i = 0 ; i < b . size (); ++ i ) { std :: cout << \"b[i] : \" << b [ i ] << std :: endl ; } std :: byte a { 20 }; std :: cout << \"a: \" << std :: to_integer < int > ( a ) << std :: endl ; return 0 ; }","title":"Bitset"},{"location":"algorithms--data-structures/data-structures/bitset/#bitset","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include <bitset> #include <iostream> #include <cstddef> using namespace std ; int main () { // Get type size cout << \"sizeof(char) = \" << sizeof ( char ) << \" bytes\" << endl ; cout << \"sizeof(unsigned char) = \" << sizeof ( unsigned char ) << \" bytes\" << endl ; cout << \"sizeof(short) = \" << sizeof ( short ) << \" bytes\" << endl ; cout << \"sizeof(int) = \" << sizeof ( int ) << \" bytes\" << endl ; cout << \"sizeof(long) = \" << sizeof ( long ) << \" bytes\" << endl ; cout << \"sizeof(size_t) = \" << sizeof ( size_t ) << \" bytes\" << endl ; cout << \"sizeof(double) = \" << sizeof ( double ) << \" bytes\" << endl << endl ; // Binary literals uint32_t r = 0b111111110100010001100110 ; cout << r << endl ; // Bitsets cout << \"r = \" << bitset < 32 > ( r ) << endl << endl ; // Operators const uint32_t unit = 0x01 ; cout << \"unit << 0 = \" << bitset < 32 > ( unit << 0 ) << endl ; cout << \"~(unit << 0) = \" << bitset < 32 > ( ~ ( unit << 0 )) << endl ; cout << \"r & (~(unit << 0)) = \" << bitset < 32 > ( r & ( ~ ( unit << 0 ))) << endl << endl ; cout << \"unit << 1 = \" << bitset < 32 > ( unit << 1 ) << endl ; cout << \"~(unit << 1) = \" << bitset < 32 > ( ~ ( unit << 1 )) << endl ; cout << \"r & (~(unit << 1)) = \" << bitset < 32 > ( r & ( ~ ( unit << 1 ))) << endl << endl ; cout << \"unit << 2 = \" << bitset < 32 > ( unit << 2 ) << endl ; cout << \"~(unit << 2) = \" << bitset < 32 > ( ~ ( unit << 2 )) << endl ; cout << \"r & (~(unit << 2)) = \" << bitset < 32 > ( r & ( ~ ( unit << 2 ))) << endl << endl ; cout << \"unit << 3 = \" << bitset < 32 > ( unit << 3 ) << endl ; cout << \"~(unit << 3) = \" << bitset < 32 > ( ~ ( unit << 3 )) << endl ; cout << \"r & (~(unit << 3)) = \" << bitset < 32 > ( r & ( ~ ( unit << 3 ))) << endl << endl ; cout << \"unit << 4 = \" << bitset < 32 > ( unit << 4 ) << endl ; cout << \"~(unit << 4) = \" << bitset < 32 > ( ~ ( unit << 4 )) << endl ; cout << \"r & (~(unit << 4)) = \" << bitset < 32 > ( r & ( ~ ( unit << 4 ))) << endl << endl ; cout << \"unit << 5 = \" << bitset < 32 > ( unit << 5 ) << endl ; cout << \"~(unit << 5) = \" << bitset < 32 > ( ~ ( unit << 5 )) << endl ; cout << \"r & (~(unit << 5)) = \" << bitset < 32 > ( r & ( ~ ( unit << 5 ))) << endl << endl ; cout << \"unit << 6 = \" << bitset < 32 > ( unit << 6 ) << endl ; cout << \"~(unit << 6) = \" << bitset < 32 > ( ~ ( unit << 6 )) << endl ; cout << \"r & (~(unit << 6)) = \" << bitset < 32 > ( r & ( ~ ( unit << 6 ))) << endl << endl ; cout << \"unit << 7 = \" << bitset < 32 > ( unit << 7 ) << endl ; cout << \"~(unit << 7) = \" << bitset < 32 > ( ~ ( unit << 7 )) << endl ; cout << \"r & (~(unit << 7)) = \" << bitset < 32 > ( r & ( ~ ( unit << 7 ))) << endl << endl ; cout << \"unit << 8 = \" << bitset < 32 > ( unit << 8 ) << endl ; cout << \"~(unit << 8) = \" << bitset < 32 > ( ~ ( unit << 8 )) << endl ; cout << \"r & (~(unit << 8)) = \" << bitset < 32 > ( r & ( ~ ( unit << 8 ))) << endl << endl ; std :: bitset < 8 > b ( 20 ); std :: cout << \"b: \" << b << std :: endl ; std :: cout << \"b: \" << b . to_ulong () << std :: endl ; std :: cout << \"b: \" << b . to_string () << std :: endl ; for ( size_t i = 0 ; i < b . size (); ++ i ) { std :: cout << \"b[i] : \" << b [ i ] << std :: endl ; } std :: byte a { 20 }; std :: cout << \"a: \" << std :: to_integer < int > ( a ) << std :: endl ; return 0 ; }","title":"Bitset"},{"location":"algorithms--data-structures/data-structures/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # Data structures add_executable ( sequential_containers sequential_containers.cpp ) add_executable ( associative_containers associative_containers.cpp ) find_package ( PMR ) if ( PMR_FOUND ) add_executable ( memory_resource memory_resource.cpp ) else () message ( \"Your compiler does not support *PMR* yet\" ) endif () add_executable ( span span.cpp ) add_executable ( bitset bitset.cpp ) # Set options to not build pareto examples # - Cache our own BUILD_EXAMPLES var so that pareto # doesn't mess with it set ( BUILD_MATPLOT_TARGETS OFF CACHE BOOL \"\" FORCE ) set ( BUILD_EXAMPLES_PREV ${ BUILD_EXAMPLES } ) set ( BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( pareto GIT_REPOSITORY https://github.com/alandefreitas/pareto.git GIT_TAG v1.2.0 ) FetchContent_MakeAvailable ( pareto ) set ( BUILD_EXAMPLES ${ BUILD_EXAMPLES_PREV } CACHE BOOL \"\" FORCE ) add_executable ( spatial_containers spatial_containers.cpp ) target_link_libraries ( spatial_containers PUBLIC pareto )","title":"Build script"},{"location":"algorithms--data-structures/data-structures/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # Data structures add_executable ( sequential_containers sequential_containers.cpp ) add_executable ( associative_containers associative_containers.cpp ) find_package ( PMR ) if ( PMR_FOUND ) add_executable ( memory_resource memory_resource.cpp ) else () message ( \"Your compiler does not support *PMR* yet\" ) endif () add_executable ( span span.cpp ) add_executable ( bitset bitset.cpp ) # Set options to not build pareto examples # - Cache our own BUILD_EXAMPLES var so that pareto # doesn't mess with it set ( BUILD_MATPLOT_TARGETS OFF CACHE BOOL \"\" FORCE ) set ( BUILD_EXAMPLES_PREV ${ BUILD_EXAMPLES } ) set ( BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( pareto GIT_REPOSITORY https://github.com/alandefreitas/pareto.git GIT_TAG v1.2.0 ) FetchContent_MakeAvailable ( pareto ) set ( BUILD_EXAMPLES ${ BUILD_EXAMPLES_PREV } CACHE BOOL \"\" FORCE ) add_executable ( spatial_containers spatial_containers.cpp ) target_link_libraries ( spatial_containers PUBLIC pareto )","title":"Build script"},{"location":"algorithms--data-structures/data-structures/memory-resource/","text":"Memory resource 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> #include <memory_resource> #include <vector> int main () { char buffer [ 64 ] = {}; // a small buffer on the stack std :: fill_n ( std :: begin ( buffer ), std :: size ( buffer ) - 1 , '_' ); std :: cout << buffer << '\\n' ; std :: pmr :: monotonic_buffer_resource pool { std :: data ( buffer ), std :: size ( buffer )}; std :: pmr :: vector < char > vec { & pool }; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { vec . push_back ( ch ); } std :: cout << buffer << '\\n' ; std :: pmr :: unsynchronized_pool_resource pool2 ; std :: pmr :: vector < char > vec2 { & pool2 }; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { vec2 . push_back ( ch ); } std :: copy ( vec2 . begin (), vec2 . end (), std :: ostream_iterator < char > ( std :: cout , \" \" )); } FindPMR.cmake: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 include ( CheckCXXSourceCompiles ) check_cxx_source_compiles ( \" #include <cstdlib> #include <vector> #include <memory_resource> int main() { std::pmr::unsynchronized_pool_resource pool; std::pmr::vector<char> vec{ &pool }; printf(\\\" %d\\ \", vec.size()); return EXIT_SUCCESS; } \" PMR_FOUND ) # If compiled correctly (concepts found) if ( PMR_FOUND AND NOT ( TARGET std::pmr )) add_library ( std::pmr INTERFACE IMPORTED ) endif ()","title":"Memory resource"},{"location":"algorithms--data-structures/data-structures/memory-resource/#memory-resource","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> #include <memory_resource> #include <vector> int main () { char buffer [ 64 ] = {}; // a small buffer on the stack std :: fill_n ( std :: begin ( buffer ), std :: size ( buffer ) - 1 , '_' ); std :: cout << buffer << '\\n' ; std :: pmr :: monotonic_buffer_resource pool { std :: data ( buffer ), std :: size ( buffer )}; std :: pmr :: vector < char > vec { & pool }; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { vec . push_back ( ch ); } std :: cout << buffer << '\\n' ; std :: pmr :: unsynchronized_pool_resource pool2 ; std :: pmr :: vector < char > vec2 { & pool2 }; for ( char ch = 'a' ; ch <= 'z' ; ++ ch ) { vec2 . push_back ( ch ); } std :: copy ( vec2 . begin (), vec2 . end (), std :: ostream_iterator < char > ( std :: cout , \" \" )); } FindPMR.cmake: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 include ( CheckCXXSourceCompiles ) check_cxx_source_compiles ( \" #include <cstdlib> #include <vector> #include <memory_resource> int main() { std::pmr::unsynchronized_pool_resource pool; std::pmr::vector<char> vec{ &pool }; printf(\\\" %d\\ \", vec.size()); return EXIT_SUCCESS; } \" PMR_FOUND ) # If compiled correctly (concepts found) if ( PMR_FOUND AND NOT ( TARGET std::pmr )) add_library ( std::pmr INTERFACE IMPORTED ) endif ()","title":"Memory resource"},{"location":"algorithms--data-structures/data-structures/sequential-containers/","text":"Sequential Containers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #include <array> #include <deque> #include <iostream> #include <list> #include <vector> template < class CONTAINER > void print_size ( const CONTAINER & c ) { if ( c . empty ()) { std :: cout << \"The container is empty\" << std :: endl ; } else { std :: cout << \"The container has \" << c . size () << \" elements\" << std :: endl ; } } template < class CONTAINER > std :: enable_if_t <! std :: is_same_v < CONTAINER , std :: array < int , 5 >> , void > append ( CONTAINER & c , int el ) { c . push_back ( el ); } template < class CONTAINER > std :: enable_if_t < std :: is_same_v < CONTAINER , std :: array < int , 5 >> , void > append ([[ maybe_unused ]] CONTAINER & c , int ) { std :: cout << \"Cannot increase the array\" << std :: endl ; } template < class CONTAINER > std :: enable_if_t < std :: is_same_v < CONTAINER , std :: vector < int >> || std :: is_same_v < CONTAINER , std :: array < int , 5 >> , void > append_front ([[ maybe_unused ]] CONTAINER & c , int ) { std :: cout << \"Cannot insert in front of vector or array\" << std :: endl ; } template < class CONTAINER > std :: enable_if_t <! ( std :: is_same_v < CONTAINER , std :: vector < int >> || std :: is_same_v < CONTAINER , std :: array < int , 5 >> ), void > append_front ( CONTAINER & c , int el ) { c . push_front ( el ); } template < class CONTAINER > std :: enable_if_t < std :: is_same_v < CONTAINER , std :: list < int >> , void > print_container_with_subscript ([[ maybe_unused ]] const CONTAINER & c ) { std :: cout << \"Cannot iterate list with subscripts\" << std :: endl ; } template < class CONTAINER > std :: enable_if_t <! std :: is_same_v < CONTAINER , std :: list < int >> , void > print_container_with_subscript ( const CONTAINER & c ) { for ( size_t i = 0 ; i < c . size (); ++ i ) { std :: cout << c [ i ] << \" \" ; } std :: cout << std :: endl ; } template < class CONTAINER > void print_container ( const CONTAINER & c ) { typename CONTAINER :: const_iterator i ; for ( i = c . begin (); i != c . end (); ++ i ) { std :: cout << * i << \" \" ; } std :: cout << std :: endl ; } int main () { std :: array < int , 5 > a = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v ( 8 , 9 ); std :: deque < int > d ( a . begin (), a . end ()); std :: list < int > l ; std :: cout << \"Print sizes:\" << std :: endl ; print_size ( a ); print_size ( v ); print_size ( d ); print_size ( l ); std :: cout << \"Push back:\" << std :: endl ; append ( a , 6 ); append ( v , 6 ); append ( d , 6 ); append ( l , 6 ); std :: cout << \"Print sizes\" << std :: endl ; print_size ( a ); print_size ( v ); print_size ( d ); print_size ( l ); std :: cout << \"Push front\" << std :: endl ; append_front ( a , 6 ); append_front ( v , 6 ); append_front ( d , 6 ); append_front ( l , 6 ); std :: cout << \"Subscrits\" << std :: endl ; print_container_with_subscript ( a ); print_container_with_subscript ( v ); print_container_with_subscript ( d ); print_container_with_subscript ( l ); std :: cout << \"Iterators\" << std :: endl ; print_container ( a ); print_container ( v ); print_container ( d ); print_container ( l ); }","title":"Sequential Containers"},{"location":"algorithms--data-structures/data-structures/sequential-containers/#sequential-containers","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #include <array> #include <deque> #include <iostream> #include <list> #include <vector> template < class CONTAINER > void print_size ( const CONTAINER & c ) { if ( c . empty ()) { std :: cout << \"The container is empty\" << std :: endl ; } else { std :: cout << \"The container has \" << c . size () << \" elements\" << std :: endl ; } } template < class CONTAINER > std :: enable_if_t <! std :: is_same_v < CONTAINER , std :: array < int , 5 >> , void > append ( CONTAINER & c , int el ) { c . push_back ( el ); } template < class CONTAINER > std :: enable_if_t < std :: is_same_v < CONTAINER , std :: array < int , 5 >> , void > append ([[ maybe_unused ]] CONTAINER & c , int ) { std :: cout << \"Cannot increase the array\" << std :: endl ; } template < class CONTAINER > std :: enable_if_t < std :: is_same_v < CONTAINER , std :: vector < int >> || std :: is_same_v < CONTAINER , std :: array < int , 5 >> , void > append_front ([[ maybe_unused ]] CONTAINER & c , int ) { std :: cout << \"Cannot insert in front of vector or array\" << std :: endl ; } template < class CONTAINER > std :: enable_if_t <! ( std :: is_same_v < CONTAINER , std :: vector < int >> || std :: is_same_v < CONTAINER , std :: array < int , 5 >> ), void > append_front ( CONTAINER & c , int el ) { c . push_front ( el ); } template < class CONTAINER > std :: enable_if_t < std :: is_same_v < CONTAINER , std :: list < int >> , void > print_container_with_subscript ([[ maybe_unused ]] const CONTAINER & c ) { std :: cout << \"Cannot iterate list with subscripts\" << std :: endl ; } template < class CONTAINER > std :: enable_if_t <! std :: is_same_v < CONTAINER , std :: list < int >> , void > print_container_with_subscript ( const CONTAINER & c ) { for ( size_t i = 0 ; i < c . size (); ++ i ) { std :: cout << c [ i ] << \" \" ; } std :: cout << std :: endl ; } template < class CONTAINER > void print_container ( const CONTAINER & c ) { typename CONTAINER :: const_iterator i ; for ( i = c . begin (); i != c . end (); ++ i ) { std :: cout << * i << \" \" ; } std :: cout << std :: endl ; } int main () { std :: array < int , 5 > a = { 1 , 2 , 3 , 4 , 5 }; std :: vector < int > v ( 8 , 9 ); std :: deque < int > d ( a . begin (), a . end ()); std :: list < int > l ; std :: cout << \"Print sizes:\" << std :: endl ; print_size ( a ); print_size ( v ); print_size ( d ); print_size ( l ); std :: cout << \"Push back:\" << std :: endl ; append ( a , 6 ); append ( v , 6 ); append ( d , 6 ); append ( l , 6 ); std :: cout << \"Print sizes\" << std :: endl ; print_size ( a ); print_size ( v ); print_size ( d ); print_size ( l ); std :: cout << \"Push front\" << std :: endl ; append_front ( a , 6 ); append_front ( v , 6 ); append_front ( d , 6 ); append_front ( l , 6 ); std :: cout << \"Subscrits\" << std :: endl ; print_container_with_subscript ( a ); print_container_with_subscript ( v ); print_container_with_subscript ( d ); print_container_with_subscript ( l ); std :: cout << \"Iterators\" << std :: endl ; print_container ( a ); print_container ( v ); print_container ( d ); print_container ( l ); }","title":"Sequential Containers"},{"location":"algorithms--data-structures/data-structures/span/","text":"Span 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include <algorithm> #include <cstddef> #include <iostream> #include <span> template < class T , std :: size_t N > [[ nodiscard ]] constexpr auto slide ( std :: span < T , N > s , std :: size_t offset , std :: size_t width ) { return s . subspan ( offset , offset + width <= s . size () ? width : 0U ); } template < class T , std :: size_t N , std :: size_t M > [[ nodiscard ]] constexpr bool starts_with ( std :: span < T , N > data , std :: span < T , M > prefix ) { return data . size () >= prefix . size () && std :: equal ( prefix . begin (), prefix . end (), data . begin ()); } template < class T , std :: size_t N , std :: size_t M > [[ nodiscard ]] constexpr bool ends_with ( std :: span < T , N > data , std :: span < T , M > suffix ) { return data . size () >= suffix . size () && std :: equal ( data . end () - suffix . size (), data . end (), suffix . end () - suffix . size ()); } template < class T , std :: size_t N , std :: size_t M > [[ nodiscard ]] constexpr bool contains ( std :: span < T , N > span , std :: span < T , M > sub ) { return std :: search ( span . begin (), span . end (), sub . begin (), sub . end ()) != span . end (); } void print ( const auto & seq ) { for ( const auto & elem : seq ) std :: cout << elem << ' ' ; std :: cout << '\\n' ; } int main () { constexpr int a []{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; constexpr int b []{ 8 , 7 , 6 }; for ( std :: size_t offset {};; ++ offset ) { constexpr std :: size_t width { 6 }; auto s = slide ( std :: span { a }, offset , width ); if ( s . empty ()) break ; print ( s ); } static_assert ( starts_with ( std :: span { a }, std :: span { a , 4 }) && starts_with ( std :: span { a + 1 , 4 }, std :: span { a + 1 , 3 }) && ! starts_with ( std :: span { a }, std :: span { b }) && ! starts_with ( std :: span { a , 8 }, std :: span { a + 1 , 3 }) && ends_with ( std :: span { a }, std :: span { a + 6 , 3 }) && ! ends_with ( std :: span { a }, std :: span { a + 6 , 2 }) && contains ( std :: span { a }, std :: span { a + 1 , 4 }) && ! contains ( std :: span { a , 8 }, std :: span { a , 9 })); }","title":"Span"},{"location":"algorithms--data-structures/data-structures/span/#span","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include <algorithm> #include <cstddef> #include <iostream> #include <span> template < class T , std :: size_t N > [[ nodiscard ]] constexpr auto slide ( std :: span < T , N > s , std :: size_t offset , std :: size_t width ) { return s . subspan ( offset , offset + width <= s . size () ? width : 0U ); } template < class T , std :: size_t N , std :: size_t M > [[ nodiscard ]] constexpr bool starts_with ( std :: span < T , N > data , std :: span < T , M > prefix ) { return data . size () >= prefix . size () && std :: equal ( prefix . begin (), prefix . end (), data . begin ()); } template < class T , std :: size_t N , std :: size_t M > [[ nodiscard ]] constexpr bool ends_with ( std :: span < T , N > data , std :: span < T , M > suffix ) { return data . size () >= suffix . size () && std :: equal ( data . end () - suffix . size (), data . end (), suffix . end () - suffix . size ()); } template < class T , std :: size_t N , std :: size_t M > [[ nodiscard ]] constexpr bool contains ( std :: span < T , N > span , std :: span < T , M > sub ) { return std :: search ( span . begin (), span . end (), sub . begin (), sub . end ()) != span . end (); } void print ( const auto & seq ) { for ( const auto & elem : seq ) std :: cout << elem << ' ' ; std :: cout << '\\n' ; } int main () { constexpr int a []{ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; constexpr int b []{ 8 , 7 , 6 }; for ( std :: size_t offset {};; ++ offset ) { constexpr std :: size_t width { 6 }; auto s = slide ( std :: span { a }, offset , width ); if ( s . empty ()) break ; print ( s ); } static_assert ( starts_with ( std :: span { a }, std :: span { a , 4 }) && starts_with ( std :: span { a + 1 , 4 }, std :: span { a + 1 , 3 }) && ! starts_with ( std :: span { a }, std :: span { b }) && ! starts_with ( std :: span { a , 8 }, std :: span { a + 1 , 3 }) && ends_with ( std :: span { a }, std :: span { a + 6 , 3 }) && ! ends_with ( std :: span { a }, std :: span { a + 6 , 2 }) && contains ( std :: span { a }, std :: span { a + 1 , 4 }) && ! contains ( std :: span { a , 8 }, std :: span { a , 9 })); }","title":"Span"},{"location":"algorithms--data-structures/data-structures/spatial-containers/","text":"Spatial Containers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <iostream> #include <set> #include <pareto/spatial_map.h> int main () { using namespace std ; // Unlike a map<map<...>>, which represents a disjunction of indexes, // a spatial map represents a conjunction of indexes. pareto :: spatial_map < double , 2 , unsigned > m ; // Inserting m ( -2.5 , -1.5 ) = 17 ; m ( -2.1 , -0.5 ) = 32 ; m ( -1.6 , 0.9 ) = 36 ; m ( -0.6 , 0.9 ) = 13 ; m ( -0.5 , 0.8 ) = 32 ; // Querying nearest std :: cout << \"Closest elements to [0, 0]:\" << std :: endl ; for ( auto it = m . find_nearest ({ 0. , 0. }, 2 ); it != m . end (); ++ it ) { std :: cout << it -> first << \": \" << it -> second << std :: endl ; } // Querying intersection std :: cout << \"Elements between [-1, -1] and [+1, +1]:\" << std :: endl ; for ( auto it = m . find_intersection ({ -1. , -1. }, { + 1 , + 1 }); it != m . end (); ++ it ) { std :: cout << it -> first << \": \" << it -> second << std :: endl ; } }","title":"Spatial Containers"},{"location":"algorithms--data-structures/data-structures/spatial-containers/#spatial-containers","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <iostream> #include <set> #include <pareto/spatial_map.h> int main () { using namespace std ; // Unlike a map<map<...>>, which represents a disjunction of indexes, // a spatial map represents a conjunction of indexes. pareto :: spatial_map < double , 2 , unsigned > m ; // Inserting m ( -2.5 , -1.5 ) = 17 ; m ( -2.1 , -0.5 ) = 32 ; m ( -1.6 , 0.9 ) = 36 ; m ( -0.6 , 0.9 ) = 13 ; m ( -0.5 , 0.8 ) = 32 ; // Querying nearest std :: cout << \"Closest elements to [0, 0]:\" << std :: endl ; for ( auto it = m . find_nearest ({ 0. , 0. }, 2 ); it != m . end (); ++ it ) { std :: cout << it -> first << \": \" << it -> second << std :: endl ; } // Querying intersection std :: cout << \"Elements between [-1, -1] and [+1, +1]:\" << std :: endl ; for ( auto it = m . find_intersection ({ -1. , -1. }, { + 1 , + 1 }); it != m . end (); ++ it ) { std :: cout << it -> first << \": \" << it -> second << std :: endl ; } }","title":"Spatial Containers"},{"location":"algorithms--data-structures/date-and-time/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 add_executable ( clock clock.cpp ) find_package ( CURL QUIET ) if ( NOT CURL_FOUND ) set ( USE_SYSTEM_TZ_DB ON CACHE BOOL \"Build tz library\" FORCE ) else () set ( USE_SYSTEM_TZ_DB OFF CACHE BOOL \"Build tz library\" FORCE ) endif () message ( \"USE_SYSTEM_TZ_DB=${USE_SYSTEM_TZ_DB}\" ) set ( BUILD_TZ_LIB ON CACHE BOOL \"Build tz library\" FORCE ) FetchContent_Declare ( date GIT_REPOSITORY https://github.com/HowardHinnant/date.git GIT_TAG v3.0.0 ) FetchContent_MakeAvailable ( date ) target_compile_options ( date-tz PUBLIC -Wno-error=deprecated-declarations ) add_executable ( datetime datetime.cpp ) target_link_libraries ( datetime date date-tz )","title":"Build script"},{"location":"algorithms--data-structures/date-and-time/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 add_executable ( clock clock.cpp ) find_package ( CURL QUIET ) if ( NOT CURL_FOUND ) set ( USE_SYSTEM_TZ_DB ON CACHE BOOL \"Build tz library\" FORCE ) else () set ( USE_SYSTEM_TZ_DB OFF CACHE BOOL \"Build tz library\" FORCE ) endif () message ( \"USE_SYSTEM_TZ_DB=${USE_SYSTEM_TZ_DB}\" ) set ( BUILD_TZ_LIB ON CACHE BOOL \"Build tz library\" FORCE ) FetchContent_Declare ( date GIT_REPOSITORY https://github.com/HowardHinnant/date.git GIT_TAG v3.0.0 ) FetchContent_MakeAvailable ( date ) target_compile_options ( date-tz PUBLIC -Wno-error=deprecated-declarations ) add_executable ( datetime datetime.cpp ) target_link_libraries ( datetime date date-tz )","title":"Build script"},{"location":"algorithms--data-structures/date-and-time/clock/","text":"Clock 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #include <chrono> // std::chrono::seconds #include <ctime> // clock_t, clock, CLOCKS_PER_SEC #include <iostream> #include <thread> // std::this_thread::sleep_for void very_expensive_function (); using namespace std ; int main () { // Old C Clock // - The only method specified in the standard to measure CPU time // - It's up to the user to keep track of the duration unit // - It doesn't work well with threads though // - Note how the example ignores the time spent this_thread::sleep_for clock_t start , end ; double cpu_time_used ; start = clock (); very_expensive_function (); end = clock (); cpu_time_used = static_cast < float > ( end - start ) / CLOCKS_PER_SEC ; cout << \"cpu_time_used: \" << cpu_time_used << \" seconds\" << endl ; // Modern C++ // - System Clocks auto start2 = chrono :: system_clock :: now (); very_expensive_function (); auto end2 = chrono :: system_clock :: now (); // Duration represented with the default duration type auto auto_duration = end2 - start2 ; cout << \"auto_duration.count() : \" << auto_duration . count () << \" nanoseconds\" << endl ; // Duration represented with double, ratio in seconds chrono :: duration < double > seconds_as_double = end2 - start2 ; cout << \"seconds_as_double.count() : \" << seconds_as_double . count () << \" seconds\" << endl ; // Duration represented with int, ratio in milliseconds // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init) chrono :: duration < int , milli > milliseconds_as_int_ ; // Cast duration (double, seconds) to duration (int, milliseconds) milliseconds_as_int_ = chrono :: duration_cast < chrono :: duration < int , milli >> ( seconds_as_double ); cout << \"milliseconds_as_int_.count() : \" << milliseconds_as_int_ . count () << \" milliseconds\" << endl ; // Using ratio directly // Same as using hours constexpr int seconds_per_hour = 60 * 60 ; // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init) chrono :: duration < int , ratio < seconds_per_hour >> hours_as_int ; hours_as_int = chrono :: duration_cast < chrono :: duration < int , ratio < 60 * 60 >>> ( seconds_as_double ); cout << \"hours_as_int.count() : \" << hours_as_int . count () << \" hours\" << endl ; // Modern C++ // - Steady Clock auto start3 = chrono :: steady_clock :: now (); very_expensive_function (); auto end3 = chrono :: steady_clock :: now (); // Duration represented with the default duration type auto auto_duration_3 = end2 - start2 ; cout << \"auto_duration_3.count() : \" << auto_duration_3 . count () << \" nanoseconds\" << endl ; // Time in seconds as double chrono :: duration < double > seconds_as_double_3 = end3 - start3 ; cout << \"seconds_as_double_3.count() : \" << seconds_as_double_3 . count () << \" seconds\" << endl ; // Time in milliseconds as int // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init) chrono :: duration < int , milli > milliseconds_as_int_3 ; milliseconds_as_int_3 = chrono :: duration_cast < chrono :: duration < int , milli >> ( seconds_as_double_3 ); cout << \"milliseconds_as_int_3.count() : \" << milliseconds_as_int_3 . count () << \" milliseconds\" << endl ; // Time in hours as int // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init) chrono :: duration < int , ratio < seconds_per_hour >> hours_as_int3 ; // same as using hours hours_as_int3 = chrono :: duration_cast < chrono :: duration < int , ratio < seconds_per_hour >>> ( seconds_as_double_3 ); cout << \"hours_as_int3.count() : \" << hours_as_int3 . count () << \" hours\" << endl ; // \"Parsing\" time // While std::chrono::parse is not available in all main compilers auto hours = chrono :: duration_cast < chrono :: hours > ( auto_duration_3 ); if ( hours . count () > 0 ) { cout << hours . count () << \" hours\" ; } auto seconds = chrono :: duration_cast < chrono :: seconds > ( auto_duration_3 ); if ( seconds . count () > 0 ) { cout << seconds . count () << \" seconds\" ; } auto milliseconds = chrono :: duration_cast < chrono :: milliseconds > ( auto_duration_3 ); if ( milliseconds . count () > 0 ) { cout << milliseconds . count () << \" milliseconds\" ; } auto nanoseconds = chrono :: duration_cast < chrono :: nanoseconds > ( auto_duration_3 ); if ( nanoseconds . count () > 0 ) { cout << nanoseconds . count () << \" nanoseconds\" ; } return 0 ; } void very_expensive_function () { for ( int i = 0 ; i < 5 ; ++ i ) { cout << '*' << flush ; this_thread :: sleep_for ( chrono :: seconds ( 1 )); } cout << endl ; } Related examples: examples/datetime/flushtime.cpp","title":"Clock"},{"location":"algorithms--data-structures/date-and-time/clock/#clock","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #include <chrono> // std::chrono::seconds #include <ctime> // clock_t, clock, CLOCKS_PER_SEC #include <iostream> #include <thread> // std::this_thread::sleep_for void very_expensive_function (); using namespace std ; int main () { // Old C Clock // - The only method specified in the standard to measure CPU time // - It's up to the user to keep track of the duration unit // - It doesn't work well with threads though // - Note how the example ignores the time spent this_thread::sleep_for clock_t start , end ; double cpu_time_used ; start = clock (); very_expensive_function (); end = clock (); cpu_time_used = static_cast < float > ( end - start ) / CLOCKS_PER_SEC ; cout << \"cpu_time_used: \" << cpu_time_used << \" seconds\" << endl ; // Modern C++ // - System Clocks auto start2 = chrono :: system_clock :: now (); very_expensive_function (); auto end2 = chrono :: system_clock :: now (); // Duration represented with the default duration type auto auto_duration = end2 - start2 ; cout << \"auto_duration.count() : \" << auto_duration . count () << \" nanoseconds\" << endl ; // Duration represented with double, ratio in seconds chrono :: duration < double > seconds_as_double = end2 - start2 ; cout << \"seconds_as_double.count() : \" << seconds_as_double . count () << \" seconds\" << endl ; // Duration represented with int, ratio in milliseconds // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init) chrono :: duration < int , milli > milliseconds_as_int_ ; // Cast duration (double, seconds) to duration (int, milliseconds) milliseconds_as_int_ = chrono :: duration_cast < chrono :: duration < int , milli >> ( seconds_as_double ); cout << \"milliseconds_as_int_.count() : \" << milliseconds_as_int_ . count () << \" milliseconds\" << endl ; // Using ratio directly // Same as using hours constexpr int seconds_per_hour = 60 * 60 ; // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init) chrono :: duration < int , ratio < seconds_per_hour >> hours_as_int ; hours_as_int = chrono :: duration_cast < chrono :: duration < int , ratio < 60 * 60 >>> ( seconds_as_double ); cout << \"hours_as_int.count() : \" << hours_as_int . count () << \" hours\" << endl ; // Modern C++ // - Steady Clock auto start3 = chrono :: steady_clock :: now (); very_expensive_function (); auto end3 = chrono :: steady_clock :: now (); // Duration represented with the default duration type auto auto_duration_3 = end2 - start2 ; cout << \"auto_duration_3.count() : \" << auto_duration_3 . count () << \" nanoseconds\" << endl ; // Time in seconds as double chrono :: duration < double > seconds_as_double_3 = end3 - start3 ; cout << \"seconds_as_double_3.count() : \" << seconds_as_double_3 . count () << \" seconds\" << endl ; // Time in milliseconds as int // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init) chrono :: duration < int , milli > milliseconds_as_int_3 ; milliseconds_as_int_3 = chrono :: duration_cast < chrono :: duration < int , milli >> ( seconds_as_double_3 ); cout << \"milliseconds_as_int_3.count() : \" << milliseconds_as_int_3 . count () << \" milliseconds\" << endl ; // Time in hours as int // NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init) chrono :: duration < int , ratio < seconds_per_hour >> hours_as_int3 ; // same as using hours hours_as_int3 = chrono :: duration_cast < chrono :: duration < int , ratio < seconds_per_hour >>> ( seconds_as_double_3 ); cout << \"hours_as_int3.count() : \" << hours_as_int3 . count () << \" hours\" << endl ; // \"Parsing\" time // While std::chrono::parse is not available in all main compilers auto hours = chrono :: duration_cast < chrono :: hours > ( auto_duration_3 ); if ( hours . count () > 0 ) { cout << hours . count () << \" hours\" ; } auto seconds = chrono :: duration_cast < chrono :: seconds > ( auto_duration_3 ); if ( seconds . count () > 0 ) { cout << seconds . count () << \" seconds\" ; } auto milliseconds = chrono :: duration_cast < chrono :: milliseconds > ( auto_duration_3 ); if ( milliseconds . count () > 0 ) { cout << milliseconds . count () << \" milliseconds\" ; } auto nanoseconds = chrono :: duration_cast < chrono :: nanoseconds > ( auto_duration_3 ); if ( nanoseconds . count () > 0 ) { cout << nanoseconds . count () << \" nanoseconds\" ; } return 0 ; } void very_expensive_function () { for ( int i = 0 ; i < 5 ; ++ i ) { cout << '*' << flush ; this_thread :: sleep_for ( chrono :: seconds ( 1 )); } cout << endl ; } Related examples: examples/datetime/flushtime.cpp","title":"Clock"},{"location":"algorithms--data-structures/date-and-time/datetime/","text":"Datetime 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 #include <date/date.h> #include <date/tz.h> #include <iostream> int main () { // date.h contains chrono extensions to deal with dates // It has been incorporated into // References: // - https://howardhinnant.github.io/date/date.html // - https://howardhinnant.github.io/date/tz.html using namespace std ; using namespace std :: chrono ; // Printing time points // - UTC time zone and microsecond precision using date :: operator << ; const std :: chrono :: time_point now = system_clock :: now (); std :: cout << \"Now: \" << now << std :: endl ; std :: cout << \"Formatted: \" << date :: format ( \"%a, %b %d, %Y at %I:%M %p %Z\" , now ) << '\\n' ; std :: cout << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , now ) << '\\n' ; cout << \"Epoch: \" << time_point < system_clock > ( seconds ( 0 )) << endl ; // Days since 1970 represented as one integer // - This is a serial-based time-point // - Good for day oriented arithmetic date :: sys_days today = date :: floor < date :: days > ( now ); cout << \"today: \" << today . time_since_epoch (). count () << \" days since epoch\" << endl ; // Days since 1970 represented as 3 integers: year / month / day // - This is a field-based time-point // - Good for returning field values // - Good for month/year arithmetic // Last day of March / 2015 using namespace date :: literals ; date :: year_month_day t_ymd = 2015 _y / date :: March / 22 ; std :: cout << \"t_ymd: \" << t_ymd << std :: endl ; std :: cout << \"t_ymd since epoch: \" << date :: sys_days ( t_ymd ). time_since_epoch (). count () << std :: endl ; // Days since 1970 represented as 4 integers: year / month / week / weekday // This is a field-based time-point date :: year_month_weekday t_ymw = date :: year { 2015 } / date :: month { 3 } / date :: Monday [ 2 ]; std :: cout << \"t_ymw: \" << t_ymw << std :: endl ; std :: cout << \"t_ymw since epoch: \" << date :: sys_days ( t_ymw ). time_since_epoch (). count () << std :: endl ; std :: cout << \"year_month_day(t3): \" << date :: sys_days ( date :: year_month_day ( t_ymw )) . time_since_epoch () . count () << std :: endl ; // Converting to/from year/month/date auto today_ymd = date :: year_month_day { today }; cout << \"Today is \" << today_ymd << '\\n' ; // Durations // - Time since midnight (serial-based) auto time_since_midnight = now - today ; cout << \"Serial time since midnight \" << duration_cast < seconds > ( time_since_midnight ) << '\\n' ; // - Time since midnight (field-based) date :: hh_mm_ss time_since_midnight_hms ( time_since_midnight ); cout << \"Field-based time since midnight: \" << today_ymd << \" - \" << time_since_midnight_hms << endl ; auto time_since_midnight_tod = date :: make_time ( time_since_midnight ); cout << \"Field-based time since midnight: \" << today_ymd << \" - \" << time_since_midnight_tod << endl ; // Checking invalid field based dates // - It's possible and it might be useful cout << \"All odd fridays this year: \" ; date :: year this_year = today_ymd . year (); for ( auto m = 1 ; m <= 12 ; ++ m ) { auto first_friday = date :: year_month_day ( this_year / m / date :: Friday [ 1 ]); cout << first_friday << ' ' ; auto third_friday = first_friday . year () / first_friday . month () / ( first_friday . day () + weeks { 2 }); cout << third_friday << ' ' ; auto fifth_friday = third_friday . year () / third_friday . month () / ( third_friday . day () + weeks { 2 }); if ( fifth_friday . ok ()) { cout << fifth_friday << ' ' ; } } std :: cout << std :: endl ; // Dealing with time zones // - Zoned time is a wrapper that also keeps track of the shift from UTC date :: zoned_time local_tp = date :: make_zoned ( date :: current_zone (), now ); // - Little more efficient way. Less convenient unless reusing the zone ptr. auto berlin_zone = date :: locate_zone ( \"Europe/Berlin\" ); auto berlin_time = date :: make_zoned ( berlin_zone , floor < seconds > ( system_clock :: now ())); std :: cout << \"berlin time: \" << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , berlin_time ) << '\\n' ; // - Little less efficient way. More convenient. auto sp_time = date :: make_zoned ( \"America/Sao_Paulo\" , floor < seconds > ( system_clock :: now ())); std :: cout << \"sao paulo time: \" << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , sp_time ) << '\\n' ; // Time zone details std :: cout << \"local_tp: \" << local_tp << std :: endl ; std :: cout << \"offset: \" << local_tp . get_info (). offset << std :: endl ; std :: cout << \"save: \" << local_tp . get_info (). save << std :: endl ; std :: cout << \"abbrev: \" << local_tp . get_info (). abbrev << std :: endl ; std :: cout << \"Local time: \" << local_tp . get_local_time () << std :: endl ; std :: cout << \"Sys time: \" << local_tp . get_sys_time () << std :: endl ; std :: cout << \"Formatted: \" << date :: format ( \"%a, %b %d, %Y at %I:%M %p %Z\" , local_tp ) << '\\n' ; std :: cout << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , local_tp ) << '\\n' ; // Change precision auto now_nanoseconds = date :: floor < nanoseconds > ( now ); auto local_tp_nanoseconds = date :: make_zoned ( date :: current_zone (), now_nanoseconds ); std :: cout << \"In millisecs: \" << local_tp_nanoseconds << std :: endl ; auto now_milliseconds = date :: floor < milliseconds > ( now ); auto local_tp_milliseconds = date :: make_zoned ( date :: current_zone (), now_milliseconds ); std :: cout << \"In millisecs: \" << local_tp_milliseconds << std :: endl ; auto now_seconds = date :: floor < seconds > ( now ); auto local_tp_seconds = date :: make_zoned ( date :: current_zone (), now_seconds ); std :: cout << \"In secs: \" << local_tp_seconds << std :: endl ; auto now_hours = date :: floor < hours > ( now ); auto local_tp_hours = date :: make_zoned ( date :: current_zone (), now_hours ); std :: cout << \"In hours: \" << local_tp_hours << std :: endl ; auto now_days = date :: floor < days > ( now ); auto local_tp_days = date :: make_zoned ( date :: current_zone (), now_days ); std :: cout << \"In days: \" << local_tp_days << std :: endl ; // Convert time between zones auto tokyo_tp = date :: make_zoned ( \"Asia/Tokyo\" , sp_time ); std :: cout << sp_time << \" in sao paulo is \" << tokyo_tp << \" in tokyo\" << std :: endl ; return 0 ; }","title":"Datetime"},{"location":"algorithms--data-structures/date-and-time/datetime/#datetime","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 #include <date/date.h> #include <date/tz.h> #include <iostream> int main () { // date.h contains chrono extensions to deal with dates // It has been incorporated into // References: // - https://howardhinnant.github.io/date/date.html // - https://howardhinnant.github.io/date/tz.html using namespace std ; using namespace std :: chrono ; // Printing time points // - UTC time zone and microsecond precision using date :: operator << ; const std :: chrono :: time_point now = system_clock :: now (); std :: cout << \"Now: \" << now << std :: endl ; std :: cout << \"Formatted: \" << date :: format ( \"%a, %b %d, %Y at %I:%M %p %Z\" , now ) << '\\n' ; std :: cout << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , now ) << '\\n' ; cout << \"Epoch: \" << time_point < system_clock > ( seconds ( 0 )) << endl ; // Days since 1970 represented as one integer // - This is a serial-based time-point // - Good for day oriented arithmetic date :: sys_days today = date :: floor < date :: days > ( now ); cout << \"today: \" << today . time_since_epoch (). count () << \" days since epoch\" << endl ; // Days since 1970 represented as 3 integers: year / month / day // - This is a field-based time-point // - Good for returning field values // - Good for month/year arithmetic // Last day of March / 2015 using namespace date :: literals ; date :: year_month_day t_ymd = 2015 _y / date :: March / 22 ; std :: cout << \"t_ymd: \" << t_ymd << std :: endl ; std :: cout << \"t_ymd since epoch: \" << date :: sys_days ( t_ymd ). time_since_epoch (). count () << std :: endl ; // Days since 1970 represented as 4 integers: year / month / week / weekday // This is a field-based time-point date :: year_month_weekday t_ymw = date :: year { 2015 } / date :: month { 3 } / date :: Monday [ 2 ]; std :: cout << \"t_ymw: \" << t_ymw << std :: endl ; std :: cout << \"t_ymw since epoch: \" << date :: sys_days ( t_ymw ). time_since_epoch (). count () << std :: endl ; std :: cout << \"year_month_day(t3): \" << date :: sys_days ( date :: year_month_day ( t_ymw )) . time_since_epoch () . count () << std :: endl ; // Converting to/from year/month/date auto today_ymd = date :: year_month_day { today }; cout << \"Today is \" << today_ymd << '\\n' ; // Durations // - Time since midnight (serial-based) auto time_since_midnight = now - today ; cout << \"Serial time since midnight \" << duration_cast < seconds > ( time_since_midnight ) << '\\n' ; // - Time since midnight (field-based) date :: hh_mm_ss time_since_midnight_hms ( time_since_midnight ); cout << \"Field-based time since midnight: \" << today_ymd << \" - \" << time_since_midnight_hms << endl ; auto time_since_midnight_tod = date :: make_time ( time_since_midnight ); cout << \"Field-based time since midnight: \" << today_ymd << \" - \" << time_since_midnight_tod << endl ; // Checking invalid field based dates // - It's possible and it might be useful cout << \"All odd fridays this year: \" ; date :: year this_year = today_ymd . year (); for ( auto m = 1 ; m <= 12 ; ++ m ) { auto first_friday = date :: year_month_day ( this_year / m / date :: Friday [ 1 ]); cout << first_friday << ' ' ; auto third_friday = first_friday . year () / first_friday . month () / ( first_friday . day () + weeks { 2 }); cout << third_friday << ' ' ; auto fifth_friday = third_friday . year () / third_friday . month () / ( third_friday . day () + weeks { 2 }); if ( fifth_friday . ok ()) { cout << fifth_friday << ' ' ; } } std :: cout << std :: endl ; // Dealing with time zones // - Zoned time is a wrapper that also keeps track of the shift from UTC date :: zoned_time local_tp = date :: make_zoned ( date :: current_zone (), now ); // - Little more efficient way. Less convenient unless reusing the zone ptr. auto berlin_zone = date :: locate_zone ( \"Europe/Berlin\" ); auto berlin_time = date :: make_zoned ( berlin_zone , floor < seconds > ( system_clock :: now ())); std :: cout << \"berlin time: \" << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , berlin_time ) << '\\n' ; // - Little less efficient way. More convenient. auto sp_time = date :: make_zoned ( \"America/Sao_Paulo\" , floor < seconds > ( system_clock :: now ())); std :: cout << \"sao paulo time: \" << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , sp_time ) << '\\n' ; // Time zone details std :: cout << \"local_tp: \" << local_tp << std :: endl ; std :: cout << \"offset: \" << local_tp . get_info (). offset << std :: endl ; std :: cout << \"save: \" << local_tp . get_info (). save << std :: endl ; std :: cout << \"abbrev: \" << local_tp . get_info (). abbrev << std :: endl ; std :: cout << \"Local time: \" << local_tp . get_local_time () << std :: endl ; std :: cout << \"Sys time: \" << local_tp . get_sys_time () << std :: endl ; std :: cout << \"Formatted: \" << date :: format ( \"%a, %b %d, %Y at %I:%M %p %Z\" , local_tp ) << '\\n' ; std :: cout << date :: format ( std :: locale ( \"de_DE\" ), \"%a, %b %d, %Y at %T %Z\" , local_tp ) << '\\n' ; // Change precision auto now_nanoseconds = date :: floor < nanoseconds > ( now ); auto local_tp_nanoseconds = date :: make_zoned ( date :: current_zone (), now_nanoseconds ); std :: cout << \"In millisecs: \" << local_tp_nanoseconds << std :: endl ; auto now_milliseconds = date :: floor < milliseconds > ( now ); auto local_tp_milliseconds = date :: make_zoned ( date :: current_zone (), now_milliseconds ); std :: cout << \"In millisecs: \" << local_tp_milliseconds << std :: endl ; auto now_seconds = date :: floor < seconds > ( now ); auto local_tp_seconds = date :: make_zoned ( date :: current_zone (), now_seconds ); std :: cout << \"In secs: \" << local_tp_seconds << std :: endl ; auto now_hours = date :: floor < hours > ( now ); auto local_tp_hours = date :: make_zoned ( date :: current_zone (), now_hours ); std :: cout << \"In hours: \" << local_tp_hours << std :: endl ; auto now_days = date :: floor < days > ( now ); auto local_tp_days = date :: make_zoned ( date :: current_zone (), now_days ); std :: cout << \"In days: \" << local_tp_days << std :: endl ; // Convert time between zones auto tokyo_tp = date :: make_zoned ( \"Asia/Tokyo\" , sp_time ); std :: cout << sp_time << \" in sao paulo is \" << tokyo_tp << \" in tokyo\" << std :: endl ; return 0 ; }","title":"Datetime"},{"location":"algorithms--data-structures/heterogeneous-types/any/","text":"Any 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <any> #include <iostream> #include <numeric> #include <vector> using namespace std ; int main () { // any is a container for single values of any type // - be careful when using it cout << boolalpha ; // any type any a = 1 ; cout << a . type (). name () << \": \" << any_cast < int > ( a ) << '\\n' ; a = 3.14 ; cout << a . type (). name () << \": \" << any_cast < double > ( a ) << '\\n' ; a = true ; cout << a . type (). name () << \": \" << any_cast < bool > ( a ) << '\\n' ; a = string ( \"Any string\" ); cout << a . type (). name () << \": \" << any_cast < string > ( a ) << '\\n' ; try { any a = 1 ; cout << any_cast < float > ( a ) << '\\n' ; } catch ( bad_any_cast & e ) { cout << e . what () << '\\n' ; } any s2 = 1 ; if ( ! s2 . has_value ()) { const type_info & ti = s2 . type (); cout << ti . name () << '\\n' ; } any a3 = 1 ; int * i = any_cast < int > ( & a3 ); cout << * i << '\\n' ; return 0 ; }","title":"Any"},{"location":"algorithms--data-structures/heterogeneous-types/any/#any","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <any> #include <iostream> #include <numeric> #include <vector> using namespace std ; int main () { // any is a container for single values of any type // - be careful when using it cout << boolalpha ; // any type any a = 1 ; cout << a . type (). name () << \": \" << any_cast < int > ( a ) << '\\n' ; a = 3.14 ; cout << a . type (). name () << \": \" << any_cast < double > ( a ) << '\\n' ; a = true ; cout << a . type (). name () << \": \" << any_cast < bool > ( a ) << '\\n' ; a = string ( \"Any string\" ); cout << a . type (). name () << \": \" << any_cast < string > ( a ) << '\\n' ; try { any a = 1 ; cout << any_cast < float > ( a ) << '\\n' ; } catch ( bad_any_cast & e ) { cout << e . what () << '\\n' ; } any s2 = 1 ; if ( ! s2 . has_value ()) { const type_info & ti = s2 . type (); cout << ti . name () << '\\n' ; } any a3 = 1 ; int * i = any_cast < int > ( & a3 ); cout << * i << '\\n' ; return 0 ; }","title":"Any"},{"location":"algorithms--data-structures/heterogeneous-types/build-script/","text":"Build script 1 2 3 4 5 6 7 8 # Heterogeneous data structures add_executable ( tuples tuples.cpp ) add_executable ( variant variant.cpp ) add_executable ( any any.cpp ) add_executable ( optional optional.cpp )","title":"Build script"},{"location":"algorithms--data-structures/heterogeneous-types/build-script/#build-script","text":"1 2 3 4 5 6 7 8 # Heterogeneous data structures add_executable ( tuples tuples.cpp ) add_executable ( variant variant.cpp ) add_executable ( any any.cpp ) add_executable ( optional optional.cpp )","title":"Build script"},{"location":"algorithms--data-structures/heterogeneous-types/optional/","text":"Optional 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include <iostream> #include <numeric> #include <optional> #include <unordered_map> #include <ctime> #include <cmath> using namespace std ; // Clearly mark optional values optional < int > get_even_random_number () { // std::rand() has limited randomness (use C++ <random> instead> int i = std :: rand (); if ( i % 2 == 0 ) { return i ; } else { return nullopt ; } } optional < int > get_even_random_number2 () { // std::rand() has limited randomness (use C++ <random> instead> int i = std :: rand (); return make_optional ( int ( i % 2 == 0 )); } int main () { auto entropy_source = static_cast < unsigned int > ( std :: time ( nullptr )); std :: srand ( entropy_source ); std :: cout << \"Optional variables:\" << std :: endl ; { optional < int > i = get_even_random_number (); if ( i ) { std :: cout << std :: sqrt ( static_cast < float > ( * i )) << '\\n' ; } else { std :: cout << \"No value was returned\" << '\\n' ; } i = get_even_random_number2 (); double d = i . value_or ( 0 ); std :: cout << std :: sqrt ( d ) << '\\n' ; std :: cout << i . value_or ( 0 ) << std :: endl ; } return 0 ; }","title":"Optional"},{"location":"algorithms--data-structures/heterogeneous-types/optional/#optional","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include <iostream> #include <numeric> #include <optional> #include <unordered_map> #include <ctime> #include <cmath> using namespace std ; // Clearly mark optional values optional < int > get_even_random_number () { // std::rand() has limited randomness (use C++ <random> instead> int i = std :: rand (); if ( i % 2 == 0 ) { return i ; } else { return nullopt ; } } optional < int > get_even_random_number2 () { // std::rand() has limited randomness (use C++ <random> instead> int i = std :: rand (); return make_optional ( int ( i % 2 == 0 )); } int main () { auto entropy_source = static_cast < unsigned int > ( std :: time ( nullptr )); std :: srand ( entropy_source ); std :: cout << \"Optional variables:\" << std :: endl ; { optional < int > i = get_even_random_number (); if ( i ) { std :: cout << std :: sqrt ( static_cast < float > ( * i )) << '\\n' ; } else { std :: cout << \"No value was returned\" << '\\n' ; } i = get_even_random_number2 (); double d = i . value_or ( 0 ); std :: cout << std :: sqrt ( d ) << '\\n' ; std :: cout << i . value_or ( 0 ) << std :: endl ; } return 0 ; }","title":"Optional"},{"location":"algorithms--data-structures/heterogeneous-types/tuples/","text":"Tuples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include <iostream> #include <tuple> #include <unordered_map> void reference_minmax ( int a , int b , int & min , int & max ) { if ( a < b ) { min = a ; max = b ; } else { min = b ; max = a ; } } std :: tuple < int , int > tuple_minmax ( int a , int b ) { std :: tuple < int , int > t ; if ( a < b ) { std :: get < 0 > ( t ) = a ; std :: get < 1 > ( t ) = b ; } else { std :: get < 0 > ( t ) = b ; std :: get < 1 > ( t ) = a ; } return t ; } int main () { // Structure for results struct my_pair { char first ; int second ; }; my_pair s { 'c' , 15 }; std :: cout << \"s.first: \" << s . first << \", s.second: \" << s . second << std :: endl ; // Tuples std :: pair < char , int > t ( 'c' , 15 ); std :: cout << \"t.first: \" << t . first << \", t.second: \" << t . second << std :: endl ; // Using auto auto t2 = std :: make_pair < char , int > ( 'c' , 15 ); std :: cout << \"t2.first: \" << t2 . first << \", t2.second: \" << t2 . second << std :: endl ; // Larger tuple auto t3 = std :: make_tuple ( 6.3 , \"texto\" , 2 , 'o' ); char x = std :: get < 3 > ( t3 ); std :: cout << \"x: \" << x << std :: endl ; std :: cout << \"std::get<0>(t3): \" << std :: get < 0 > ( t3 ) << \", std::get<1>(t3): \" << std :: get < 1 > ( t3 ) << std :: endl ; // Tie int a ; char b ; std :: tie ( std :: ignore , std :: ignore , a , b ) = t3 ; std :: cout << \"a: \" << a << std :: endl ; std :: cout << \"b: \" << b << std :: endl ; // \"Returning\" by reference int min ; int max ; reference_minmax ( 3 , 2 , min , max ); std :: cout << \"min : \" << min << std :: endl ; std :: cout << \"max : \" << max << std :: endl ; // Returning a tuple auto t4 = tuple_minmax ( 3 , 2 ); std :: cout << \"min : \" << std :: get < 0 > ( t4 ) << std :: endl ; std :: cout << \"max : \" << std :: get < 1 > ( t4 ) << std :: endl ; // Unpackaging the tuple int min2 ; int max2 ; std :: tie ( min2 , max2 ) = tuple_minmax ( 3 , 2 ); std :: cout << \"min : \" << min2 << std :: endl ; std :: cout << \"max : \" << max2 << std :: endl ; // Structured binding auto [ min3 , max3 ] = tuple_minmax ( 3 , 2 ); std :: cout << \"min : \" << min3 << std :: endl ; std :: cout << \"max : \" << max3 << std :: endl ; return 0 ; }","title":"Tuples"},{"location":"algorithms--data-structures/heterogeneous-types/tuples/#tuples","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 #include <iostream> #include <tuple> #include <unordered_map> void reference_minmax ( int a , int b , int & min , int & max ) { if ( a < b ) { min = a ; max = b ; } else { min = b ; max = a ; } } std :: tuple < int , int > tuple_minmax ( int a , int b ) { std :: tuple < int , int > t ; if ( a < b ) { std :: get < 0 > ( t ) = a ; std :: get < 1 > ( t ) = b ; } else { std :: get < 0 > ( t ) = b ; std :: get < 1 > ( t ) = a ; } return t ; } int main () { // Structure for results struct my_pair { char first ; int second ; }; my_pair s { 'c' , 15 }; std :: cout << \"s.first: \" << s . first << \", s.second: \" << s . second << std :: endl ; // Tuples std :: pair < char , int > t ( 'c' , 15 ); std :: cout << \"t.first: \" << t . first << \", t.second: \" << t . second << std :: endl ; // Using auto auto t2 = std :: make_pair < char , int > ( 'c' , 15 ); std :: cout << \"t2.first: \" << t2 . first << \", t2.second: \" << t2 . second << std :: endl ; // Larger tuple auto t3 = std :: make_tuple ( 6.3 , \"texto\" , 2 , 'o' ); char x = std :: get < 3 > ( t3 ); std :: cout << \"x: \" << x << std :: endl ; std :: cout << \"std::get<0>(t3): \" << std :: get < 0 > ( t3 ) << \", std::get<1>(t3): \" << std :: get < 1 > ( t3 ) << std :: endl ; // Tie int a ; char b ; std :: tie ( std :: ignore , std :: ignore , a , b ) = t3 ; std :: cout << \"a: \" << a << std :: endl ; std :: cout << \"b: \" << b << std :: endl ; // \"Returning\" by reference int min ; int max ; reference_minmax ( 3 , 2 , min , max ); std :: cout << \"min : \" << min << std :: endl ; std :: cout << \"max : \" << max << std :: endl ; // Returning a tuple auto t4 = tuple_minmax ( 3 , 2 ); std :: cout << \"min : \" << std :: get < 0 > ( t4 ) << std :: endl ; std :: cout << \"max : \" << std :: get < 1 > ( t4 ) << std :: endl ; // Unpackaging the tuple int min2 ; int max2 ; std :: tie ( min2 , max2 ) = tuple_minmax ( 3 , 2 ); std :: cout << \"min : \" << min2 << std :: endl ; std :: cout << \"max : \" << max2 << std :: endl ; // Structured binding auto [ min3 , max3 ] = tuple_minmax ( 3 , 2 ); std :: cout << \"min : \" << min3 << std :: endl ; std :: cout << \"max : \" << max3 << std :: endl ; return 0 ; }","title":"Tuples"},{"location":"algorithms--data-structures/heterogeneous-types/variant/","text":"Variant 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include <iostream> #include <numeric> #include <variant> #include <vector> using namespace std ; union my_union { double a ; char b ; int c ; }; int main () { // The old union // - It only works with fundamental data type // - It doesn't have many convenience function my_union u = { 3.14 }; u = { 'A' }; u = { 15 }; // Variant types // - Only use variant types if you really need it variant < double , char , string > v ; v = 3.14 ; v = 'A' ; v = \"Some longer text\" ; visit ([]( auto x ) { cout << x << '\\n' ; }, v ); v = 3.14 ; cout << get < double > ( v ) << endl ; v = 'A' ; cout << get < char > ( v ) << endl ; v = \"Some longer text\" ; cout << get < string > ( v ) << endl ; switch ( v . index ()) { case 0 : cout << \"This is a double\" << endl ; break ; case 1 : cout << \"This is a char\" << endl ; break ; case 2 : cout << \"This is a string\" << endl ; break ; } return 0 ; }","title":"Variant"},{"location":"algorithms--data-structures/heterogeneous-types/variant/#variant","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include <iostream> #include <numeric> #include <variant> #include <vector> using namespace std ; union my_union { double a ; char b ; int c ; }; int main () { // The old union // - It only works with fundamental data type // - It doesn't have many convenience function my_union u = { 3.14 }; u = { 'A' }; u = { 15 }; // Variant types // - Only use variant types if you really need it variant < double , char , string > v ; v = 3.14 ; v = 'A' ; v = \"Some longer text\" ; visit ([]( auto x ) { cout << x << '\\n' ; }, v ); v = 3.14 ; cout << get < double > ( v ) << endl ; v = 'A' ; cout << get < char > ( v ) << endl ; v = \"Some longer text\" ; cout << get < string > ( v ) << endl ; switch ( v . index ()) { case 0 : cout << \"This is a double\" << endl ; break ; case 1 : cout << \"This is a char\" << endl ; break ; case 2 : cout << \"This is a string\" << endl ; break ; } return 0 ; }","title":"Variant"},{"location":"algorithms--data-structures/random/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 10 11 add_executable ( random random.cpp ) FetchContent_Declare ( pcg-cpp GIT_REPOSITORY https://github.com/imneme/pcg-cpp.git GIT_TAG v0.98.1 ) FetchContent_GetProperties ( pcg-cpp ) if ( NOT pcg-cpp_POPULATED ) FetchContent_Populate ( pcg-cpp ) add_library ( pcg-cpp INTERFACE ) target_include_directories ( pcg-cpp INTERFACE ${ pcg-cpp_SOURCE_DIR } /include ) endif () add_executable ( pcg pcg.cpp ) target_link_libraries ( pcg pcg-cpp )","title":"Build script"},{"location":"algorithms--data-structures/random/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 10 11 add_executable ( random random.cpp ) FetchContent_Declare ( pcg-cpp GIT_REPOSITORY https://github.com/imneme/pcg-cpp.git GIT_TAG v0.98.1 ) FetchContent_GetProperties ( pcg-cpp ) if ( NOT pcg-cpp_POPULATED ) FetchContent_Populate ( pcg-cpp ) add_library ( pcg-cpp INTERFACE ) target_include_directories ( pcg-cpp INTERFACE ${ pcg-cpp_SOURCE_DIR } /include ) endif () add_executable ( pcg pcg.cpp ) target_link_libraries ( pcg pcg-cpp )","title":"Build script"},{"location":"algorithms--data-structures/random/pcg/","text":"PCG 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include <iostream> #include <random> #include <pcg_random.hpp> using namespace std ; int main () { // Initialize with two fixed seeds pcg32 rng ( 42u , 54u ); // Seed with external entropy rng . seed ( pcg_extras :: seed_seq_from < std :: random_device > ()); // Random number std :: cout << \"Random number: \" << rng () << std :: endl ; std :: cout << \"Random number: \" << rng () << std :: endl ; std :: cout << \"Random number: \" << rng () << std :: endl ; // Flip coins std :: cout << \"Flip coin: \" << rng ( 2 ) << std :: endl ; std :: cout << \"Flip coin: \" << rng ( 2 ) << std :: endl ; std :: cout << \"Flip coin: \" << rng ( 2 ) << std :: endl ; // Roll dice std :: cout << \"Roll dice: \" << rng ( 6 ) << std :: endl ; std :: cout << \"Roll dice: \" << rng ( 6 ) << std :: endl ; std :: cout << \"Roll dice: \" << rng ( 6 ) << std :: endl ; // Print generator state std :: cout << \"Generator state: \" << rng << std :: endl ; std :: cout << \"Result size: \" << sizeof ( pcg32 :: result_type ) * 8 << \"bits\" << std :: endl ; std :: cout << \"Period: 2^\" << pcg32 :: period_pow2 () << std :: endl ; // C++ distributions uniform_real_distribution < double > distribution ( 1.0 , 10.0 ); cout << distribution ( rng ) << endl ; return 0 ; }","title":"PCG"},{"location":"algorithms--data-structures/random/pcg/#pcg","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include <iostream> #include <random> #include <pcg_random.hpp> using namespace std ; int main () { // Initialize with two fixed seeds pcg32 rng ( 42u , 54u ); // Seed with external entropy rng . seed ( pcg_extras :: seed_seq_from < std :: random_device > ()); // Random number std :: cout << \"Random number: \" << rng () << std :: endl ; std :: cout << \"Random number: \" << rng () << std :: endl ; std :: cout << \"Random number: \" << rng () << std :: endl ; // Flip coins std :: cout << \"Flip coin: \" << rng ( 2 ) << std :: endl ; std :: cout << \"Flip coin: \" << rng ( 2 ) << std :: endl ; std :: cout << \"Flip coin: \" << rng ( 2 ) << std :: endl ; // Roll dice std :: cout << \"Roll dice: \" << rng ( 6 ) << std :: endl ; std :: cout << \"Roll dice: \" << rng ( 6 ) << std :: endl ; std :: cout << \"Roll dice: \" << rng ( 6 ) << std :: endl ; // Print generator state std :: cout << \"Generator state: \" << rng << std :: endl ; std :: cout << \"Result size: \" << sizeof ( pcg32 :: result_type ) * 8 << \"bits\" << std :: endl ; std :: cout << \"Period: 2^\" << pcg32 :: period_pow2 () << std :: endl ; // C++ distributions uniform_real_distribution < double > distribution ( 1.0 , 10.0 ); cout << distribution ( rng ) << endl ; return 0 ; }","title":"PCG"},{"location":"algorithms--data-structures/random/random/","text":"Random 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include <iostream> #include <random> #include <chrono> using namespace std ; static constexpr uint32_t fnv ( uint32_t hash , const char * pos ) { return * pos == '\\0' ? hash : fnv (( hash * 16777619U ) ^ * pos , pos + 1 ); } int main () { // Operating system number generator (usually high-cost) random_device rd ; // Generate seed for low cost generator unsigned int seed = rd (); // Mix seed with some more imaginable cross-platform entropy sources // - Current time seed ^= static_cast < unsigned int > ( chrono :: system_clock :: now (). time_since_epoch (). count ()); // - Compile stamp constexpr uint32_t compile_stamp = fnv ( 2166136261U , __DATE__ __TIME__ __FILE__ ); seed ^= static_cast < unsigned int > ( compile_stamp ); // - A heap address void * heap_addr = malloc ( sizeof ( int )); seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > ( heap_addr )); // - A stack address seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > ( & heap_addr )); free ( heap_addr ); // - A fixed counter seed ^= static_cast < unsigned int > ( 45 ); // - The time function address seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > ( & std :: chrono :: system_clock :: now )); // - The exit function address seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > (( void * ) & _Exit )); // - The generator type hash code seed ^= static_cast < unsigned int > ( typeid ( random_device ). hash_code ()); // Use seed for a low-cost generator (supposedly) default_random_engine g ( seed ); // Create a distribution uniform_real_distribution < double > distribution ( 1.0 , 10.0 ); // Using the machine with that distribution cout << distribution ( g ) << endl ; // Create a mt19937 generator instead of default_random_engine mt19937 g2 { seed }; // Creating a normal distribution (very cheap) normal_distribution < double > d2 ( 0.0 , 1.0 ); // Using the machine with that distribution cout << d2 ( g2 ) << endl ; // Generate a histogram vector < int > hist ( 10 , 0 ); for ( int i = 0 ; i < 300 ; ++ i ) { auto bin = d2 ( g2 ) + static_cast < double > ( hist . size ()) / 2 ; if ( bin >= 0. && static_cast < size_t > ( bin ) < hist . size ()) { ++ hist [ static_cast < size_t > ( bin )]; } } for ( int n : hist ) { cout << '-' ; for ( int j = 0 ; j < n ; ++ j ) { cout << '*' ; } cout << endl ; } return 0 ; }","title":"Random"},{"location":"algorithms--data-structures/random/random/#random","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include <iostream> #include <random> #include <chrono> using namespace std ; static constexpr uint32_t fnv ( uint32_t hash , const char * pos ) { return * pos == '\\0' ? hash : fnv (( hash * 16777619U ) ^ * pos , pos + 1 ); } int main () { // Operating system number generator (usually high-cost) random_device rd ; // Generate seed for low cost generator unsigned int seed = rd (); // Mix seed with some more imaginable cross-platform entropy sources // - Current time seed ^= static_cast < unsigned int > ( chrono :: system_clock :: now (). time_since_epoch (). count ()); // - Compile stamp constexpr uint32_t compile_stamp = fnv ( 2166136261U , __DATE__ __TIME__ __FILE__ ); seed ^= static_cast < unsigned int > ( compile_stamp ); // - A heap address void * heap_addr = malloc ( sizeof ( int )); seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > ( heap_addr )); // - A stack address seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > ( & heap_addr )); free ( heap_addr ); // - A fixed counter seed ^= static_cast < unsigned int > ( 45 ); // - The time function address seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > ( & std :: chrono :: system_clock :: now )); // - The exit function address seed ^= static_cast < unsigned int > ( reinterpret_cast < uintptr_t > (( void * ) & _Exit )); // - The generator type hash code seed ^= static_cast < unsigned int > ( typeid ( random_device ). hash_code ()); // Use seed for a low-cost generator (supposedly) default_random_engine g ( seed ); // Create a distribution uniform_real_distribution < double > distribution ( 1.0 , 10.0 ); // Using the machine with that distribution cout << distribution ( g ) << endl ; // Create a mt19937 generator instead of default_random_engine mt19937 g2 { seed }; // Creating a normal distribution (very cheap) normal_distribution < double > d2 ( 0.0 , 1.0 ); // Using the machine with that distribution cout << d2 ( g2 ) << endl ; // Generate a histogram vector < int > hist ( 10 , 0 ); for ( int i = 0 ; i < 300 ; ++ i ) { auto bin = d2 ( g2 ) + static_cast < double > ( hist . size ()) / 2 ; if ( bin >= 0. && static_cast < size_t > ( bin ) < hist . size ()) { ++ hist [ static_cast < size_t > ( bin )]; } } for ( int n : hist ) { cout << '-' ; for ( int j = 0 ; j < n ; ++ j ) { cout << '*' ; } cout << endl ; } return 0 ; }","title":"Random"},{"location":"algorithms--data-structures/template/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 10 11 add_executable ( template_functions template_functions.cpp ) add_executable ( template_alias template_alias.cpp ) find_package ( Concepts ) if ( Concepts_FOUND ) add_executable ( concepts concepts.cpp ) else () message ( \"Your compiler does not support *concepts* yet\" ) endif () add_executable ( sfinae sfinae.cpp )","title":"Build script"},{"location":"algorithms--data-structures/template/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 10 11 add_executable ( template_functions template_functions.cpp ) add_executable ( template_alias template_alias.cpp ) find_package ( Concepts ) if ( Concepts_FOUND ) add_executable ( concepts concepts.cpp ) else () message ( \"Your compiler does not support *concepts* yet\" ) endif () add_executable ( sfinae sfinae.cpp )","title":"Build script"},{"location":"algorithms--data-structures/template/concepts/","text":"Concepts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 #include <array> #include <concepts> #include <iostream> #include <type_traits> #include <vector> // Define concepts with a compile-time boolean predicate // - is_arithmetic_v might be misleading since it also includes bool // - is_arithmetic_v might be misleading since it doesn't include std::complex template < typename T > concept Number = std :: is_arithmetic_v < T > ; template < typename T > concept NotNumber = ! Number < T > ; // Define concept from conjunction of constraints template < typename T > concept SignedNumber = Number < T > && std :: is_signed_v < T > ; template < typename T > concept UnsignedNumber = Number < T > && ! std :: is_signed_v < T > ; // Define concept from disjunction of constraints template < typename T1 , typename T2 > concept Equivalent = std :: is_convertible_v < T1 , T2 > || std :: is_same_v < T1 , T2 > ; // Define concept from simple requires-expression // These expressions must be something that will compile template < typename T > concept Range = requires ( T r ) { * r . begin (); * r . end (); }; // Typename requirement (e.g. check type exists) // Define concept from typename requires-expression // These expressions must something that will compile template < typename T > concept HasValueType = requires ( T r ) { typename T :: value_type ; // required nested name }; // Compound requirement // Two requirements at the same time template < typename T > concept Pair = requires ( T p ) { { p . first }; { p . second }; }; // Typename requirement with type constraint // The expression should not only compile but it should also have // a type that passes the concept after -> template < typename T > concept IntPair = requires ( T p ) { { p . first } -> std :: same_as < int > ; { p . second } -> std :: same_as < int > ; }; // Requirement with two parameters template < typename T > concept EqualityComparable = requires ( T a , T b ) { { a == b }; { a != b }; }; // Nested requirements // Additional constraint to existing constraints // Functions can use Range or RangeSameType now without // ambiguity template < typename T > concept PairSameType = Pair < T > && requires ( T p ) { { p . first } -> std :: same_as < decltype ( p . second ) > ; }; // Nested requirements without requires template < typename T > concept RangeWithValueType = Range < T > && HasValueType < T > ; template < typename T > concept RangeWithoutValueType = Range < T > && ! HasValueType < T > ; // Constrain with template type // Number, but nor SignedNumber neither UnsignedNumber template < Number T > void max_value ( T a , T b ) { if ( a > b ) { std :: cout << \"max_value: \" << a << std :: endl ; } else { std :: cout << \"max_value: \" << b << std :: endl ; } } // Constrain with template type // Number -> SignedNumber template < SignedNumber T > void max_value ( T a , T b ) { if ( a > b ) { if ( a > 0 ) { std :: cout << \"max_value: positive \" << a << std :: endl ; } else { std :: cout << \"max_value: negative \" << - a << std :: endl ; } } else { if ( b > 0 ) { std :: cout << \"max_value: positive \" << b << std :: endl ; } else { std :: cout << \"max_value: negative \" << - b << std :: endl ; } } } // Constrain with template type // Number -> UnsignedNumber template < UnsignedNumber T > void max_value ( T a , T b ) { if ( a > b ) { std :: cout << \"max_value: +\" << a << std :: endl ; } else { std :: cout << \"max_value: +\" << b << std :: endl ; } } // Constrain with template type // NotNumber == !Number<T> template < NotNumber T > void max_value ( T a , T b ) { std :: cout << \"a: \" << a << std :: endl ; std :: cout << \"b: \" << b << std :: endl ; } // Unconstrained function (Not range) template < class T > void print_element ( const T & c ) { std :: cout << c << std :: endl ; } // Constrained with template type // - The most constrained concept is used template < Range T > void print_element ( const T & c ) { for ( const auto & item : c ) { std :: cout << item << ' ' ; } std :: cout << std :: endl ; } // Constrain the same function with a more constrained template type // - The most constrained concept is used in nested constraints template < RangeWithValueType T > void print_element ( const T & c ) { std :: cout << typeid ( typename T :: value_type ). name () << \": \" ; for ( const auto & item : c ) { std :: cout << item << ' ' ; } std :: cout << std :: endl ; } // Constrain with require-clause directly in function declaration template < typename T > requires EqualityComparable < T > void compare ( const T & a , const T & b ) { if ( a == b ) { std :: cout << a << \" == \" << b << \" is \" << ( a == b ? \"true\" : \"false\" ) << std :: endl ; } else { std :: cout << a << \" != \" << b << \" is \" << ( a != b ? \"true\" : \"false\" ) << std :: endl ; } } // Unconstrained version template < typename T > void compare ( const T & a , const T & b ) { std :: cout << typeid ( T ). name () << \": \" << a . c << \" == \" << b . c << \"?\" << std :: endl ; } struct nonComparableStruct { double c { 0. }; }; // Constrain with template type template < Pair T > void print_pair ( const T & p ) { std :: cout << typeid ( p . first ). name () << \": \" << p . first << \" == \" << typeid ( p . second ). name () << \": \" << p . second << std :: endl ; } // Constrain again with more specific requirement template < PairSameType T > void print_pair ( const T & p ) { std :: cout << typeid ( p . first ). name () << \": \" << p . first << \" == \" << p . second << std :: endl ; } int main () { /* * \\see https://en.cppreference.com/w/cpp/language/constraints */ max_value ( 5 , 7 ); max_value ( 4 , 7 ); max_value ( \"foo\" , \"bar\" ); print_element ( std :: vector < int > { 2 , 4 , 6 , 4 }); print_element ( 56 ); compare ( 4 , 7 ); compare ( nonComparableStruct { 1.0 }, nonComparableStruct { 2.0 }); print_pair ( std :: make_pair ( 1 , 2 )); print_pair ( std :: make_pair ( 1.6 , 2 )); return 0 ; } FindConcepts.cmake: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 include ( CheckCXXSourceCompiles ) check_cxx_source_compiles ( \" #include <concepts> #include <type_traits> template <typename T> concept Number = std::is_arithmetic_v<T>; int main() { return 0; } \" Concepts_FOUND ) if ( Concepts_FOUND AND NOT ( TARGET std::concepts )) add_library ( std::concepts INTERFACE IMPORTED ) set_target_properties ( std::concepts PROPERTIES INTERFACE_COMPILE_OPTIONS $< $<COMPILE_LANGUAGE:CXX > :-fconcepts> ) endif ()","title":"Concepts"},{"location":"algorithms--data-structures/template/concepts/#concepts","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 #include <array> #include <concepts> #include <iostream> #include <type_traits> #include <vector> // Define concepts with a compile-time boolean predicate // - is_arithmetic_v might be misleading since it also includes bool // - is_arithmetic_v might be misleading since it doesn't include std::complex template < typename T > concept Number = std :: is_arithmetic_v < T > ; template < typename T > concept NotNumber = ! Number < T > ; // Define concept from conjunction of constraints template < typename T > concept SignedNumber = Number < T > && std :: is_signed_v < T > ; template < typename T > concept UnsignedNumber = Number < T > && ! std :: is_signed_v < T > ; // Define concept from disjunction of constraints template < typename T1 , typename T2 > concept Equivalent = std :: is_convertible_v < T1 , T2 > || std :: is_same_v < T1 , T2 > ; // Define concept from simple requires-expression // These expressions must be something that will compile template < typename T > concept Range = requires ( T r ) { * r . begin (); * r . end (); }; // Typename requirement (e.g. check type exists) // Define concept from typename requires-expression // These expressions must something that will compile template < typename T > concept HasValueType = requires ( T r ) { typename T :: value_type ; // required nested name }; // Compound requirement // Two requirements at the same time template < typename T > concept Pair = requires ( T p ) { { p . first }; { p . second }; }; // Typename requirement with type constraint // The expression should not only compile but it should also have // a type that passes the concept after -> template < typename T > concept IntPair = requires ( T p ) { { p . first } -> std :: same_as < int > ; { p . second } -> std :: same_as < int > ; }; // Requirement with two parameters template < typename T > concept EqualityComparable = requires ( T a , T b ) { { a == b }; { a != b }; }; // Nested requirements // Additional constraint to existing constraints // Functions can use Range or RangeSameType now without // ambiguity template < typename T > concept PairSameType = Pair < T > && requires ( T p ) { { p . first } -> std :: same_as < decltype ( p . second ) > ; }; // Nested requirements without requires template < typename T > concept RangeWithValueType = Range < T > && HasValueType < T > ; template < typename T > concept RangeWithoutValueType = Range < T > && ! HasValueType < T > ; // Constrain with template type // Number, but nor SignedNumber neither UnsignedNumber template < Number T > void max_value ( T a , T b ) { if ( a > b ) { std :: cout << \"max_value: \" << a << std :: endl ; } else { std :: cout << \"max_value: \" << b << std :: endl ; } } // Constrain with template type // Number -> SignedNumber template < SignedNumber T > void max_value ( T a , T b ) { if ( a > b ) { if ( a > 0 ) { std :: cout << \"max_value: positive \" << a << std :: endl ; } else { std :: cout << \"max_value: negative \" << - a << std :: endl ; } } else { if ( b > 0 ) { std :: cout << \"max_value: positive \" << b << std :: endl ; } else { std :: cout << \"max_value: negative \" << - b << std :: endl ; } } } // Constrain with template type // Number -> UnsignedNumber template < UnsignedNumber T > void max_value ( T a , T b ) { if ( a > b ) { std :: cout << \"max_value: +\" << a << std :: endl ; } else { std :: cout << \"max_value: +\" << b << std :: endl ; } } // Constrain with template type // NotNumber == !Number<T> template < NotNumber T > void max_value ( T a , T b ) { std :: cout << \"a: \" << a << std :: endl ; std :: cout << \"b: \" << b << std :: endl ; } // Unconstrained function (Not range) template < class T > void print_element ( const T & c ) { std :: cout << c << std :: endl ; } // Constrained with template type // - The most constrained concept is used template < Range T > void print_element ( const T & c ) { for ( const auto & item : c ) { std :: cout << item << ' ' ; } std :: cout << std :: endl ; } // Constrain the same function with a more constrained template type // - The most constrained concept is used in nested constraints template < RangeWithValueType T > void print_element ( const T & c ) { std :: cout << typeid ( typename T :: value_type ). name () << \": \" ; for ( const auto & item : c ) { std :: cout << item << ' ' ; } std :: cout << std :: endl ; } // Constrain with require-clause directly in function declaration template < typename T > requires EqualityComparable < T > void compare ( const T & a , const T & b ) { if ( a == b ) { std :: cout << a << \" == \" << b << \" is \" << ( a == b ? \"true\" : \"false\" ) << std :: endl ; } else { std :: cout << a << \" != \" << b << \" is \" << ( a != b ? \"true\" : \"false\" ) << std :: endl ; } } // Unconstrained version template < typename T > void compare ( const T & a , const T & b ) { std :: cout << typeid ( T ). name () << \": \" << a . c << \" == \" << b . c << \"?\" << std :: endl ; } struct nonComparableStruct { double c { 0. }; }; // Constrain with template type template < Pair T > void print_pair ( const T & p ) { std :: cout << typeid ( p . first ). name () << \": \" << p . first << \" == \" << typeid ( p . second ). name () << \": \" << p . second << std :: endl ; } // Constrain again with more specific requirement template < PairSameType T > void print_pair ( const T & p ) { std :: cout << typeid ( p . first ). name () << \": \" << p . first << \" == \" << p . second << std :: endl ; } int main () { /* * \\see https://en.cppreference.com/w/cpp/language/constraints */ max_value ( 5 , 7 ); max_value ( 4 , 7 ); max_value ( \"foo\" , \"bar\" ); print_element ( std :: vector < int > { 2 , 4 , 6 , 4 }); print_element ( 56 ); compare ( 4 , 7 ); compare ( nonComparableStruct { 1.0 }, nonComparableStruct { 2.0 }); print_pair ( std :: make_pair ( 1 , 2 )); print_pair ( std :: make_pair ( 1.6 , 2 )); return 0 ; } FindConcepts.cmake: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 include ( CheckCXXSourceCompiles ) check_cxx_source_compiles ( \" #include <concepts> #include <type_traits> template <typename T> concept Number = std::is_arithmetic_v<T>; int main() { return 0; } \" Concepts_FOUND ) if ( Concepts_FOUND AND NOT ( TARGET std::concepts )) add_library ( std::concepts INTERFACE IMPORTED ) set_target_properties ( std::concepts PROPERTIES INTERFACE_COMPILE_OPTIONS $< $<COMPILE_LANGUAGE:CXX > :-fconcepts> ) endif ()","title":"Concepts"},{"location":"algorithms--data-structures/template/sfinae/","text":"SFINAE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <array> #include <iostream> #include <string> #include <type_traits> // Define concept with a boolean template < class T > void max ( std :: enable_if_t < std :: is_arithmetic_v < T > , T > a , T b ) { if ( a > b ) { std :: cout << \"max: \" << a << std :: endl ; } else { std :: cout << \"max: \" << b << std :: endl ; } } template < class T > void max ( std :: enable_if_t <! std :: is_arithmetic_v < T > , T > a , T b ) { std :: cout << \"a: \" << a << std :: endl ; std :: cout << \"b: \" << b << std :: endl ; } int main () { max ( 5 , 7 ); max ( \"foo\" , \"bar\" ); return 0 ; }","title":"SFINAE"},{"location":"algorithms--data-structures/template/sfinae/#sfinae","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <array> #include <iostream> #include <string> #include <type_traits> // Define concept with a boolean template < class T > void max ( std :: enable_if_t < std :: is_arithmetic_v < T > , T > a , T b ) { if ( a > b ) { std :: cout << \"max: \" << a << std :: endl ; } else { std :: cout << \"max: \" << b << std :: endl ; } } template < class T > void max ( std :: enable_if_t <! std :: is_arithmetic_v < T > , T > a , T b ) { std :: cout << \"a: \" << a << std :: endl ; std :: cout << \"b: \" << b << std :: endl ; } int main () { max ( 5 , 7 ); max ( \"foo\" , \"bar\" ); return 0 ; }","title":"SFINAE"},{"location":"algorithms--data-structures/template/template-aliases/","text":"Template aliases 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <array> #include <iostream> #include <string> using namespace std ; // Template alias for two-dimensional arrays // - This is only an example // - We would't really do that in practice template < class T , size_t N_ROWS , size_t N_COLUMNS > using matrix = array < array < T , N_COLUMNS > , N_ROWS > ; int main () { matrix < double , 10 , 3 > m ; double i = 5.6 ; for ( auto & row : m ) { for ( auto & xij : row ) { xij = i ++ ; } } for ( auto & row : m ) { for ( auto & xij : row ) { cout << \"xij: \" << xij << endl ; } } return 0 ; }","title":"Template aliases"},{"location":"algorithms--data-structures/template/template-aliases/#template-aliases","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <array> #include <iostream> #include <string> using namespace std ; // Template alias for two-dimensional arrays // - This is only an example // - We would't really do that in practice template < class T , size_t N_ROWS , size_t N_COLUMNS > using matrix = array < array < T , N_COLUMNS > , N_ROWS > ; int main () { matrix < double , 10 , 3 > m ; double i = 5.6 ; for ( auto & row : m ) { for ( auto & xij : row ) { xij = i ++ ; } } for ( auto & row : m ) { for ( auto & xij : row ) { cout << \"xij: \" << xij << endl ; } } return 0 ; }","title":"Template aliases"},{"location":"algorithms--data-structures/template/template-function/","text":"Template function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <iostream> // max for int int max ( int n1 , int n2 ) { return ( n1 > n2 ) ? n1 : n2 ; } // max for any type T template < class T > T max ( T n1 , T n2 ) { return ( n1 > n2 ) ? n1 : n2 ; } // max for any types T and T2 template < class T , class T2 > T2 max ( T n1 , T2 n2 ) { return ( n1 > n2 ) ? n1 : n2 ; } // The \"old\" way: max operating on nullified pointers void * max ( void * n1 , void * n2 , bool ( * comp )( void * , void * )) { return ( comp ( n1 , n2 )) ? n1 : n2 ; } // The \"old\" way: an extra function operating on the nullified pointers bool comp ( void * a , void * b ) { return ( * ( int * ) a < * ( int * ) b ); } template < class T1 , class T2 > struct pair { T1 first ; T2 second ; }; int main () { // Templates for any data type std :: cout << \"m: \" << max ( 3 , 9 ) << std :: endl ; std :: cout << \"m: \" << max ( 3.5 , 9.3 ) << std :: endl ; std :: cout << \"m: \" << max ( 3 , 9.3 ) << std :: endl ; // Objects with templates pair < int , double > p { 3 , 3.3 }; std :: cout << \"p.first: \" << p . first << std :: endl ; std :: cout << \"p.second: \" << p . second << std :: endl ; // In old C++ and C, we need nullify pointers to create generic functions // - It's easy to see why this is inconvenient int a = 3 ; int b = 9 ; void * m = max ( & a , & b , & comp ); std :: cout << \"m: \" << * ( int * ) m << std :: endl ; return 0 ; }","title":"Template function"},{"location":"algorithms--data-structures/template/template-function/#template-function","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <iostream> // max for int int max ( int n1 , int n2 ) { return ( n1 > n2 ) ? n1 : n2 ; } // max for any type T template < class T > T max ( T n1 , T n2 ) { return ( n1 > n2 ) ? n1 : n2 ; } // max for any types T and T2 template < class T , class T2 > T2 max ( T n1 , T2 n2 ) { return ( n1 > n2 ) ? n1 : n2 ; } // The \"old\" way: max operating on nullified pointers void * max ( void * n1 , void * n2 , bool ( * comp )( void * , void * )) { return ( comp ( n1 , n2 )) ? n1 : n2 ; } // The \"old\" way: an extra function operating on the nullified pointers bool comp ( void * a , void * b ) { return ( * ( int * ) a < * ( int * ) b ); } template < class T1 , class T2 > struct pair { T1 first ; T2 second ; }; int main () { // Templates for any data type std :: cout << \"m: \" << max ( 3 , 9 ) << std :: endl ; std :: cout << \"m: \" << max ( 3.5 , 9.3 ) << std :: endl ; std :: cout << \"m: \" << max ( 3 , 9.3 ) << std :: endl ; // Objects with templates pair < int , double > p { 3 , 3.3 }; std :: cout << \"p.first: \" << p . first << std :: endl ; std :: cout << \"p.second: \" << p . second << std :: endl ; // In old C++ and C, we need nullify pointers to create generic functions // - It's easy to see why this is inconvenient int a = 3 ; int b = 9 ; void * m = max ( & a , & b , & comp ); std :: cout << \"m: \" << * ( int * ) m << std :: endl ; return 0 ; }","title":"Template function"},{"location":"basic-syntax/basic-data-types/aggregate-initialization/","text":"Aggregate initialization 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include <iomanip> #include <iostream> using namespace std ; struct A { int x ; int y ; int z ; }; struct B { int x ; A y ; int z ; }; void print ( const A & a ) { std :: cout << \"a: {\" << a . x << \", \" << a . y << \", \" << a . z << \"}\" << std :: endl ; } void print ( const B & a ) { std :: cout << \"a: {\" << a . x << \", {\" << a . y . x << \", \" << a . y . y << \", \" << a . y . z << \"}, \" << a . z << \"}\" << std :: endl ; } int main () { // Designated initializers A a {. x = 1 , . y = 4 , . z = 2 }; print ( a ); A b {. x = 1 , . y = 2 , . z = 6 }; print ( b ); // List initialization A c { 1 , 2 , 3 }; print ( c ); // Nested initialization B d {. x = 1 , . y = { 2 , 6 , 5 }, . z = 3 }; print ( d ); return 0 ; }","title":"Aggregate initialization"},{"location":"basic-syntax/basic-data-types/aggregate-initialization/#aggregate-initialization","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include <iomanip> #include <iostream> using namespace std ; struct A { int x ; int y ; int z ; }; struct B { int x ; A y ; int z ; }; void print ( const A & a ) { std :: cout << \"a: {\" << a . x << \", \" << a . y << \", \" << a . z << \"}\" << std :: endl ; } void print ( const B & a ) { std :: cout << \"a: {\" << a . x << \", {\" << a . y . x << \", \" << a . y . y << \", \" << a . y . z << \"}, \" << a . z << \"}\" << std :: endl ; } int main () { // Designated initializers A a {. x = 1 , . y = 4 , . z = 2 }; print ( a ); A b {. x = 1 , . y = 2 , . z = 6 }; print ( b ); // List initialization A c { 1 , 2 , 3 }; print ( c ); // Nested initialization B d {. x = 1 , . y = { 2 , 6 , 5 }, . z = 3 }; print ( d ); return 0 ; }","title":"Aggregate initialization"},{"location":"basic-syntax/basic-data-types/arrays/","text":"Arrays 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include <array> #include <iostream> #include <string> using namespace std ; int main () { constexpr int n = 3 ; // Fixed size array array < int , n > a = { 1 , 2 , 3 }; for ( size_t i = 0 ; i < a . size (); ++ i ) { cout << \"a[\" << i << \"]: \" << a [ i ] << endl ; } cout << \"a.size(): \" << a . size () << endl ; cout << \"a.empty(): \" << a . empty () << endl ; cout << \"a.front(): \" << a . front () << endl ; cout << \"a.back(): \" << a . back () << endl ; cout << \"&a: \" << & a << endl ; cout << \"&a[0]: \" << & a [ 0 ] << endl ; cout << \"&a[1]: \" << & a [ 1 ] << endl ; cout << \"&a[2]: \" << & a [ 2 ] << endl ; // We might still need the underlying raw array // to interact with old code cout << \"Underlying raw array - a.data(): \" << a . data () << endl ; // array<T,N> has a fixed size in bytes cout << \"sizeof(a): \" << sizeof ( a ) << endl ; // Multidimensional array array < array < double , 3 > , 10 > matrix ; for ( size_t i = 0 ; i < matrix . size (); ++ i ) { for ( size_t j = 0 ; j < matrix [ i ]. size (); ++ j ) { matrix [ i ][ j ] = 0.5 * i + 0.8 * j ; } } for ( const auto & row : matrix ) { double sum = 0. ; for ( const auto & col : row ) { sum += col ; } cout << \"Row average \" << sum / row . size () << endl ; } return 0 ; }","title":"Arrays"},{"location":"basic-syntax/basic-data-types/arrays/#arrays","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include <array> #include <iostream> #include <string> using namespace std ; int main () { constexpr int n = 3 ; // Fixed size array array < int , n > a = { 1 , 2 , 3 }; for ( size_t i = 0 ; i < a . size (); ++ i ) { cout << \"a[\" << i << \"]: \" << a [ i ] << endl ; } cout << \"a.size(): \" << a . size () << endl ; cout << \"a.empty(): \" << a . empty () << endl ; cout << \"a.front(): \" << a . front () << endl ; cout << \"a.back(): \" << a . back () << endl ; cout << \"&a: \" << & a << endl ; cout << \"&a[0]: \" << & a [ 0 ] << endl ; cout << \"&a[1]: \" << & a [ 1 ] << endl ; cout << \"&a[2]: \" << & a [ 2 ] << endl ; // We might still need the underlying raw array // to interact with old code cout << \"Underlying raw array - a.data(): \" << a . data () << endl ; // array<T,N> has a fixed size in bytes cout << \"sizeof(a): \" << sizeof ( a ) << endl ; // Multidimensional array array < array < double , 3 > , 10 > matrix ; for ( size_t i = 0 ; i < matrix . size (); ++ i ) { for ( size_t j = 0 ; j < matrix [ i ]. size (); ++ j ) { matrix [ i ][ j ] = 0.5 * i + 0.8 * j ; } } for ( const auto & row : matrix ) { double sum = 0. ; for ( const auto & col : row ) { sum += col ; } cout << \"Row average \" << sum / row . size () << endl ; } return 0 ; }","title":"Arrays"},{"location":"basic-syntax/basic-data-types/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 10 11 12 13 add_executable ( raw_arrays raw_arrays.cpp ) add_executable ( arrays arrays.cpp ) add_executable ( vectors vectors.cpp ) add_executable ( strings strings.cpp ) add_executable ( move move.cpp ) add_executable ( aggregate_initialization aggregate_initialization.cpp ) add_executable ( structured_binding structured_binding.cpp )","title":"Build script"},{"location":"basic-syntax/basic-data-types/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 add_executable ( raw_arrays raw_arrays.cpp ) add_executable ( arrays arrays.cpp ) add_executable ( vectors vectors.cpp ) add_executable ( strings strings.cpp ) add_executable ( move move.cpp ) add_executable ( aggregate_initialization aggregate_initialization.cpp ) add_executable ( structured_binding structured_binding.cpp )","title":"Build script"},{"location":"basic-syntax/basic-data-types/move/","text":"Move 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <iostream> #include <numeric> #include <vector> #include <algorithm> int main () { std :: vector < double > v ( 30 , 1.0 ); // Copying v std :: vector < double > v2 = v ; std :: cout << \"v1: \" ; std :: for_each ( v . begin (), v . end (), []( const double c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; std :: cout << \"v2: \" ; std :: for_each ( v . begin (), v . end (), []( const double c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Moving v // - std::move casts v to an rvalue std :: vector < double > v3 = std :: move ( v ); std :: cout << \"v1: \" ; // NOLINTNEXTLINE(bugprone-use-after-move): making a point std :: for_each ( v . begin (), v . end (), []( const double c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; std :: cout << \"v3: \" ; std :: for_each ( v3 . begin (), v3 . end (), []( const double c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; return 0 ; }","title":"Move"},{"location":"basic-syntax/basic-data-types/move/#move","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <iostream> #include <numeric> #include <vector> #include <algorithm> int main () { std :: vector < double > v ( 30 , 1.0 ); // Copying v std :: vector < double > v2 = v ; std :: cout << \"v1: \" ; std :: for_each ( v . begin (), v . end (), []( const double c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; std :: cout << \"v2: \" ; std :: for_each ( v . begin (), v . end (), []( const double c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; // Moving v // - std::move casts v to an rvalue std :: vector < double > v3 = std :: move ( v ); std :: cout << \"v1: \" ; // NOLINTNEXTLINE(bugprone-use-after-move): making a point std :: for_each ( v . begin (), v . end (), []( const double c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; std :: cout << \"v3: \" ; std :: for_each ( v3 . begin (), v3 . end (), []( const double c ) { std :: cout << c << \" \" ; }); std :: cout << std :: endl ; return 0 ; }","title":"Move"},{"location":"basic-syntax/basic-data-types/raw-arrays/","text":"Raw arrays 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include <array> #include <iostream> #include <string> using namespace std ; int main () { constexpr int n = 3 ; // Raw arrays // - Examples only: don't use raw arrays! // Explicit size int a [ n ]; a [ 0 ] = 1 ; a [ 1 ] = 2 ; a [ 2 ] = 3 ; // Implicit size int temp [] = { 1 , 2 , 3 }; for ( size_t i = 0 ; i < n ; ++ i ) { cout << \"temp[\" << i << \"]: \" << temp [ i ] << endl ; } // Array is converted to its initial pointer cout << \"temp: \" << temp << endl ; cout << \"&temp: \" << & temp << endl ; cout << \"temp[0]: \" << temp [ 0 ] << endl ; cout << \"&temp[0]: \" << & temp [ 0 ] << endl ; cout << \"temp[1]: \" << temp [ 1 ] << endl ; cout << \"&temp[1]: \" << & temp [ 1 ] << endl ; cout << \"temp[2]: \" << temp [ 2 ] << endl ; cout << \"&temp[2]: \" << & temp [ 2 ] << endl ; return 0 ; }","title":"Raw arrays"},{"location":"basic-syntax/basic-data-types/raw-arrays/#raw-arrays","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include <array> #include <iostream> #include <string> using namespace std ; int main () { constexpr int n = 3 ; // Raw arrays // - Examples only: don't use raw arrays! // Explicit size int a [ n ]; a [ 0 ] = 1 ; a [ 1 ] = 2 ; a [ 2 ] = 3 ; // Implicit size int temp [] = { 1 , 2 , 3 }; for ( size_t i = 0 ; i < n ; ++ i ) { cout << \"temp[\" << i << \"]: \" << temp [ i ] << endl ; } // Array is converted to its initial pointer cout << \"temp: \" << temp << endl ; cout << \"&temp: \" << & temp << endl ; cout << \"temp[0]: \" << temp [ 0 ] << endl ; cout << \"&temp[0]: \" << & temp [ 0 ] << endl ; cout << \"temp[1]: \" << temp [ 1 ] << endl ; cout << \"&temp[1]: \" << & temp [ 1 ] << endl ; cout << \"temp[2]: \" << temp [ 2 ] << endl ; cout << \"&temp[2]: \" << & temp [ 2 ] << endl ; return 0 ; }","title":"Raw arrays"},{"location":"basic-syntax/basic-data-types/strings/","text":"Strings 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <array> #include <iostream> #include <string> using namespace std ; int main () { // Strings are dynamic arrays of chars string str = \"avocado\" ; // Print the whole string cout << str << '\\n' ; // Print the string chars for ( size_t i = 0 ; i < str . size (); ++ i ) { cout << \"str[\" << i << \"]: \" << str [ i ] << '\\n' ; } // Access index if ( str . size () >= 10 ) { cout << \"str[10]: \" << str [ 10 ] << '\\n' ; } else { cout << \"str[10]: (does not exist)\" << '\\n' ; } // Container functions cout << \"str.size(): \" << str . size () << '\\n' ; cout << \"str.empty(): \" << str . empty () << '\\n' ; cout << \"str.front(): \" << str . front () << '\\n' ; cout << \"str.back(): \" << str . back () << '\\n' ; // Contiguous addresses (like any array) cout << \"&str: \" << & str << '\\n' ; cout << \"str.data(): \" << str . data () << '\\n' ; // The subscript operator accesses a single char cout << \"str[0]: \" << str [ 0 ] << '\\n' ; cout << \"str[1]: \" << str [ 1 ] << '\\n' ; cout << \"str[2]: \" << str [ 2 ] << '\\n' ; // The address of a char prints from that position cout << \"&str[0]: \" << & str [ 0 ] << '\\n' ; cout << \"&str[1]: \" << & str [ 1 ] << '\\n' ; cout << \"&str[2]: \" << & str [ 2 ] << '\\n' ; return 0 ; }","title":"Strings"},{"location":"basic-syntax/basic-data-types/strings/#strings","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <array> #include <iostream> #include <string> using namespace std ; int main () { // Strings are dynamic arrays of chars string str = \"avocado\" ; // Print the whole string cout << str << '\\n' ; // Print the string chars for ( size_t i = 0 ; i < str . size (); ++ i ) { cout << \"str[\" << i << \"]: \" << str [ i ] << '\\n' ; } // Access index if ( str . size () >= 10 ) { cout << \"str[10]: \" << str [ 10 ] << '\\n' ; } else { cout << \"str[10]: (does not exist)\" << '\\n' ; } // Container functions cout << \"str.size(): \" << str . size () << '\\n' ; cout << \"str.empty(): \" << str . empty () << '\\n' ; cout << \"str.front(): \" << str . front () << '\\n' ; cout << \"str.back(): \" << str . back () << '\\n' ; // Contiguous addresses (like any array) cout << \"&str: \" << & str << '\\n' ; cout << \"str.data(): \" << str . data () << '\\n' ; // The subscript operator accesses a single char cout << \"str[0]: \" << str [ 0 ] << '\\n' ; cout << \"str[1]: \" << str [ 1 ] << '\\n' ; cout << \"str[2]: \" << str [ 2 ] << '\\n' ; // The address of a char prints from that position cout << \"&str[0]: \" << & str [ 0 ] << '\\n' ; cout << \"&str[1]: \" << & str [ 1 ] << '\\n' ; cout << \"&str[2]: \" << & str [ 2 ] << '\\n' ; return 0 ; }","title":"Strings"},{"location":"basic-syntax/basic-data-types/structured-binding/","text":"Structured binding 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #include <algorithm> #include <cmath> #include <iomanip> #include <iostream> #include <map> #include <numeric> #include <string> #include <vector> using namespace std ; struct Foo { int i ; char c ; double d ; }; /// Min and max elements from a vector /// \\param v Vector /// \\return Min /// \\return Max pair < int , int > minmax ( vector < int > & v ) { // unpack tuple of iterators with min and max auto [ min_iter , max_iter ] = minmax_element ( v . begin (), v . end ()); return make_pair ( * min_iter , * max_iter ); } /// Mean, variance, and std deviation /// \\param v Vector /// \\return Total /// \\return Mean /// \\return Variance /// \\return Deviation tuple < int , double , double , double > stats ( vector < int > & v ) { int total = accumulate ( v . begin (), v . end (), 0 ); double mean = static_cast < double > ( total ) / v . size (); double variance = accumulate ( v . begin (), v . end (), 0.0 , [ mean ]( double sum , int elem ) { return sum + ( static_cast < double > ( elem ) - mean ) * ( static_cast < double > ( elem ) - mean ); }) / ( v . size () - 1 ); double stddev = sqrt ( variance ); return make_tuple ( total , mean , variance , stddev ); } int main () { // Unpacking pairs vector < int > v = { 7 , 3 , 9 , 3 , 1 , 7 , 4 , 9 }; auto [ min_value , max_value ] = minmax ( v ); cout << \"min_value: \" << min_value << endl ; cout << \"max_value: \" << max_value << endl ; // Unpacking tuples auto [ total , mean , variance , stddev ] = stats ( v ); cout << \"total: \" << total << endl ; cout << \"mean: \" << mean << endl ; cout << \"variance: \" << variance << endl ; cout << \"stddev: \" << stddev << endl ; // Unpacking structs Foo f { 1 , 'a' , 2.3 }; auto [ i , c , d ] = f ; cout << \"f.i: \" << i << endl ; cout << \"f.c: \" << c << endl ; cout << \"f.d: \" << d << endl ; // Creating references auto & [ i2 , c2 , d2 ] = f ; cout << \"i2: \" << i2 << endl ; cout << \"c2: \" << c2 << endl ; cout << \"d2: \" << d2 << endl ; // Unpacking native arrays int a [ 2 ] = { 1 , 2 }; auto [ x , y ] = a ; cout << \"x: \" << x << endl ; cout << \"y: \" << y << endl ; // rvalue reference in range based loop map < string , int > my_map = { { \"hello\" , 1 }, { \"world\" , 2 }, { \"it's\" , 3 }, { \"me\" , 4 }, }; for ( auto && [ key , value ] : my_map ) { cout << \"key=\" << key << \" value=\" << value << endl ; } // Getting iterator from the insert function if ( auto [ iter , success ] = my_map . insert ( make_pair ( \"Bye\" , 5 )); success ) { auto & [ key , value ] = * iter ; cout << \"insert is successful. The value is \" << quoted ( key ) << '\\n' ; } else { auto & [ key , value ] = * iter ; cout << \"The value \" << quoted ( key ) << \" already exists in the set \\n \" ; } return 0 ; }","title":"Structured binding"},{"location":"basic-syntax/basic-data-types/structured-binding/#structured-binding","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #include <algorithm> #include <cmath> #include <iomanip> #include <iostream> #include <map> #include <numeric> #include <string> #include <vector> using namespace std ; struct Foo { int i ; char c ; double d ; }; /// Min and max elements from a vector /// \\param v Vector /// \\return Min /// \\return Max pair < int , int > minmax ( vector < int > & v ) { // unpack tuple of iterators with min and max auto [ min_iter , max_iter ] = minmax_element ( v . begin (), v . end ()); return make_pair ( * min_iter , * max_iter ); } /// Mean, variance, and std deviation /// \\param v Vector /// \\return Total /// \\return Mean /// \\return Variance /// \\return Deviation tuple < int , double , double , double > stats ( vector < int > & v ) { int total = accumulate ( v . begin (), v . end (), 0 ); double mean = static_cast < double > ( total ) / v . size (); double variance = accumulate ( v . begin (), v . end (), 0.0 , [ mean ]( double sum , int elem ) { return sum + ( static_cast < double > ( elem ) - mean ) * ( static_cast < double > ( elem ) - mean ); }) / ( v . size () - 1 ); double stddev = sqrt ( variance ); return make_tuple ( total , mean , variance , stddev ); } int main () { // Unpacking pairs vector < int > v = { 7 , 3 , 9 , 3 , 1 , 7 , 4 , 9 }; auto [ min_value , max_value ] = minmax ( v ); cout << \"min_value: \" << min_value << endl ; cout << \"max_value: \" << max_value << endl ; // Unpacking tuples auto [ total , mean , variance , stddev ] = stats ( v ); cout << \"total: \" << total << endl ; cout << \"mean: \" << mean << endl ; cout << \"variance: \" << variance << endl ; cout << \"stddev: \" << stddev << endl ; // Unpacking structs Foo f { 1 , 'a' , 2.3 }; auto [ i , c , d ] = f ; cout << \"f.i: \" << i << endl ; cout << \"f.c: \" << c << endl ; cout << \"f.d: \" << d << endl ; // Creating references auto & [ i2 , c2 , d2 ] = f ; cout << \"i2: \" << i2 << endl ; cout << \"c2: \" << c2 << endl ; cout << \"d2: \" << d2 << endl ; // Unpacking native arrays int a [ 2 ] = { 1 , 2 }; auto [ x , y ] = a ; cout << \"x: \" << x << endl ; cout << \"y: \" << y << endl ; // rvalue reference in range based loop map < string , int > my_map = { { \"hello\" , 1 }, { \"world\" , 2 }, { \"it's\" , 3 }, { \"me\" , 4 }, }; for ( auto && [ key , value ] : my_map ) { cout << \"key=\" << key << \" value=\" << value << endl ; } // Getting iterator from the insert function if ( auto [ iter , success ] = my_map . insert ( make_pair ( \"Bye\" , 5 )); success ) { auto & [ key , value ] = * iter ; cout << \"insert is successful. The value is \" << quoted ( key ) << '\\n' ; } else { auto & [ key , value ] = * iter ; cout << \"The value \" << quoted ( key ) << \" already exists in the set \\n \" ; } return 0 ; }","title":"Structured binding"},{"location":"basic-syntax/basic-data-types/vectors/","text":"Vectors 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <iostream> #include <string> #include <vector> using namespace std ; int main () { // Dynamic size vector vector < int > v = { 1 , 2 , 3 }; for ( size_t i = 0 ; i < v . size (); ++ i ) { cout << \"v[\" << i << \"]: \" << v [ i ] << endl ; } cout << \"v.size(): \" << v . size () << endl ; cout << \"v.empty(): \" << v . empty () << endl ; cout << \"v.front(): \" << v . front () << endl ; cout << \"v.back(): \" << v . back () << endl ; cout << \"&v: \" << & v << endl ; cout << \"&v[0]: \" << & v [ 0 ] << endl ; cout << \"&v[1]: \" << & v [ 1 ] << endl ; cout << \"&v[2]: \" << & v [ 2 ] << endl ; // We might still need the underlying raw vector // to interact with old code cout << \"Underlying raw vector - v.data(): \" << v . data () << endl ; // vector<T,N> has no fixed size in bytes // sizeof(v) has only the size of the pointers to manage v cout << \"sizeof(v): \" << sizeof ( v ) << endl ; // Multidimensional vector vector < vector < double >> matrix ( 10 , vector < double > ( 3 , 0 )); for ( size_t i = 0 ; i < matrix . size (); ++ i ) { for ( size_t j = 0 ; j < matrix [ i ]. size (); ++ j ) { matrix [ i ][ j ] = 0.5 * i + 0.8 * j ; } } for ( const auto & row : matrix ) { double sum = 0. ; for ( const auto & col : row ) { sum += col ; } cout << \"Row average \" << sum / row . size () << endl ; } return 0 ; }","title":"Vectors"},{"location":"basic-syntax/basic-data-types/vectors/#vectors","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <iostream> #include <string> #include <vector> using namespace std ; int main () { // Dynamic size vector vector < int > v = { 1 , 2 , 3 }; for ( size_t i = 0 ; i < v . size (); ++ i ) { cout << \"v[\" << i << \"]: \" << v [ i ] << endl ; } cout << \"v.size(): \" << v . size () << endl ; cout << \"v.empty(): \" << v . empty () << endl ; cout << \"v.front(): \" << v . front () << endl ; cout << \"v.back(): \" << v . back () << endl ; cout << \"&v: \" << & v << endl ; cout << \"&v[0]: \" << & v [ 0 ] << endl ; cout << \"&v[1]: \" << & v [ 1 ] << endl ; cout << \"&v[2]: \" << & v [ 2 ] << endl ; // We might still need the underlying raw vector // to interact with old code cout << \"Underlying raw vector - v.data(): \" << v . data () << endl ; // vector<T,N> has no fixed size in bytes // sizeof(v) has only the size of the pointers to manage v cout << \"sizeof(v): \" << sizeof ( v ) << endl ; // Multidimensional vector vector < vector < double >> matrix ( 10 , vector < double > ( 3 , 0 )); for ( size_t i = 0 ; i < matrix . size (); ++ i ) { for ( size_t j = 0 ; j < matrix [ i ]. size (); ++ j ) { matrix [ i ][ j ] = 0.5 * i + 0.8 * j ; } } for ( const auto & row : matrix ) { double sum = 0. ; for ( const auto & col : row ) { sum += col ; } cout << \"Row average \" << sum / row . size () << endl ; } return 0 ; }","title":"Vectors"},{"location":"basic-syntax/control-flow/build-script/","text":"Build script 1 2 3 4 5 add_executable ( sequential sequential.cpp ) add_executable ( conditional conditional.cpp ) add_executable ( loops loops.cpp )","title":"Build script"},{"location":"basic-syntax/control-flow/build-script/#build-script","text":"1 2 3 4 5 add_executable ( sequential sequential.cpp ) add_executable ( conditional conditional.cpp ) add_executable ( loops loops.cpp )","title":"Build script"},{"location":"basic-syntax/control-flow/conditional/","text":"Conditional 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 #include <iostream> using namespace std ; int main () { // Declare constants and variables constexpr int number_of_numbers = 2 ; int first_number ; int second_number ; int n_even_numbers = 0 ; // Input cout << \"Type the first number: \" ; cin >> first_number ; cout << \"Type the second number: \" ; cin >> second_number ; // Simplest conditional if ( first_number % 2 == 0 ) { ++ n_even_numbers ; } // Ternary Operator // same as: n_even_numbers += second_number % 2 == 0; n_even_numbers += ( first_number % 2 == 0 ) ? 1 : 0 ; // Common conditional if ( n_even_numbers == 0 ) { cout << \"You typed 0 even numbers and 2 odd numbers\" << endl ; } else if ( n_even_numbers == 1 ) { cout << \"You typed 1 even number e 1 odd number\" << endl ; } else if ( n_even_numbers == 2 ) { cout << \"You typed 2 even numbers e 0 odd numbers\" << endl ; } else { cout << \"Tem um erro s\u00e9rio no seu programa\" << endl ; return 1 ; } // Switch on fundamental data types switch ( n_even_numbers ) { case 0 : cout << \"Zero even numbers. Two odd numbers.\" << endl ; break ; case 1 : cout << \"One even number and one odd number.\" << endl ; break ; case 2 : cout << \"Two even numbers. No odd numbers.\" << endl ; break ; default : cout << \"We found a serious error with your program\" << endl ; return 1 ; } // Common conditional without n_even_numbers if ( first_number % 2 != 0 && second_number % 2 != 0 ) { cout << \"You typed 0 even numbers e 2 odd numbers\" << endl ; } else if ( first_number % 2 == 0 && second_number % 2 == 0 ) { cout << \"You typed 2 even numbers e 0 odd numbers\" << endl ; } else { cout << \"You typed 1 even number e 1 odd number\" << endl ; } // Printing directly cout << \"You typed \" << n_even_numbers << \" even numbers and \" << number_of_numbers - n_even_numbers << \" odd numbers\" << endl ; // Ternary operators for fixing plurals cout << \"You typed \" << n_even_numbers << \" even number\" ; cout << ( n_even_numbers == 1 ? \"\" : \"s\" ); cout << \" and \" << number_of_numbers - n_even_numbers << \" odd number\" ; cout << ( number_of_numbers - n_even_numbers == 1 ? \"\" : \"s\" ); // Common conditional if ( n_even_numbers > number_of_numbers - n_even_numbers ) { cout << \"You have more even numbers\" << endl ; } else { cout << \"You don't have more even numbers\" << endl ; } // Ternary operator cout << \"You \" << (( n_even_numbers > number_of_numbers - n_even_numbers ) ? ( \"\" ) : ( \"don't\" )); cout << \" have more even numbers than odd numbers\" << endl ; // Testing constants if constexpr ( number_of_numbers > 2 ) { cout << \"You're program is not adapted to that yet\" << endl ; } else { cout << \"Program for testing up to two numbers\" << endl ; } return 0 ; }","title":"Conditional"},{"location":"basic-syntax/control-flow/conditional/#conditional","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 #include <iostream> using namespace std ; int main () { // Declare constants and variables constexpr int number_of_numbers = 2 ; int first_number ; int second_number ; int n_even_numbers = 0 ; // Input cout << \"Type the first number: \" ; cin >> first_number ; cout << \"Type the second number: \" ; cin >> second_number ; // Simplest conditional if ( first_number % 2 == 0 ) { ++ n_even_numbers ; } // Ternary Operator // same as: n_even_numbers += second_number % 2 == 0; n_even_numbers += ( first_number % 2 == 0 ) ? 1 : 0 ; // Common conditional if ( n_even_numbers == 0 ) { cout << \"You typed 0 even numbers and 2 odd numbers\" << endl ; } else if ( n_even_numbers == 1 ) { cout << \"You typed 1 even number e 1 odd number\" << endl ; } else if ( n_even_numbers == 2 ) { cout << \"You typed 2 even numbers e 0 odd numbers\" << endl ; } else { cout << \"Tem um erro s\u00e9rio no seu programa\" << endl ; return 1 ; } // Switch on fundamental data types switch ( n_even_numbers ) { case 0 : cout << \"Zero even numbers. Two odd numbers.\" << endl ; break ; case 1 : cout << \"One even number and one odd number.\" << endl ; break ; case 2 : cout << \"Two even numbers. No odd numbers.\" << endl ; break ; default : cout << \"We found a serious error with your program\" << endl ; return 1 ; } // Common conditional without n_even_numbers if ( first_number % 2 != 0 && second_number % 2 != 0 ) { cout << \"You typed 0 even numbers e 2 odd numbers\" << endl ; } else if ( first_number % 2 == 0 && second_number % 2 == 0 ) { cout << \"You typed 2 even numbers e 0 odd numbers\" << endl ; } else { cout << \"You typed 1 even number e 1 odd number\" << endl ; } // Printing directly cout << \"You typed \" << n_even_numbers << \" even numbers and \" << number_of_numbers - n_even_numbers << \" odd numbers\" << endl ; // Ternary operators for fixing plurals cout << \"You typed \" << n_even_numbers << \" even number\" ; cout << ( n_even_numbers == 1 ? \"\" : \"s\" ); cout << \" and \" << number_of_numbers - n_even_numbers << \" odd number\" ; cout << ( number_of_numbers - n_even_numbers == 1 ? \"\" : \"s\" ); // Common conditional if ( n_even_numbers > number_of_numbers - n_even_numbers ) { cout << \"You have more even numbers\" << endl ; } else { cout << \"You don't have more even numbers\" << endl ; } // Ternary operator cout << \"You \" << (( n_even_numbers > number_of_numbers - n_even_numbers ) ? ( \"\" ) : ( \"don't\" )); cout << \" have more even numbers than odd numbers\" << endl ; // Testing constants if constexpr ( number_of_numbers > 2 ) { cout << \"You're program is not adapted to that yet\" << endl ; } else { cout << \"Program for testing up to two numbers\" << endl ; } return 0 ; }","title":"Conditional"},{"location":"basic-syntax/control-flow/loops/","text":"Loops 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include <array> #include <iostream> #include <map> #include <random> #include <string> using namespace std ; int main () { // Classic loop for ( size_t i = 0 ; i < 10 ; ++ i ) { cout << i << endl ; } // Changing update statement int b = 2 ; int e = 1024 ; for ( int i = b ; i <= e ; i *= b ) { cout << b << endl ; } // While loop int option = 0 ; do { ++ option ; } while ( option < 4 ); // Index based loop constexpr int n = 100 ; array < double , n > prices {}; for ( size_t i = 0 ; i < prices . size (); ++ i ) { prices [ i ] = 4 + 0.1 * i ; } // Iterator based loop for ( double & price : prices ) { cout << \"Item price: \" << price << endl ; } // Range based loop double sum = 0. ; for ( const auto & price : prices ) { sum += price ; } cout << \"Average price: \" << sum / n << endl ; // Range based loop with value pairs map < int , int > t ; t [ 7 ] = 2 ; t [ 8 ] = 4 ; t [ 4 ] = 6 ; for ( const auto & [ key , value ] : t ) { cout << key << \": \" << value << endl ; } // Iterating 2-dimensional arrays constexpr int n1 = 100 ; constexpr int n2 = 3 ; array < array < double , n2 > , n1 > grades {}; // Index based loop for ( int i = 0 ; i < n1 ; ++ i ) { for ( int j = 0 ; j < n2 ; ++ j ) { grades [ i ][ j ] = 6. + i * ( 2. / n1 ) + j * ( 2. / n2 ); } } // Range based loop for ( const auto & row : grades ) { double row_sum = 0.0 ; for ( const auto & col : row ) { row_sum += col ; } cout << \"Average student grade: \" << row_sum / grades . size () << endl ; } // Columns in the external for for ( int j = 0 ; j < n2 ; ++ j ) { double col_sum = 0.0 ; for ( int i = 0 ; i < n1 ; ++ i ) { col_sum += grades [ i ][ j ]; } cout << \"Average score on test \" << j + 1 << \": \" << col_sum / n1 << endl ; } return 0 ; }","title":"Loops"},{"location":"basic-syntax/control-flow/loops/#loops","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include <array> #include <iostream> #include <map> #include <random> #include <string> using namespace std ; int main () { // Classic loop for ( size_t i = 0 ; i < 10 ; ++ i ) { cout << i << endl ; } // Changing update statement int b = 2 ; int e = 1024 ; for ( int i = b ; i <= e ; i *= b ) { cout << b << endl ; } // While loop int option = 0 ; do { ++ option ; } while ( option < 4 ); // Index based loop constexpr int n = 100 ; array < double , n > prices {}; for ( size_t i = 0 ; i < prices . size (); ++ i ) { prices [ i ] = 4 + 0.1 * i ; } // Iterator based loop for ( double & price : prices ) { cout << \"Item price: \" << price << endl ; } // Range based loop double sum = 0. ; for ( const auto & price : prices ) { sum += price ; } cout << \"Average price: \" << sum / n << endl ; // Range based loop with value pairs map < int , int > t ; t [ 7 ] = 2 ; t [ 8 ] = 4 ; t [ 4 ] = 6 ; for ( const auto & [ key , value ] : t ) { cout << key << \": \" << value << endl ; } // Iterating 2-dimensional arrays constexpr int n1 = 100 ; constexpr int n2 = 3 ; array < array < double , n2 > , n1 > grades {}; // Index based loop for ( int i = 0 ; i < n1 ; ++ i ) { for ( int j = 0 ; j < n2 ; ++ j ) { grades [ i ][ j ] = 6. + i * ( 2. / n1 ) + j * ( 2. / n2 ); } } // Range based loop for ( const auto & row : grades ) { double row_sum = 0.0 ; for ( const auto & col : row ) { row_sum += col ; } cout << \"Average student grade: \" << row_sum / grades . size () << endl ; } // Columns in the external for for ( int j = 0 ; j < n2 ; ++ j ) { double col_sum = 0.0 ; for ( int i = 0 ; i < n1 ; ++ i ) { col_sum += grades [ i ][ j ]; } cout << \"Average score on test \" << j + 1 << \": \" << col_sum / n1 << endl ; } return 0 ; }","title":"Loops"},{"location":"basic-syntax/control-flow/sequential/","text":"Sequential 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <iostream> using namespace std ; int main () { double l = 4 ; double area = l * l ; cout << \"Area: \" << area << endl ; double height = 1.90 ; double weight = 90 ; cout << \"BMI: \" << weight / ( height * height ) << endl ; int a = 4 ; int b = 7 ; int fx = ( b * b * b + a * b ) - 2 * b + a % b ; cout << \"f(x) = \" << fx << endl ; return 0 ; }","title":"Sequential"},{"location":"basic-syntax/control-flow/sequential/#sequential","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <iostream> using namespace std ; int main () { double l = 4 ; double area = l * l ; cout << \"Area: \" << area << endl ; double height = 1.90 ; double weight = 90 ; cout << \"BMI: \" << weight / ( height * height ) << endl ; int a = 4 ; int b = 7 ; int fx = ( b * b * b + a * b ) - 2 * b + a % b ; cout << \"f(x) = \" << fx << endl ; return 0 ; }","title":"Sequential"},{"location":"basic-syntax/data-types/auto/","text":"Auto 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include <iostream> #include <string> #include <unordered_map> int main () { using std :: cout ; using std :: endl ; // Auto // Example only: don't do that for fundamental data types! // This is a bad place for auto // - It does not avoid a long type name // - There's ambiguity // (87 could *semantically* be any number type) auto dont_do_that = 87 ; cout << \"dont_do_that: \" << dont_do_that << endl ; // Data type alias std :: unordered_map < std :: string , double > t ; t [ \"zero\" ] = 0.0 ; t [ \"pi\" ] = 3.14 ; t [ \"ten\" ] = 10.0 ; // Without auto // NOLINTNEXTLINE(modernize-use-auto) std :: unordered_map < std :: string , double >:: iterator it = t . find ( \"pi\" ); if ( it != t . end ()) { cout << it -> first << \": \" << it -> second << endl ; } // With auto // This is the perfect place for auto // - It avoids a long type name // - There's no ambiguity (find always returns an iterator) auto it2 = t . find ( \"zero\" ); if ( it2 != t . end ()) { cout << it2 -> first << \": \" << it2 -> second << endl ; } // Get type from another variable decltype ( it ) it3 ; it3 = it ; ++ it3 ; if ( it3 != t . end ()) { cout << it3 -> first << \": \" << it3 -> second << endl ; } // Auto is also very useful for generic functions auto print_map_container = []( const auto & m ) { for ( auto && item : m ) { std :: cout << item . first << \": \" << item . second << std :: endl ; } }; print_map_container ( t ); return 0 ; }","title":"Auto"},{"location":"basic-syntax/data-types/auto/#auto","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include <iostream> #include <string> #include <unordered_map> int main () { using std :: cout ; using std :: endl ; // Auto // Example only: don't do that for fundamental data types! // This is a bad place for auto // - It does not avoid a long type name // - There's ambiguity // (87 could *semantically* be any number type) auto dont_do_that = 87 ; cout << \"dont_do_that: \" << dont_do_that << endl ; // Data type alias std :: unordered_map < std :: string , double > t ; t [ \"zero\" ] = 0.0 ; t [ \"pi\" ] = 3.14 ; t [ \"ten\" ] = 10.0 ; // Without auto // NOLINTNEXTLINE(modernize-use-auto) std :: unordered_map < std :: string , double >:: iterator it = t . find ( \"pi\" ); if ( it != t . end ()) { cout << it -> first << \": \" << it -> second << endl ; } // With auto // This is the perfect place for auto // - It avoids a long type name // - There's no ambiguity (find always returns an iterator) auto it2 = t . find ( \"zero\" ); if ( it2 != t . end ()) { cout << it2 -> first << \": \" << it2 -> second << endl ; } // Get type from another variable decltype ( it ) it3 ; it3 = it ; ++ it3 ; if ( it3 != t . end ()) { cout << it3 -> first << \": \" << it3 -> second << endl ; } // Auto is also very useful for generic functions auto print_map_container = []( const auto & m ) { for ( auto && item : m ) { std :: cout << item . first << \": \" << item . second << std :: endl ; } }; print_map_container ( t ); return 0 ; }","title":"Auto"},{"location":"basic-syntax/data-types/build-script/","text":"Build script 1 2 3 4 5 6 7 add_executable ( data_types data_types.cpp ) add_executable ( operators operators.cpp ) add_executable ( auto auto.cpp ) add_executable ( constants constants.cpp )","title":"Build script"},{"location":"basic-syntax/data-types/build-script/#build-script","text":"1 2 3 4 5 6 7 add_executable ( data_types data_types.cpp ) add_executable ( operators operators.cpp ) add_executable ( auto auto.cpp ) add_executable ( constants constants.cpp )","title":"Build script"},{"location":"basic-syntax/data-types/constants/","text":"Constants 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <array> #include <iostream> // Never do that on header files // Probably not a good idea in other files using namespace std ; int main () { // Variable int a = 2 ; cout << \"a : \" << a << endl ; // Constant as a promise const int b = 3 ; cout << \"b : \" << b << endl ; // Possible, but makes it impossible to know // b2 in compile-time. const int b2 = a ; cout << \"b2 : \" << b2 << endl ; // Constant \"more constant than const\" constexpr int c = 4 ; cout << \"c : \" << c << endl ; // Impossible, we wouldn't know c2 in compile-time. // constexpr int c2 = a; // Creating arrays of size a, b, c // The compiler needs to know the size at compile time // Impossible: // std::array<int,a> v1; // Sometimes possible std :: array < int , b > v2 = { 5 , 6 , 5 }; cout << \"v2.size(): \" << v2 . size () << endl ; // Impossible (b2 depends on a variable): // std::array<int,b2> v2b; // Always possible std :: array < int , c > v3 = { 7 , 8 , 7 , 8 }; cout << \"v3.size(): \" << v3 . size () << endl ; return 0 ; }","title":"Constants"},{"location":"basic-syntax/data-types/constants/#constants","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <array> #include <iostream> // Never do that on header files // Probably not a good idea in other files using namespace std ; int main () { // Variable int a = 2 ; cout << \"a : \" << a << endl ; // Constant as a promise const int b = 3 ; cout << \"b : \" << b << endl ; // Possible, but makes it impossible to know // b2 in compile-time. const int b2 = a ; cout << \"b2 : \" << b2 << endl ; // Constant \"more constant than const\" constexpr int c = 4 ; cout << \"c : \" << c << endl ; // Impossible, we wouldn't know c2 in compile-time. // constexpr int c2 = a; // Creating arrays of size a, b, c // The compiler needs to know the size at compile time // Impossible: // std::array<int,a> v1; // Sometimes possible std :: array < int , b > v2 = { 5 , 6 , 5 }; cout << \"v2.size(): \" << v2 . size () << endl ; // Impossible (b2 depends on a variable): // std::array<int,b2> v2b; // Always possible std :: array < int , c > v3 = { 7 , 8 , 7 , 8 }; cout << \"v3.size(): \" << v3 . size () << endl ; return 0 ; }","title":"Constants"},{"location":"basic-syntax/data-types/fundamental-data-types/","text":"Fundamental Data Types 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 #include <bit> #include <bitset> #include <cstdint> #include <iostream> void print_endian (); template < class T > std :: bitset < sizeof ( T ) * 8 > get_bits ( T v ); int main () { print_endian (); // Basic types bool a = true ; std :: cout << \"bool a: \" << a << std :: endl ; std :: cout << \"sizeof(a): \" << sizeof ( a ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( a ) << std :: endl ; std :: cout << std :: endl ; int b = 25 ; std :: cout << \"int b: \" << b << std :: endl ; std :: cout << \"sizeof(b): \" << sizeof ( b ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( b ) << std :: endl ; std :: cout << std :: endl ; double c = 1.34 ; std :: cout << \"double c: \" << c << std :: endl ; std :: cout << \"sizeof(c): \" << sizeof ( c ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( c ) << std :: endl ; std :: cout << std :: endl ; char d = 'g' ; std :: cout << \"char d: \" << d << std :: endl ; std :: cout << \"sizeof(d): \" << sizeof ( d ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( d ) << std :: endl ; std :: cout << std :: endl ; // Integer implicit precision long g = 25 ; std :: cout << \"long g: \" << g << std :: endl ; std :: cout << \"sizeof(g): \" << sizeof ( g ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( g ) << std :: endl ; std :: cout << std :: endl ; long long h = 8271 ; std :: cout << \"long long h: \" << h << std :: endl ; std :: cout << \"sizeof(h): \" << sizeof ( h ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( h ) << std :: endl ; std :: cout << std :: endl ; // Unsigned integer - implicit precision unsigned long i = 987312 ; std :: cout << \"unsigned long i: \" << i << std :: endl ; std :: cout << \"sizeof(i): \" << sizeof ( i ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( i ) << std :: endl ; std :: cout << std :: endl ; unsigned long long j = 4398271 ; std :: cout << \"unsigned long long j: \" << j << std :: endl ; std :: cout << \"sizeof(j): \" << sizeof ( j ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( j ) << std :: endl ; std :: cout << std :: endl ; // Integer explicit precision int8_t k = 25 ; std :: cout << \"int8_t k: \" << k << std :: endl ; std :: cout << \"sizeof(k): \" << sizeof ( k ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( k ) << std :: endl ; std :: cout << std :: endl ; int64_t l = 542 ; std :: cout << \"int64_t l: \" << l << std :: endl ; std :: cout << \"sizeof(l): \" << sizeof ( l ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( l ) << std :: endl ; std :: cout << std :: endl ; // Unsigned integer explicit precision uint8_t m = 54 ; std :: cout << \"uint8_t m: \" << m << std :: endl ; std :: cout << \"sizeof(m): \" << sizeof ( m ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( m ) << std :: endl ; std :: cout << std :: endl ; uint64_t n = 76354346 ; std :: cout << \"uint64_t n: \" << n << std :: endl ; std :: cout << \"sizeof(n): \" << sizeof ( n ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( n ) << std :: endl ; std :: cout << std :: endl ; // Floating point precision float o = 25.54 ; std :: cout << \"float o: \" << o << std :: endl ; std :: cout << \"sizeof(o): \" << sizeof ( o ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( o ) << std :: endl ; std :: cout << std :: endl ; long double p = 987312.325 ; std :: cout << \"long double p: \" << p << std :: endl ; std :: cout << \"sizeof(p): \" << sizeof ( p ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( p ) << std :: endl ; std :: cout << std :: endl ; // Char unsigned char q = 'c' ; std :: cout << \"unsigned char m: \" << q << std :: endl ; std :: cout << \"sizeof(q): \" << sizeof ( q ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( q ) << std :: endl ; std :: cout << std :: endl ; return 0 ; } void print_endian () { if constexpr ( std :: endian :: native == std :: endian :: big ) { std :: cout << \"big-endian\" << '\\n' ; } else if constexpr ( std :: endian :: native == std :: endian :: little ) { std :: cout << \"little-endian platform\" << '\\n' ; } else { std :: cout << \"mixed-endian\" << '\\n' ; } } template < class T > std :: bitset < sizeof ( T ) * 8 > get_bits ( T v ) { auto ptr = reinterpret_cast < unsigned char *> ( & v ); unsigned long long bytes = ptr [ 0 ]; for ( size_t i = 1 ; i < sizeof ( v ); ++ i ) { bytes <<= 8 ; bytes += ptr [ i ]; } return std :: bitset < sizeof ( v ) * 8 > ( bytes ); }","title":"Fundamental Data Types"},{"location":"basic-syntax/data-types/fundamental-data-types/#fundamental-data-types","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 #include <bit> #include <bitset> #include <cstdint> #include <iostream> void print_endian (); template < class T > std :: bitset < sizeof ( T ) * 8 > get_bits ( T v ); int main () { print_endian (); // Basic types bool a = true ; std :: cout << \"bool a: \" << a << std :: endl ; std :: cout << \"sizeof(a): \" << sizeof ( a ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( a ) << std :: endl ; std :: cout << std :: endl ; int b = 25 ; std :: cout << \"int b: \" << b << std :: endl ; std :: cout << \"sizeof(b): \" << sizeof ( b ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( b ) << std :: endl ; std :: cout << std :: endl ; double c = 1.34 ; std :: cout << \"double c: \" << c << std :: endl ; std :: cout << \"sizeof(c): \" << sizeof ( c ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( c ) << std :: endl ; std :: cout << std :: endl ; char d = 'g' ; std :: cout << \"char d: \" << d << std :: endl ; std :: cout << \"sizeof(d): \" << sizeof ( d ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( d ) << std :: endl ; std :: cout << std :: endl ; // Integer implicit precision long g = 25 ; std :: cout << \"long g: \" << g << std :: endl ; std :: cout << \"sizeof(g): \" << sizeof ( g ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( g ) << std :: endl ; std :: cout << std :: endl ; long long h = 8271 ; std :: cout << \"long long h: \" << h << std :: endl ; std :: cout << \"sizeof(h): \" << sizeof ( h ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( h ) << std :: endl ; std :: cout << std :: endl ; // Unsigned integer - implicit precision unsigned long i = 987312 ; std :: cout << \"unsigned long i: \" << i << std :: endl ; std :: cout << \"sizeof(i): \" << sizeof ( i ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( i ) << std :: endl ; std :: cout << std :: endl ; unsigned long long j = 4398271 ; std :: cout << \"unsigned long long j: \" << j << std :: endl ; std :: cout << \"sizeof(j): \" << sizeof ( j ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( j ) << std :: endl ; std :: cout << std :: endl ; // Integer explicit precision int8_t k = 25 ; std :: cout << \"int8_t k: \" << k << std :: endl ; std :: cout << \"sizeof(k): \" << sizeof ( k ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( k ) << std :: endl ; std :: cout << std :: endl ; int64_t l = 542 ; std :: cout << \"int64_t l: \" << l << std :: endl ; std :: cout << \"sizeof(l): \" << sizeof ( l ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( l ) << std :: endl ; std :: cout << std :: endl ; // Unsigned integer explicit precision uint8_t m = 54 ; std :: cout << \"uint8_t m: \" << m << std :: endl ; std :: cout << \"sizeof(m): \" << sizeof ( m ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( m ) << std :: endl ; std :: cout << std :: endl ; uint64_t n = 76354346 ; std :: cout << \"uint64_t n: \" << n << std :: endl ; std :: cout << \"sizeof(n): \" << sizeof ( n ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( n ) << std :: endl ; std :: cout << std :: endl ; // Floating point precision float o = 25.54 ; std :: cout << \"float o: \" << o << std :: endl ; std :: cout << \"sizeof(o): \" << sizeof ( o ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( o ) << std :: endl ; std :: cout << std :: endl ; long double p = 987312.325 ; std :: cout << \"long double p: \" << p << std :: endl ; std :: cout << \"sizeof(p): \" << sizeof ( p ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( p ) << std :: endl ; std :: cout << std :: endl ; // Char unsigned char q = 'c' ; std :: cout << \"unsigned char m: \" << q << std :: endl ; std :: cout << \"sizeof(q): \" << sizeof ( q ) << \" bytes\" << std :: endl ; std :: cout << get_bits ( q ) << std :: endl ; std :: cout << std :: endl ; return 0 ; } void print_endian () { if constexpr ( std :: endian :: native == std :: endian :: big ) { std :: cout << \"big-endian\" << '\\n' ; } else if constexpr ( std :: endian :: native == std :: endian :: little ) { std :: cout << \"little-endian platform\" << '\\n' ; } else { std :: cout << \"mixed-endian\" << '\\n' ; } } template < class T > std :: bitset < sizeof ( T ) * 8 > get_bits ( T v ) { auto ptr = reinterpret_cast < unsigned char *> ( & v ); unsigned long long bytes = ptr [ 0 ]; for ( size_t i = 1 ; i < sizeof ( v ); ++ i ) { bytes <<= 8 ; bytes += ptr [ i ]; } return std :: bitset < sizeof ( v ) * 8 > ( bytes ); }","title":"Fundamental Data Types"},{"location":"basic-syntax/data-types/operators/","text":"Operators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include <cmath> #include <iostream> using namespace std ; int main () { // Operators int number_1 = 8 ; int number_2 = 3 ; std :: cout << number_1 << \" + \" << number_2 << \": \" << number_1 + number_2 << std :: endl ; std :: cout << number_1 << \" - \" << number_2 << \": \" << number_1 - number_2 << std :: endl ; std :: cout << number_1 << \" * \" << number_2 << \": \" << number_1 * number_2 << std :: endl ; std :: cout << number_1 << \" / \" << number_2 << \": \" << number_1 / number_2 << std :: endl ; std :: cout << number_1 << \" % \" << number_2 << \": \" << number_1 % number_2 << std :: endl ; double number_3 = 8. ; double number_4 = 3. ; std :: cout << number_3 << \" + \" << number_4 << \": \" << number_3 + number_4 << std :: endl ; std :: cout << number_3 << \" - \" << number_4 << \": \" << number_3 - number_4 << std :: endl ; std :: cout << number_3 << \" * \" << number_4 << \": \" << number_3 * number_4 << std :: endl ; std :: cout << number_3 << \" / \" << number_4 << \": \" << number_3 / number_4 << std :: endl ; std :: cout << \"fmod(\" << number_3 << \", \" << number_4 << \"): \" << fmod ( number_3 , number_4 ) << std :: endl ; // Attribution operator number_1 += number_2 ; // number_1 = number_1 + number_2; std :: cout << \"number_1 after += is \" << number_1 << std :: endl ; number_1 -= number_2 ; std :: cout << \"number_1 after -= is \" << number_1 << std :: endl ; number_1 *= number_2 ; std :: cout << \"number_1 after *= is \" << number_1 << std :: endl ; number_1 /= number_2 ; std :: cout << \"number_1 after /= is \" << number_1 << std :: endl ; number_1 %= number_2 ; std :: cout << \"number_1 after %= is \" << number_1 << std :: endl ; // Postfixed increment/decrement number_1 ++ ; // or number_1 += 1; // or number_1 = number_1 + 1; std :: cout << \"number_1 after ++ is \" << number_1 << std :: endl ; number_1 -- ; std :: cout << \"number_1 after -- is \" << number_1 << std :: endl ; // Prefixed increment/decrement ++ number_1 ; // or number_1 += 1; // or number_1 = number_1 + 1; std :: cout << \"number_1 after ++ is \" << number_1 << std :: endl ; -- number_1 ; std :: cout << \"number_1 after -- is \" << number_1 << std :: endl ; // Inside an expression std :: cout << \"number_1: \" << number_1 ++ << std :: endl ; std :: cout << \"number_1: \" << ++ number_1 << std :: endl ; return 0 ; }","title":"Operators"},{"location":"basic-syntax/data-types/operators/#operators","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include <cmath> #include <iostream> using namespace std ; int main () { // Operators int number_1 = 8 ; int number_2 = 3 ; std :: cout << number_1 << \" + \" << number_2 << \": \" << number_1 + number_2 << std :: endl ; std :: cout << number_1 << \" - \" << number_2 << \": \" << number_1 - number_2 << std :: endl ; std :: cout << number_1 << \" * \" << number_2 << \": \" << number_1 * number_2 << std :: endl ; std :: cout << number_1 << \" / \" << number_2 << \": \" << number_1 / number_2 << std :: endl ; std :: cout << number_1 << \" % \" << number_2 << \": \" << number_1 % number_2 << std :: endl ; double number_3 = 8. ; double number_4 = 3. ; std :: cout << number_3 << \" + \" << number_4 << \": \" << number_3 + number_4 << std :: endl ; std :: cout << number_3 << \" - \" << number_4 << \": \" << number_3 - number_4 << std :: endl ; std :: cout << number_3 << \" * \" << number_4 << \": \" << number_3 * number_4 << std :: endl ; std :: cout << number_3 << \" / \" << number_4 << \": \" << number_3 / number_4 << std :: endl ; std :: cout << \"fmod(\" << number_3 << \", \" << number_4 << \"): \" << fmod ( number_3 , number_4 ) << std :: endl ; // Attribution operator number_1 += number_2 ; // number_1 = number_1 + number_2; std :: cout << \"number_1 after += is \" << number_1 << std :: endl ; number_1 -= number_2 ; std :: cout << \"number_1 after -= is \" << number_1 << std :: endl ; number_1 *= number_2 ; std :: cout << \"number_1 after *= is \" << number_1 << std :: endl ; number_1 /= number_2 ; std :: cout << \"number_1 after /= is \" << number_1 << std :: endl ; number_1 %= number_2 ; std :: cout << \"number_1 after %= is \" << number_1 << std :: endl ; // Postfixed increment/decrement number_1 ++ ; // or number_1 += 1; // or number_1 = number_1 + 1; std :: cout << \"number_1 after ++ is \" << number_1 << std :: endl ; number_1 -- ; std :: cout << \"number_1 after -- is \" << number_1 << std :: endl ; // Prefixed increment/decrement ++ number_1 ; // or number_1 += 1; // or number_1 = number_1 + 1; std :: cout << \"number_1 after ++ is \" << number_1 << std :: endl ; -- number_1 ; std :: cout << \"number_1 after -- is \" << number_1 << std :: endl ; // Inside an expression std :: cout << \"number_1: \" << number_1 ++ << std :: endl ; std :: cout << \"number_1: \" << ++ number_1 << std :: endl ; return 0 ; }","title":"Operators"},{"location":"basic-syntax/files/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 add_executable ( files files.cpp ) find_package ( Filesystem ) if ( Filesystem_FOUND ) add_executable ( filesystem_manage filesystem.cpp ) target_link_libraries ( filesystem_manage PRIVATE std::filesystem ) target_compile_definitions ( filesystem_manage PRIVATE -DCXX_FILESYSTEM_HEADER=< ${ CXX_FILESYSTEM_HEADER } > ) target_compile_definitions ( filesystem_manage PRIVATE -DCXX_FILESYSTEM_NAMESPACE= ${ CXX_FILESYSTEM_NAMESPACE } ) endif () FindFilesystem.cmake: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 # Distributed under the OSI-approved BSD 3-Clause License. See accompanying # file Copyright.txt or https://cmake.org/licensing for details. #[=======================================================================[.rst: FindFilesystem ############## This module supports the C++17 standard library's filesystem utilities. Use the :imp-target:`std::filesystem` imported target to Options ******* The ``COMPONENTS`` argument to this module supports the following values: .. find-component:: Experimental :name: fs.Experimental Allows the module to find the \"experimental\" Filesystem TS version of the Filesystem library. This is the library that should be used with the ``std::experimental::filesystem`` namespace. .. find-component:: Final :name: fs.Final Finds the final C++17 standard version of the filesystem library. If no components are provided, behaves as if the :find-component:`fs.Final` component was specified. If both :find-component:`fs.Experimental` and :find-component:`fs.Final` are provided, first looks for ``Final``, and falls back to ``Experimental`` in case of failure. If ``Final`` is found, :imp-target:`std::filesystem` and all :ref:`variables <fs.variables>` will refer to the ``Final`` version. Imported Targets **************** .. imp-target:: std::filesystem The ``std::filesystem`` imported target is defined when any requested version of the C++ filesystem library has been found, whether it is *Experimental* or *Final*. If no version of the filesystem library is available, this target will not be defined. .. note:: This target has ``cxx_std_17`` as an ``INTERFACE`` :ref:`compile language standard feature <req-lang-standards>`. Linking to this target will automatically enable C++17 if no later standard version is already required on the linking target. .. _fs.variables: Variables ********* .. variable:: CXX_FILESYSTEM_IS_EXPERIMENTAL Set to ``TRUE`` when the :find-component:`fs.Experimental` version of C++ filesystem library was found, otherwise ``FALSE``. .. variable:: CXX_FILESYSTEM_HAVE_FS Set to ``TRUE`` when a filesystem header was found. .. variable:: CXX_FILESYSTEM_HEADER Set to either ``filesystem`` or ``experimental/filesystem`` depending on whether :find-component:`fs.Final` or :find-component:`fs.Experimental` was found. .. variable:: CXX_FILESYSTEM_NAMESPACE Set to either ``std::filesystem`` or ``std::experimental::filesystem`` depending on whether :find-component:`fs.Final` or :find-component:`fs.Experimental` was found. Examples ******** Using ` find_package ( Filesystem ) ` with no component arguments: .. code-block:: cmake find_package ( Filesystem REQUIRED ) add_executable ( my-program main.cpp ) target_link_libraries ( my-program PRIVATE std::filesystem ) #]=======================================================================] if ( TARGET std::filesystem ) # This module has already been processed. Don't do it again. return () endif () cmake_minimum_required ( VERSION 3.10 ) include ( CMakePushCheckState ) include ( CheckIncludeFileCXX ) # If we're not cross-compiling, try to run test executables. # Otherwise, assume that compile + link is a sufficient check. if ( CMAKE_CROSSCOMPILING ) include ( CheckCXXSourceCompiles ) macro ( _cmcm_check_cxx_source code var ) check_cxx_source_compiles ( \"${code}\" ${ var } ) endmacro () else () include ( CheckCXXSourceRuns ) macro ( _cmcm_check_cxx_source code var ) check_cxx_source_runs ( \"${code}\" ${ var } ) endmacro () endif () cmake_push_check_state () set ( CMAKE_REQUIRED_QUIET ${ Filesystem_FIND_QUIETLY } ) # All of our tests required C++17 or later set ( CMAKE_CXX_STANDARD 17 ) # Normalize and check the component list we were given set ( want_components ${ Filesystem_FIND_COMPONENTS } ) if ( Filesystem_FIND_COMPONENTS STREQUAL \"\" ) set ( want_components Final ) endif () # Warn on any unrecognized components set ( extra_components ${ want_components } ) list ( REMOVE_ITEM extra_components Final Experimental ) foreach ( component IN LISTS extra_components ) message ( WARNING \"Extraneous find_package component for Filesystem: ${component}\" ) endforeach () # Detect which of Experimental and Final we should look for set ( find_experimental TRUE ) set ( find_final TRUE ) if ( NOT \"Final\" IN_LIST want_components ) set ( find_final FALSE ) endif () if ( NOT \"Experimental\" IN_LIST want_components ) set ( find_experimental FALSE ) endif () if ( find_final ) check_include_file_cxx ( \"filesystem\" _CXX_FILESYSTEM_HAVE_HEADER ) mark_as_advanced ( _CXX_FILESYSTEM_HAVE_HEADER ) if ( _CXX_FILESYSTEM_HAVE_HEADER ) # We found the non-experimental header. Don't bother looking for the # experimental one. set ( find_experimental FALSE ) endif () else () set ( _CXX_FILESYSTEM_HAVE_HEADER FALSE ) endif () if ( find_experimental ) check_include_file_cxx ( \"experimental/filesystem\" _CXX_FILESYSTEM_HAVE_EXPERIMENTAL_HEADER ) mark_as_advanced ( _CXX_FILESYSTEM_HAVE_EXPERIMENTAL_HEADER ) else () set ( _CXX_FILESYSTEM_HAVE_EXPERIMENTAL_HEADER FALSE ) endif () if ( _CXX_FILESYSTEM_HAVE_HEADER ) set ( _have_fs TRUE ) set ( _fs_header filesystem ) set ( _fs_namespace std::filesystem ) set ( _is_experimental FALSE ) elseif ( _CXX_FILESYSTEM_HAVE_EXPERIMENTAL_HEADER ) set ( _have_fs TRUE ) set ( _fs_header experimental/filesystem ) set ( _fs_namespace std::experimental::filesystem ) set ( _is_experimental TRUE ) else () set ( _have_fs FALSE ) endif () set ( CXX_FILESYSTEM_HAVE_FS ${ _have_fs } CACHE BOOL \"TRUE if we have the C++ filesystem headers\" ) set ( CXX_FILESYSTEM_HEADER ${ _fs_header } CACHE STRING \"The header that should be included to obtain the filesystem APIs\" ) set ( CXX_FILESYSTEM_NAMESPACE ${ _fs_namespace } CACHE STRING \"The C++ namespace that contains the filesystem APIs\" ) set ( CXX_FILESYSTEM_IS_EXPERIMENTAL ${ _is_experimental } CACHE BOOL \"TRUE if the C++ filesystem library is the experimental version\" ) set ( _found FALSE ) if ( CXX_FILESYSTEM_HAVE_FS ) # We have some filesystem library available. Do link checks string ( CONFIGURE [[ #include <cstdlib> #include <@CXX_FILESYSTEM_HEADER@> int main( ) { auto cwd = @CXX_FILESYSTEM_NAMESPACE@:: current_path () ; printf ( \"%s\" , cwd.c_str( ) ); return EXIT_SUCCESS; } ]] code @ONLY) # Check a simple filesystem program without any linker flags _cmcm_check_cxx_source ( \"${code}\" CXX_FILESYSTEM_NO_LINK_NEEDED ) set ( can_link ${ CXX_FILESYSTEM_NO_LINK_NEEDED } ) if ( NOT CXX_FILESYSTEM_NO_LINK_NEEDED ) set ( prev_libraries ${ CMAKE_REQUIRED_LIBRARIES } ) # Add the libstdc++ flag set ( CMAKE_REQUIRED_LIBRARIES ${ prev_libraries } -lstdc++fs ) _cmcm_check_cxx_source ( \"${code}\" CXX_FILESYSTEM_STDCPPFS_NEEDED ) set ( can_link ${ CXX_FILESYSTEM_STDCPPFS_NEEDED } ) if ( NOT CXX_FILESYSTEM_STDCPPFS_NEEDED ) # Try the libc++ flag set ( CMAKE_REQUIRED_LIBRARIES ${ prev_libraries } -lc++fs ) _cmcm_check_cxx_source ( \"${code}\" CXX_FILESYSTEM_CPPFS_NEEDED ) set ( can_link ${ CXX_FILESYSTEM_CPPFS_NEEDED } ) endif () endif () if ( can_link ) add_library ( std::filesystem INTERFACE IMPORTED ) set_property ( TARGET std::filesystem APPEND PROPERTY INTERFACE_COMPILE_FEATURES cxx_std_17 ) set ( _found TRUE ) if ( CXX_FILESYSTEM_NO_LINK_NEEDED ) # Nothing to add... elseif ( CXX_FILESYSTEM_STDCPPFS_NEEDED ) set_property ( TARGET std::filesystem APPEND PROPERTY INTERFACE_LINK_LIBRARIES -lstdc++fs ) elseif ( CXX_FILESYSTEM_CPPFS_NEEDED ) set_property ( TARGET std::filesystem APPEND PROPERTY INTERFACE_LINK_LIBRARIES -lc++fs ) endif () endif () endif () cmake_pop_check_state () set ( Filesystem_FOUND ${ _found } CACHE BOOL \"TRUE if we can run a program using std::filesystem\" FORCE ) if ( Filesystem_FIND_REQUIRED AND NOT Filesystem_FOUND ) message ( FATAL_ERROR \"Cannot run simple program using std::filesystem\" ) endif ()","title":"Build script"},{"location":"basic-syntax/files/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 add_executable ( files files.cpp ) find_package ( Filesystem ) if ( Filesystem_FOUND ) add_executable ( filesystem_manage filesystem.cpp ) target_link_libraries ( filesystem_manage PRIVATE std::filesystem ) target_compile_definitions ( filesystem_manage PRIVATE -DCXX_FILESYSTEM_HEADER=< ${ CXX_FILESYSTEM_HEADER } > ) target_compile_definitions ( filesystem_manage PRIVATE -DCXX_FILESYSTEM_NAMESPACE= ${ CXX_FILESYSTEM_NAMESPACE } ) endif () FindFilesystem.cmake: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 # Distributed under the OSI-approved BSD 3-Clause License. See accompanying # file Copyright.txt or https://cmake.org/licensing for details. #[=======================================================================[.rst: FindFilesystem ############## This module supports the C++17 standard library's filesystem utilities. Use the :imp-target:`std::filesystem` imported target to Options ******* The ``COMPONENTS`` argument to this module supports the following values: .. find-component:: Experimental :name: fs.Experimental Allows the module to find the \"experimental\" Filesystem TS version of the Filesystem library. This is the library that should be used with the ``std::experimental::filesystem`` namespace. .. find-component:: Final :name: fs.Final Finds the final C++17 standard version of the filesystem library. If no components are provided, behaves as if the :find-component:`fs.Final` component was specified. If both :find-component:`fs.Experimental` and :find-component:`fs.Final` are provided, first looks for ``Final``, and falls back to ``Experimental`` in case of failure. If ``Final`` is found, :imp-target:`std::filesystem` and all :ref:`variables <fs.variables>` will refer to the ``Final`` version. Imported Targets **************** .. imp-target:: std::filesystem The ``std::filesystem`` imported target is defined when any requested version of the C++ filesystem library has been found, whether it is *Experimental* or *Final*. If no version of the filesystem library is available, this target will not be defined. .. note:: This target has ``cxx_std_17`` as an ``INTERFACE`` :ref:`compile language standard feature <req-lang-standards>`. Linking to this target will automatically enable C++17 if no later standard version is already required on the linking target. .. _fs.variables: Variables ********* .. variable:: CXX_FILESYSTEM_IS_EXPERIMENTAL Set to ``TRUE`` when the :find-component:`fs.Experimental` version of C++ filesystem library was found, otherwise ``FALSE``. .. variable:: CXX_FILESYSTEM_HAVE_FS Set to ``TRUE`` when a filesystem header was found. .. variable:: CXX_FILESYSTEM_HEADER Set to either ``filesystem`` or ``experimental/filesystem`` depending on whether :find-component:`fs.Final` or :find-component:`fs.Experimental` was found. .. variable:: CXX_FILESYSTEM_NAMESPACE Set to either ``std::filesystem`` or ``std::experimental::filesystem`` depending on whether :find-component:`fs.Final` or :find-component:`fs.Experimental` was found. Examples ******** Using ` find_package ( Filesystem ) ` with no component arguments: .. code-block:: cmake find_package ( Filesystem REQUIRED ) add_executable ( my-program main.cpp ) target_link_libraries ( my-program PRIVATE std::filesystem ) #]=======================================================================] if ( TARGET std::filesystem ) # This module has already been processed. Don't do it again. return () endif () cmake_minimum_required ( VERSION 3.10 ) include ( CMakePushCheckState ) include ( CheckIncludeFileCXX ) # If we're not cross-compiling, try to run test executables. # Otherwise, assume that compile + link is a sufficient check. if ( CMAKE_CROSSCOMPILING ) include ( CheckCXXSourceCompiles ) macro ( _cmcm_check_cxx_source code var ) check_cxx_source_compiles ( \"${code}\" ${ var } ) endmacro () else () include ( CheckCXXSourceRuns ) macro ( _cmcm_check_cxx_source code var ) check_cxx_source_runs ( \"${code}\" ${ var } ) endmacro () endif () cmake_push_check_state () set ( CMAKE_REQUIRED_QUIET ${ Filesystem_FIND_QUIETLY } ) # All of our tests required C++17 or later set ( CMAKE_CXX_STANDARD 17 ) # Normalize and check the component list we were given set ( want_components ${ Filesystem_FIND_COMPONENTS } ) if ( Filesystem_FIND_COMPONENTS STREQUAL \"\" ) set ( want_components Final ) endif () # Warn on any unrecognized components set ( extra_components ${ want_components } ) list ( REMOVE_ITEM extra_components Final Experimental ) foreach ( component IN LISTS extra_components ) message ( WARNING \"Extraneous find_package component for Filesystem: ${component}\" ) endforeach () # Detect which of Experimental and Final we should look for set ( find_experimental TRUE ) set ( find_final TRUE ) if ( NOT \"Final\" IN_LIST want_components ) set ( find_final FALSE ) endif () if ( NOT \"Experimental\" IN_LIST want_components ) set ( find_experimental FALSE ) endif () if ( find_final ) check_include_file_cxx ( \"filesystem\" _CXX_FILESYSTEM_HAVE_HEADER ) mark_as_advanced ( _CXX_FILESYSTEM_HAVE_HEADER ) if ( _CXX_FILESYSTEM_HAVE_HEADER ) # We found the non-experimental header. Don't bother looking for the # experimental one. set ( find_experimental FALSE ) endif () else () set ( _CXX_FILESYSTEM_HAVE_HEADER FALSE ) endif () if ( find_experimental ) check_include_file_cxx ( \"experimental/filesystem\" _CXX_FILESYSTEM_HAVE_EXPERIMENTAL_HEADER ) mark_as_advanced ( _CXX_FILESYSTEM_HAVE_EXPERIMENTAL_HEADER ) else () set ( _CXX_FILESYSTEM_HAVE_EXPERIMENTAL_HEADER FALSE ) endif () if ( _CXX_FILESYSTEM_HAVE_HEADER ) set ( _have_fs TRUE ) set ( _fs_header filesystem ) set ( _fs_namespace std::filesystem ) set ( _is_experimental FALSE ) elseif ( _CXX_FILESYSTEM_HAVE_EXPERIMENTAL_HEADER ) set ( _have_fs TRUE ) set ( _fs_header experimental/filesystem ) set ( _fs_namespace std::experimental::filesystem ) set ( _is_experimental TRUE ) else () set ( _have_fs FALSE ) endif () set ( CXX_FILESYSTEM_HAVE_FS ${ _have_fs } CACHE BOOL \"TRUE if we have the C++ filesystem headers\" ) set ( CXX_FILESYSTEM_HEADER ${ _fs_header } CACHE STRING \"The header that should be included to obtain the filesystem APIs\" ) set ( CXX_FILESYSTEM_NAMESPACE ${ _fs_namespace } CACHE STRING \"The C++ namespace that contains the filesystem APIs\" ) set ( CXX_FILESYSTEM_IS_EXPERIMENTAL ${ _is_experimental } CACHE BOOL \"TRUE if the C++ filesystem library is the experimental version\" ) set ( _found FALSE ) if ( CXX_FILESYSTEM_HAVE_FS ) # We have some filesystem library available. Do link checks string ( CONFIGURE [[ #include <cstdlib> #include <@CXX_FILESYSTEM_HEADER@> int main( ) { auto cwd = @CXX_FILESYSTEM_NAMESPACE@:: current_path () ; printf ( \"%s\" , cwd.c_str( ) ); return EXIT_SUCCESS; } ]] code @ONLY) # Check a simple filesystem program without any linker flags _cmcm_check_cxx_source ( \"${code}\" CXX_FILESYSTEM_NO_LINK_NEEDED ) set ( can_link ${ CXX_FILESYSTEM_NO_LINK_NEEDED } ) if ( NOT CXX_FILESYSTEM_NO_LINK_NEEDED ) set ( prev_libraries ${ CMAKE_REQUIRED_LIBRARIES } ) # Add the libstdc++ flag set ( CMAKE_REQUIRED_LIBRARIES ${ prev_libraries } -lstdc++fs ) _cmcm_check_cxx_source ( \"${code}\" CXX_FILESYSTEM_STDCPPFS_NEEDED ) set ( can_link ${ CXX_FILESYSTEM_STDCPPFS_NEEDED } ) if ( NOT CXX_FILESYSTEM_STDCPPFS_NEEDED ) # Try the libc++ flag set ( CMAKE_REQUIRED_LIBRARIES ${ prev_libraries } -lc++fs ) _cmcm_check_cxx_source ( \"${code}\" CXX_FILESYSTEM_CPPFS_NEEDED ) set ( can_link ${ CXX_FILESYSTEM_CPPFS_NEEDED } ) endif () endif () if ( can_link ) add_library ( std::filesystem INTERFACE IMPORTED ) set_property ( TARGET std::filesystem APPEND PROPERTY INTERFACE_COMPILE_FEATURES cxx_std_17 ) set ( _found TRUE ) if ( CXX_FILESYSTEM_NO_LINK_NEEDED ) # Nothing to add... elseif ( CXX_FILESYSTEM_STDCPPFS_NEEDED ) set_property ( TARGET std::filesystem APPEND PROPERTY INTERFACE_LINK_LIBRARIES -lstdc++fs ) elseif ( CXX_FILESYSTEM_CPPFS_NEEDED ) set_property ( TARGET std::filesystem APPEND PROPERTY INTERFACE_LINK_LIBRARIES -lc++fs ) endif () endif () endif () cmake_pop_check_state () set ( Filesystem_FOUND ${ _found } CACHE BOOL \"TRUE if we can run a program using std::filesystem\" FORCE ) if ( Filesystem_FIND_REQUIRED AND NOT Filesystem_FOUND ) message ( FATAL_ERROR \"Cannot run simple program using std::filesystem\" ) endif ()","title":"Build script"},{"location":"basic-syntax/files/file-streams/","text":"File streams 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include <array> #include <chrono> #include <filesystem> #include <fstream> #include <iomanip> #include <iostream> #include <memory> #include <vector> #include <algorithm> int main () { using namespace std ; vector < int > numbers ; numbers . resize ( 15 ); for ( size_t i = 0 ; i < 15 ; ++ i ) { numbers . emplace_back ( i * 10 + 1 ); } // Save numbers in text file ofstream fout ( \"numbers.txt\" ); for ( int number : numbers ) { fout << number << \" \" ; } fout . close (); // Load numbers from text file vector < int > m_numbers ; ifstream fin ( \"numbers.txt\" ); for ( size_t i = 0 ; i < numbers . size (); ++ i ) { int x ; fin >> x ; m_numbers . emplace_back ( x ); } fin . close (); // Print numbers for_each ( numbers . begin (), numbers . end (), []( auto x ) { cout << x << \" \" ; }); cout << endl ; for_each ( m_numbers . begin (), m_numbers . end (), []( auto x ) { cout << x << \" \" ; }); cout << endl ; // Save numbers in binary file fout . open ( \"numbers.bin\" , ios :: binary ); for ( int & number : numbers ) { char * pointer_to_number = ( char * ) & number ; size_t bytes_per_number = sizeof ( number ); fout . write ( pointer_to_number , bytes_per_number ); } fout . close (); // Load numbers from binary file m_numbers . clear (); fin . open ( \"numbers.bin\" , ios :: binary ); for ( size_t i = 0 ; i < numbers . size (); ++ i ) { int x ; char * pointer_to_number = ( char * ) & x ; size_t bytes_per_number = sizeof ( x ); fin . read ( pointer_to_number , bytes_per_number ); m_numbers . emplace_back ( x ); } fin . close (); // Print numbers for_each ( numbers . begin (), numbers . end (), []( auto x ) { cout << x << \" \" ; }); cout << endl ; for_each ( m_numbers . begin (), m_numbers . end (), []( auto x ) { cout << x << \" \" ; }); cout << endl ; // Compare file sizes cout << \"File size (text): \" << filesystem :: file_size ( \"numbers.txt\" ) << \" bytes\" << endl ; cout << \"File size (binary): \" << filesystem :: file_size ( \"numbers.bin\" ) << \" bytes\" << endl ; return 0 ; }","title":"File streams"},{"location":"basic-syntax/files/file-streams/#file-streams","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include <array> #include <chrono> #include <filesystem> #include <fstream> #include <iomanip> #include <iostream> #include <memory> #include <vector> #include <algorithm> int main () { using namespace std ; vector < int > numbers ; numbers . resize ( 15 ); for ( size_t i = 0 ; i < 15 ; ++ i ) { numbers . emplace_back ( i * 10 + 1 ); } // Save numbers in text file ofstream fout ( \"numbers.txt\" ); for ( int number : numbers ) { fout << number << \" \" ; } fout . close (); // Load numbers from text file vector < int > m_numbers ; ifstream fin ( \"numbers.txt\" ); for ( size_t i = 0 ; i < numbers . size (); ++ i ) { int x ; fin >> x ; m_numbers . emplace_back ( x ); } fin . close (); // Print numbers for_each ( numbers . begin (), numbers . end (), []( auto x ) { cout << x << \" \" ; }); cout << endl ; for_each ( m_numbers . begin (), m_numbers . end (), []( auto x ) { cout << x << \" \" ; }); cout << endl ; // Save numbers in binary file fout . open ( \"numbers.bin\" , ios :: binary ); for ( int & number : numbers ) { char * pointer_to_number = ( char * ) & number ; size_t bytes_per_number = sizeof ( number ); fout . write ( pointer_to_number , bytes_per_number ); } fout . close (); // Load numbers from binary file m_numbers . clear (); fin . open ( \"numbers.bin\" , ios :: binary ); for ( size_t i = 0 ; i < numbers . size (); ++ i ) { int x ; char * pointer_to_number = ( char * ) & x ; size_t bytes_per_number = sizeof ( x ); fin . read ( pointer_to_number , bytes_per_number ); m_numbers . emplace_back ( x ); } fin . close (); // Print numbers for_each ( numbers . begin (), numbers . end (), []( auto x ) { cout << x << \" \" ; }); cout << endl ; for_each ( m_numbers . begin (), m_numbers . end (), []( auto x ) { cout << x << \" \" ; }); cout << endl ; // Compare file sizes cout << \"File size (text): \" << filesystem :: file_size ( \"numbers.txt\" ) << \" bytes\" << endl ; cout << \"File size (binary): \" << filesystem :: file_size ( \"numbers.bin\" ) << \" bytes\" << endl ; return 0 ; }","title":"File streams"},{"location":"basic-syntax/files/filesystem/","text":"Filesystem 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 #include CXX_FILESYSTEM_HEADER #include <fstream> #include <iostream> #include <string> int main () { using namespace std ; namespace fs = CXX_FILESYSTEM_NAMESPACE ; // Writing to file ofstream fout ; fout . open ( \"example.txt\" ); if ( fout . is_open ()) { fout << \"This is a line. \\n \" ; fout << \"This is another line. \\n \" ; fout . close (); } // Reading from file string line ; ifstream fin ( \"example.txt\" ); if ( fin . is_open ()) { while ( getline ( fin , line )) { cout << line << '\\n' ; } fin . close (); } // Describing paths fs :: path p1 { \"C: \\\\ \" }; fs :: path p2 { \"C: \\\\ Windows\" }; fs :: path p3 { L \"C: \\\\ Boost C++ \\u5E93 \" }; cout << \"p2.string(): \" << p2 . string () << '\\n' ; cout << \"p2.generic_string(): \" << p2 . generic_string () << '\\n' ; // Portable path fs :: path root_p { \"/\" }; cout << \"root_p.string(): \" << root_p . string () << '\\n' ; cout << \"root_p.generic_string(): \" << root_p . generic_string () << '\\n' ; // Path components fs :: path p { \"C: \\\\ Windows \\\\ System \\\\ photo.jpg\" }; cout << \"p.root_name(): \" << p . root_name () << '\\n' ; cout << \"p.root_directory(): \" << p . root_directory () << '\\n' ; cout << \"p.root_path(): \" << p . root_path () << '\\n' ; cout << \"p.relative_path(): \" << p . relative_path () << '\\n' ; cout << \"p.parent_path(): \" << p . parent_path () << '\\n' ; cout << \"p.filename(): \" << p . filename () << '\\n' ; cout << \"p.stem(): \" << p . stem () << '\\n' ; cout << \"p.extension(): \" << p . extension () << '\\n' ; fs :: path pl { \"/Linux/System/photo.jpg\" }; cout << \"pl: \" << pl << '\\n' ; cout << \"pl.lexically_proximate( \\\" /Linux/ \\\" ): \" << pl . lexically_proximate ( \"/Linux/\" ) << '\\n' ; cout << \"pl.root_name(): \" << pl . root_name () << '\\n' ; cout << \"pl.root_directory(): \" << pl . root_directory () << '\\n' ; cout << \"pl.root_path(): \" << pl . root_path () << '\\n' ; cout << \"pl.relative_path(): \" << pl . relative_path () << '\\n' ; cout << \"pl.parent_path(): \" << pl . parent_path () << '\\n' ; cout << \"pl.filename(): \" << pl . filename () << '\\n' ; cout << \"pl.stem(): \" << pl . stem () << '\\n' ; cout << \"pl.extension(): \" << pl . extension () << '\\n' ; fs :: path p4 { \"C: \\\\ Windows \\\\ System \\\\ photo.jpg\" }; for ( const fs :: path & pp : p4 ) { cout << pp << endl ; } fs :: path p5 { \"/Linux/System/photo.jpg\" }; for ( const fs :: path & pp : p5 ) { cout << pp << endl ; } fs :: path p6 { \"/\" }; p6 /= \"Linux/System\" ; for ( const fs :: path & pp : p6 ) { cout << pp << endl ; } // Files and Directories: // Testing if it's directory fs :: path p7 { \"/\" }; try { fs :: file_status s = status ( p7 ); cout << boolalpha << fs :: is_directory ( s ) << '\\n' ; } catch ( fs :: filesystem_error & e ) { cerr << e . what () << '\\n' ; } // File size fs :: path p8 { \"C: \\\\ Windows \\\\ win.ini\" }; error_code ec ; size_t filesize = fs :: file_size ( p8 , ec ); if ( ! ec ) { cout << filesize << '\\n' ; } else { cout << ec << '\\n' ; } // Last time write fs :: path p9 { \"C: \\\\ Windows \\\\ win.ini\" }; try { // Maybe unused as an example, because the next code snippet // is not portable [[ maybe_unused ]] fs :: file_time_type t = last_write_time ( p9 ); /* The following is not portable: https://en.cppreference.com/w/cpp/filesystem/file_time_type std::time_t cftime = fs::file_time_type::clock::to_time_t(t); cout << cftime << '\\n'; */ } catch ( fs :: filesystem_error & e ) { cout << e . what () << '\\n' ; } // Retrieve total and remaining disk space fs :: path p10 { \"/\" }; try { fs :: space_info s = space ( p10 ); cout << \"s.capacity: \" << s . capacity << \" bytes\" << endl ; cout << \"s.free: \" << s . free << \" bytes\" << endl ; cout << \"s.available: \" << s . available << \" bytes\" << endl ; } catch ( fs :: filesystem_error & e ) { cerr << e . what () << '\\n' ; } // Creating, renaming, and deleting directories fs :: path p11 = fs :: current_path (); p /= \"test_directory\" ; try { if ( create_directory ( p11 )) { fs :: path p12 = fs :: current_path (); p12 /= \"test_directory2\" ; rename ( p , p12 ); fs :: remove ( p12 ); } else { cout << \"The path could not be created\" << endl ; } } catch ( fs :: filesystem_error & e ) { cerr << e . what () << '\\n' ; } // absolute path based on a file name try { cout << fs :: absolute ( \"photo.jpg\" ) << '\\n' ; } catch ( fs :: filesystem_error & e ) { cerr << e . what () << '\\n' ; } // Directory Iterators // Iterating over files fs :: path p13 = fs :: current_path (); fs :: directory_iterator range { p13 }; for ( auto & p : range ) { cout << p . path (). filename () << '\\n' ; } // Recursively iterating over files fs :: path p14 = fs :: current_path (); fs :: recursive_directory_iterator it { p14 }; while ( it != fs :: recursive_directory_iterator {}) { cout << it -> path (). lexically_proximate ( fs :: current_path ()) << '\\n' ; ++ it ; } // File Streams from paths // Streaming to files fs :: path p15 = fs :: absolute ( \"example_text.txt\" ); ofstream ofs { p15 }; ofs << \"Hello, world! \\n \" ; ofs << \"Bye, world! \\n \" ; return 0 ; }","title":"Filesystem"},{"location":"basic-syntax/files/filesystem/#filesystem","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 #include CXX_FILESYSTEM_HEADER #include <fstream> #include <iostream> #include <string> int main () { using namespace std ; namespace fs = CXX_FILESYSTEM_NAMESPACE ; // Writing to file ofstream fout ; fout . open ( \"example.txt\" ); if ( fout . is_open ()) { fout << \"This is a line. \\n \" ; fout << \"This is another line. \\n \" ; fout . close (); } // Reading from file string line ; ifstream fin ( \"example.txt\" ); if ( fin . is_open ()) { while ( getline ( fin , line )) { cout << line << '\\n' ; } fin . close (); } // Describing paths fs :: path p1 { \"C: \\\\ \" }; fs :: path p2 { \"C: \\\\ Windows\" }; fs :: path p3 { L \"C: \\\\ Boost C++ \\u5E93 \" }; cout << \"p2.string(): \" << p2 . string () << '\\n' ; cout << \"p2.generic_string(): \" << p2 . generic_string () << '\\n' ; // Portable path fs :: path root_p { \"/\" }; cout << \"root_p.string(): \" << root_p . string () << '\\n' ; cout << \"root_p.generic_string(): \" << root_p . generic_string () << '\\n' ; // Path components fs :: path p { \"C: \\\\ Windows \\\\ System \\\\ photo.jpg\" }; cout << \"p.root_name(): \" << p . root_name () << '\\n' ; cout << \"p.root_directory(): \" << p . root_directory () << '\\n' ; cout << \"p.root_path(): \" << p . root_path () << '\\n' ; cout << \"p.relative_path(): \" << p . relative_path () << '\\n' ; cout << \"p.parent_path(): \" << p . parent_path () << '\\n' ; cout << \"p.filename(): \" << p . filename () << '\\n' ; cout << \"p.stem(): \" << p . stem () << '\\n' ; cout << \"p.extension(): \" << p . extension () << '\\n' ; fs :: path pl { \"/Linux/System/photo.jpg\" }; cout << \"pl: \" << pl << '\\n' ; cout << \"pl.lexically_proximate( \\\" /Linux/ \\\" ): \" << pl . lexically_proximate ( \"/Linux/\" ) << '\\n' ; cout << \"pl.root_name(): \" << pl . root_name () << '\\n' ; cout << \"pl.root_directory(): \" << pl . root_directory () << '\\n' ; cout << \"pl.root_path(): \" << pl . root_path () << '\\n' ; cout << \"pl.relative_path(): \" << pl . relative_path () << '\\n' ; cout << \"pl.parent_path(): \" << pl . parent_path () << '\\n' ; cout << \"pl.filename(): \" << pl . filename () << '\\n' ; cout << \"pl.stem(): \" << pl . stem () << '\\n' ; cout << \"pl.extension(): \" << pl . extension () << '\\n' ; fs :: path p4 { \"C: \\\\ Windows \\\\ System \\\\ photo.jpg\" }; for ( const fs :: path & pp : p4 ) { cout << pp << endl ; } fs :: path p5 { \"/Linux/System/photo.jpg\" }; for ( const fs :: path & pp : p5 ) { cout << pp << endl ; } fs :: path p6 { \"/\" }; p6 /= \"Linux/System\" ; for ( const fs :: path & pp : p6 ) { cout << pp << endl ; } // Files and Directories: // Testing if it's directory fs :: path p7 { \"/\" }; try { fs :: file_status s = status ( p7 ); cout << boolalpha << fs :: is_directory ( s ) << '\\n' ; } catch ( fs :: filesystem_error & e ) { cerr << e . what () << '\\n' ; } // File size fs :: path p8 { \"C: \\\\ Windows \\\\ win.ini\" }; error_code ec ; size_t filesize = fs :: file_size ( p8 , ec ); if ( ! ec ) { cout << filesize << '\\n' ; } else { cout << ec << '\\n' ; } // Last time write fs :: path p9 { \"C: \\\\ Windows \\\\ win.ini\" }; try { // Maybe unused as an example, because the next code snippet // is not portable [[ maybe_unused ]] fs :: file_time_type t = last_write_time ( p9 ); /* The following is not portable: https://en.cppreference.com/w/cpp/filesystem/file_time_type std::time_t cftime = fs::file_time_type::clock::to_time_t(t); cout << cftime << '\\n'; */ } catch ( fs :: filesystem_error & e ) { cout << e . what () << '\\n' ; } // Retrieve total and remaining disk space fs :: path p10 { \"/\" }; try { fs :: space_info s = space ( p10 ); cout << \"s.capacity: \" << s . capacity << \" bytes\" << endl ; cout << \"s.free: \" << s . free << \" bytes\" << endl ; cout << \"s.available: \" << s . available << \" bytes\" << endl ; } catch ( fs :: filesystem_error & e ) { cerr << e . what () << '\\n' ; } // Creating, renaming, and deleting directories fs :: path p11 = fs :: current_path (); p /= \"test_directory\" ; try { if ( create_directory ( p11 )) { fs :: path p12 = fs :: current_path (); p12 /= \"test_directory2\" ; rename ( p , p12 ); fs :: remove ( p12 ); } else { cout << \"The path could not be created\" << endl ; } } catch ( fs :: filesystem_error & e ) { cerr << e . what () << '\\n' ; } // absolute path based on a file name try { cout << fs :: absolute ( \"photo.jpg\" ) << '\\n' ; } catch ( fs :: filesystem_error & e ) { cerr << e . what () << '\\n' ; } // Directory Iterators // Iterating over files fs :: path p13 = fs :: current_path (); fs :: directory_iterator range { p13 }; for ( auto & p : range ) { cout << p . path (). filename () << '\\n' ; } // Recursively iterating over files fs :: path p14 = fs :: current_path (); fs :: recursive_directory_iterator it { p14 }; while ( it != fs :: recursive_directory_iterator {}) { cout << it -> path (). lexically_proximate ( fs :: current_path ()) << '\\n' ; ++ it ; } // File Streams from paths // Streaming to files fs :: path p15 = fs :: absolute ( \"example_text.txt\" ); ofstream ofs { p15 }; ofs << \"Hello, world! \\n \" ; ofs << \"Bye, world! \\n \" ; return 0 ; }","title":"Filesystem"},{"location":"basic-syntax/functions/build-script/","text":"Build script 1 2 3 add_executable ( functions functions.cpp ) add_executable ( lambda lambda.cpp )","title":"Build script"},{"location":"basic-syntax/functions/build-script/#build-script","text":"1 2 3 add_executable ( functions functions.cpp ) add_executable ( lambda lambda.cpp )","title":"Build script"},{"location":"basic-syntax/functions/function/","text":"Function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 #include <algorithm> #include <array> #include <chrono> #include <iostream> #include <memory> using namespace std ; // No return void show_menu (); // Constexpr function - One return value constexpr double pi () { return 3.14159265358979323846 ; } // One parameter double power_three ( double x ); // Two parameters double power ( double x , int y ); // Parameters by reference void times_two ( int & x ); // Parameters by reference - Default parameter void increment_all ( array < int , 1000 > & a , int increment_value = 1 ); // Parameters by const reference bool has_element ( const array < int , 1000 > & a , int element ); // \"Return\" two values by reference void maxmin ( int a , int b , int c , int & minimum , int & maximum ); // \"Return\" three values by reference void sort ( int a , int b , int c , int & minimum , int & middle , int & maximum ); // Return two values with a pair pair < int , int > maxmin ( int a , int b , int c ); // Return three+ values with a tuple tuple < int , int , int > sort ( int a , int b , int c ); // Parameter by pointer by value void pointer_to_cube ( shared_ptr < int > p ); // Iterative function int fibonacci_iterative ( int n ); // Recursive function int fibonacci_recursive ( int n ); int main () { // No return function int opt = 3 ; do { show_menu (); -- opt ; } while ( opt != 0 ); // One return value cout << \"\u03c0 = \" << pi () << endl ; // One parameter cout << \"4.4^3 = \" << power_three ( 4.4 ) << endl ; // Two parameters cout << \"4.4^5 = \" << power ( 4.4 , 5 ) << endl ; // Parameters by reference int x = 5 ; times_two ( x ); cout << \"x = \" << x << endl ; // Parameter by reference // - Always pass arrays by reference to avoid copying array < int , 1000 > v {}; increment_all ( v ); for ( size_t i = 0 ; i < v . size () && i < 20 ; ++ i ) { cout << v [ i ] << \" \" ; } cout << endl ; increment_all ( v , 10 ); for ( size_t i = 0 ; i < v . size () && i < 20 ; ++ i ) { cout << v [ i ] << \" \" ; } cout << endl ; // Parameters by constant reference // - We don't want to copy // - But we also don't want to change it for ( size_t i = 0 ; i < v . size (); ++ i ) { v [ i ] = i ; } if ( has_element ( v , 400 )) { cout << \"Array v has the element 400\" << endl ; } else { cout << \"Array v doesn't have the element 400\" << endl ; } // \"Returning\" two values by reference int maximum ; int minimum ; maxmin ( 5 , 3 , 8 , minimum , maximum ); cout << \"Minimum and maximum: \" << minimum << \", \" << maximum << endl ; // \"Returning\" three values by reference int middle ; sort ( 5 , 3 , 8 , minimum , middle , maximum ); cout << \"Sorting 5, 3, 8 = \" << minimum << \", \" << middle << \", \" << maximum << endl ; // Returning two values with a pair pair < int , int > p = maxmin ( 5 , 3 , 8 ); cout << \"Minimum and maximum: \" << p . first << \", \" << p . second << endl ; // Returning two values with structured binding (for new variables) auto [ m1 , m2 ] = maxmin ( 5 , 3 , 8 ); cout << \"Minimum and maximum: \" << m1 << \", \" << m2 << endl ; // Returning two values with tie (for existing variables) tie ( m1 , m2 ) = maxmin ( 5 , 3 , 8 ); cout << \"Minimum and maximum: \" << m1 << \", \" << m2 << endl ; // Returning three values with a tuple tuple < int , int , int > t = sort ( 5 , 3 , 8 ); cout << \"Sorting 5, 3, 8: \" << get < 0 > ( t ) << \", \" << get < 1 > ( t ) << \", \" << get < 2 > ( t ) << endl ; // Returning three values with structured binding (for new variables) auto [ minimum3 , middle3 , maximum3 ] = sort ( 5 , 3 , 8 ); cout << \"Sorting 5, 3, 8: \" << minimum3 << \", \" << middle3 << \", \" << maximum3 << endl ; // Returning three values with tie (for existing variables) tie ( minimum3 , middle3 , maximum3 ) = sort ( 5 , 3 , 8 ); cout << \"Sorting 5, 3, 8: \" << minimum3 << \", \" << middle3 << \", \" << maximum3 << endl ; // Parameter by pointer by value shared_ptr < int > ptr = make_shared < int > ( 5 ); pointer_to_cube ( ptr ); cout << \"5^3 = \" << * ptr << endl ; // Recursive functions cout << \"fibonacci_iterative(6) = \" << fibonacci_iterative ( 6 ) << endl ; cout << \"fibonacci_recursive(6) = \" << fibonacci_recursive ( 6 ) << endl ; return 0 ; } void show_menu () { cout << \"Options: \\n \" \"[0] Exit \\n \" \"[1] Sum \\n \" \"[2] Multiply\" << endl ; } double power_three ( double x ) { return x * x * x ; } double power ( double x , int y ) { double result = 1 ; for ( int i = 0 ; i < y ; ++ i ) { result *= x ; } return result ; } void times_two ( int & x ) { x = 2 * x ; } void maxmin ( int a , int b , int c , int & minimum , int & maximum ) { if ( a > b ) { minimum = b ; maximum = a ; } else { minimum = a ; maximum = b ; } if ( c > maximum ) { maximum = c ; } if ( c < minimum ) { minimum = c ; } } pair < int , int > maxmin ( int a , int b , int c ) { int minimum ; int maximum ; if ( a > b ) { minimum = b ; maximum = a ; } else { minimum = a ; maximum = b ; } if ( c > maximum ) { maximum = c ; } if ( c < minimum ) { minimum = c ; } return make_pair ( minimum , maximum ); } void sort ( int a , int b , int c , int & minimum , int & middle , int & maximum ) { maxmin ( a , b , c , minimum , maximum ); if ( a != minimum && a != maximum ) { middle = a ; return ; } if ( b != minimum && b != maximum ) { middle = b ; return ; } middle = c ; } tuple < int , int , int > sort ( int a , int b , int c ) { auto [ minimum , maximum ] = maxmin ( a , b , c ); if ( a != minimum && a != maximum ) { return make_tuple ( minimum , a , maximum ); } if ( b != minimum && b != maximum ) { return make_tuple ( minimum , b , maximum ); } return make_tuple ( minimum , b , maximum ); } bool has_element ( const array < int , 1000 > & a , int element ) { return std :: any_of ( a . begin (), a . end (), [ element ]( int x ) { return x == element ; }); } void increment_all ( array < int , 1000 > & a , int increment_value ) { for ( int & x : a ) { x += increment_value ; } } // Pass pointers by value: https://youtu.be/xGDLkt-jBJ4?t=869 // As small as the reference and no other level of indirection // NOLINTNEXTLINE(performance-unnecessary-value-param): Does not apply to // pointers void pointer_to_cube ( shared_ptr < int > p ) { if ( p ) { * p = * p * * p * * p ; } } int fibonacci_iterative ( int n ) { if ( n <= 2 ) { return 1 ; } int fn ; int fn_1 = 1 ; int fn_2 = 1 ; for ( int i = 3 ; i <= n ; ++ i ) { fn = fn_1 + fn_2 ; fn_2 = fn_1 ; fn_1 = fn ; } return fn ; } // NOLINTNEXTLINE(misc-no-recursion): making a point here int fibonacci_recursive ( int n ) { if ( n > 2 ) { return fibonacci_recursive ( n - 1 ) + fibonacci_recursive ( n - 2 ); } else { return 1 ; } } Related examples: examples/functions/recursive_bench.cpp","title":"Function"},{"location":"basic-syntax/functions/function/#function","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 #include <algorithm> #include <array> #include <chrono> #include <iostream> #include <memory> using namespace std ; // No return void show_menu (); // Constexpr function - One return value constexpr double pi () { return 3.14159265358979323846 ; } // One parameter double power_three ( double x ); // Two parameters double power ( double x , int y ); // Parameters by reference void times_two ( int & x ); // Parameters by reference - Default parameter void increment_all ( array < int , 1000 > & a , int increment_value = 1 ); // Parameters by const reference bool has_element ( const array < int , 1000 > & a , int element ); // \"Return\" two values by reference void maxmin ( int a , int b , int c , int & minimum , int & maximum ); // \"Return\" three values by reference void sort ( int a , int b , int c , int & minimum , int & middle , int & maximum ); // Return two values with a pair pair < int , int > maxmin ( int a , int b , int c ); // Return three+ values with a tuple tuple < int , int , int > sort ( int a , int b , int c ); // Parameter by pointer by value void pointer_to_cube ( shared_ptr < int > p ); // Iterative function int fibonacci_iterative ( int n ); // Recursive function int fibonacci_recursive ( int n ); int main () { // No return function int opt = 3 ; do { show_menu (); -- opt ; } while ( opt != 0 ); // One return value cout << \"\u03c0 = \" << pi () << endl ; // One parameter cout << \"4.4^3 = \" << power_three ( 4.4 ) << endl ; // Two parameters cout << \"4.4^5 = \" << power ( 4.4 , 5 ) << endl ; // Parameters by reference int x = 5 ; times_two ( x ); cout << \"x = \" << x << endl ; // Parameter by reference // - Always pass arrays by reference to avoid copying array < int , 1000 > v {}; increment_all ( v ); for ( size_t i = 0 ; i < v . size () && i < 20 ; ++ i ) { cout << v [ i ] << \" \" ; } cout << endl ; increment_all ( v , 10 ); for ( size_t i = 0 ; i < v . size () && i < 20 ; ++ i ) { cout << v [ i ] << \" \" ; } cout << endl ; // Parameters by constant reference // - We don't want to copy // - But we also don't want to change it for ( size_t i = 0 ; i < v . size (); ++ i ) { v [ i ] = i ; } if ( has_element ( v , 400 )) { cout << \"Array v has the element 400\" << endl ; } else { cout << \"Array v doesn't have the element 400\" << endl ; } // \"Returning\" two values by reference int maximum ; int minimum ; maxmin ( 5 , 3 , 8 , minimum , maximum ); cout << \"Minimum and maximum: \" << minimum << \", \" << maximum << endl ; // \"Returning\" three values by reference int middle ; sort ( 5 , 3 , 8 , minimum , middle , maximum ); cout << \"Sorting 5, 3, 8 = \" << minimum << \", \" << middle << \", \" << maximum << endl ; // Returning two values with a pair pair < int , int > p = maxmin ( 5 , 3 , 8 ); cout << \"Minimum and maximum: \" << p . first << \", \" << p . second << endl ; // Returning two values with structured binding (for new variables) auto [ m1 , m2 ] = maxmin ( 5 , 3 , 8 ); cout << \"Minimum and maximum: \" << m1 << \", \" << m2 << endl ; // Returning two values with tie (for existing variables) tie ( m1 , m2 ) = maxmin ( 5 , 3 , 8 ); cout << \"Minimum and maximum: \" << m1 << \", \" << m2 << endl ; // Returning three values with a tuple tuple < int , int , int > t = sort ( 5 , 3 , 8 ); cout << \"Sorting 5, 3, 8: \" << get < 0 > ( t ) << \", \" << get < 1 > ( t ) << \", \" << get < 2 > ( t ) << endl ; // Returning three values with structured binding (for new variables) auto [ minimum3 , middle3 , maximum3 ] = sort ( 5 , 3 , 8 ); cout << \"Sorting 5, 3, 8: \" << minimum3 << \", \" << middle3 << \", \" << maximum3 << endl ; // Returning three values with tie (for existing variables) tie ( minimum3 , middle3 , maximum3 ) = sort ( 5 , 3 , 8 ); cout << \"Sorting 5, 3, 8: \" << minimum3 << \", \" << middle3 << \", \" << maximum3 << endl ; // Parameter by pointer by value shared_ptr < int > ptr = make_shared < int > ( 5 ); pointer_to_cube ( ptr ); cout << \"5^3 = \" << * ptr << endl ; // Recursive functions cout << \"fibonacci_iterative(6) = \" << fibonacci_iterative ( 6 ) << endl ; cout << \"fibonacci_recursive(6) = \" << fibonacci_recursive ( 6 ) << endl ; return 0 ; } void show_menu () { cout << \"Options: \\n \" \"[0] Exit \\n \" \"[1] Sum \\n \" \"[2] Multiply\" << endl ; } double power_three ( double x ) { return x * x * x ; } double power ( double x , int y ) { double result = 1 ; for ( int i = 0 ; i < y ; ++ i ) { result *= x ; } return result ; } void times_two ( int & x ) { x = 2 * x ; } void maxmin ( int a , int b , int c , int & minimum , int & maximum ) { if ( a > b ) { minimum = b ; maximum = a ; } else { minimum = a ; maximum = b ; } if ( c > maximum ) { maximum = c ; } if ( c < minimum ) { minimum = c ; } } pair < int , int > maxmin ( int a , int b , int c ) { int minimum ; int maximum ; if ( a > b ) { minimum = b ; maximum = a ; } else { minimum = a ; maximum = b ; } if ( c > maximum ) { maximum = c ; } if ( c < minimum ) { minimum = c ; } return make_pair ( minimum , maximum ); } void sort ( int a , int b , int c , int & minimum , int & middle , int & maximum ) { maxmin ( a , b , c , minimum , maximum ); if ( a != minimum && a != maximum ) { middle = a ; return ; } if ( b != minimum && b != maximum ) { middle = b ; return ; } middle = c ; } tuple < int , int , int > sort ( int a , int b , int c ) { auto [ minimum , maximum ] = maxmin ( a , b , c ); if ( a != minimum && a != maximum ) { return make_tuple ( minimum , a , maximum ); } if ( b != minimum && b != maximum ) { return make_tuple ( minimum , b , maximum ); } return make_tuple ( minimum , b , maximum ); } bool has_element ( const array < int , 1000 > & a , int element ) { return std :: any_of ( a . begin (), a . end (), [ element ]( int x ) { return x == element ; }); } void increment_all ( array < int , 1000 > & a , int increment_value ) { for ( int & x : a ) { x += increment_value ; } } // Pass pointers by value: https://youtu.be/xGDLkt-jBJ4?t=869 // As small as the reference and no other level of indirection // NOLINTNEXTLINE(performance-unnecessary-value-param): Does not apply to // pointers void pointer_to_cube ( shared_ptr < int > p ) { if ( p ) { * p = * p * * p * * p ; } } int fibonacci_iterative ( int n ) { if ( n <= 2 ) { return 1 ; } int fn ; int fn_1 = 1 ; int fn_2 = 1 ; for ( int i = 3 ; i <= n ; ++ i ) { fn = fn_1 + fn_2 ; fn_2 = fn_1 ; fn_1 = fn ; } return fn ; } // NOLINTNEXTLINE(misc-no-recursion): making a point here int fibonacci_recursive ( int n ) { if ( n > 2 ) { return fibonacci_recursive ( n - 1 ) + fibonacci_recursive ( n - 2 ); } else { return 1 ; } } Related examples: examples/functions/recursive_bench.cpp","title":"Function"},{"location":"basic-syntax/functions/lambda/","text":"Lambda 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 #include <algorithm> #include <array> #include <functional> #include <iostream> #include <numeric> #include <vector> class add { public : add (){}; double operator ()( double left , double right ) { return left + right ; } }; using namespace std ; int main () { // The old way: Functors // - Function objects overload operator() to hold functions double number = add ()( 2 , 3 ); cout << number << endl ; // The modern way // - Keeping inline lambda functions in variables // - This is a good place to use auto auto function = []() { cout << \"Hello, world! \" ; }; function (); // Using the lambda functions as arguments to other functions // Sort in increasing order vector < int > v { 4 , 3 , 1 , 2 }; auto comparison = []( int a , int b ) { return a < b ; }; sort ( v . begin (), v . end (), comparison ); // Using lambda functions directly // Sort in decreasing order sort ( v . begin (), v . end (), []( int a , int b ) { return a > b ; }); for_each ( v . begin (), v . end (), []( const double c ) { cout << c << \" \" ; }); cout << endl ; // Function type std :: function < int ( int ) > func = []( int i ) { return i + 10 ; }; cout << \"func(6): \" << func ( 6 ) << endl ; // Capturing values in lambda function // - These values are external to the function parameters int x = 10 ; std :: function < int ( int ) > func2 = [ x ]( int i ) { return i + x ; }; cout << \"func2(6): \" << func2 ( 6 ) << endl ; // Automatic parameters auto decreasing_comparison = []( auto a , auto b ) { return b < a ; }; vector < double > v2 = { 3.6 , 3.2 , 7.5 , 2.4 }; sort ( v . begin (), v . end (), decreasing_comparison ); // Binding parameters to the function // - Creates new functions from existing functions auto my_divide = []( double x , double y ) { return x / y ; }; // returns x/y cout << \"my_divide(4,7): \" << my_divide ( 4 , 7 ) << endl ; // Make x and y always 10 and 2 // - Function has no parameters now auto fn_five = bind ( my_divide , 10 , 2 ); cout << \"fn_five(): \" << fn_five () << endl ; // Make y always 2 // - Function has only one parameter now auto fn_half = bind ( my_divide , placeholders :: _1 , 2 ); // returns x/2 cout << \"fn_half(10): \" << fn_half ( 10 ) << endl ; // Keep parameters but convert the return type auto fn_floor = bind < int > ( my_divide , placeholders :: _1 , placeholders :: _2 ); // returns int(x/y) cout << \"fn_floor(10,2): \" << fn_floor ( 13 , 2 ) << endl ; // Sorting with lambdas vector < int > myvector = { 32 , 71 , 12 , 45 , 26 , 80 , 53 , 33 }; sort ( myvector . begin (), myvector . begin () + 4 ); sort ( myvector . begin () + 4 , myvector . end (), []( auto x , auto y ) { return x > y ; }); // Checking condition on all elements // - This algorithm (like some others) only makes sense with lambdas vector < int > foo = { 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 }; if ( all_of ( foo . begin (), foo . end (), []( int i ) { return i % 2 ; })) { cout << \"All the elements are odd numbers. \\n \" ; } // Any of array < int , 7 > foo2 = { 0 , 1 , -1 , 3 , -3 , 5 , -5 }; if ( any_of ( foo2 . begin (), foo2 . end (), []( int i ) { return i < 0 ; })) { cout << \"There are negative elements in the range. \\n \" ; } // None of array < int , 8 > foo3 = { 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 }; if ( none_of ( foo3 . begin (), foo3 . end (), []( int i ) { return i < 0 ; })) { cout << \"There are no negative elements in the range. \\n \" ; } // Find if... vector < int > v3 = { 10 , 25 , 40 , 55 }; auto it = find_if ( v3 . begin (), v3 . end (), []( auto i ) { return i % 2 == 1 ; }); cout << \"The first odd value is \" << * it << '\\n' ; // Removing if... vector < int > v4 { 1 , 2 , 3 , 4 , 5 , 6 , 7 }; auto last = remove_if ( v4 . begin (), v4 . end (), []( int n ) { return n < 6 ; }); v4 . erase ( last , v4 . end ()); for_each ( v4 . begin (), v4 . end (), []( const double c ) { cout << c << \" \" ; }); cout << endl ; x = 5 ; v4 . erase ( remove_if ( v4 . begin (), v4 . end (), [ x ]( int n ) { return n < x ; }), v4 . end ()); for_each ( v4 . begin (), v4 . end (), []( const double c ) { cout << c << \" \" ; }); cout << endl ; // Counting if... vector < int > v5 ( 9 ); iota ( v5 . begin (), v5 . end (), 1 ); int mycount = count_if ( v5 . begin (), v5 . end (), []( int i ) { return (( i % 2 ) == 1 ); }); cout << \"My vector contains \" << mycount << \" odd values. \\n \" ; // Replacing if... vector < int > v6 ( 9 ); iota ( v6 . begin (), v6 . end (), 1 ); replace_if ( v6 . begin (), v6 . end (), []( int i ) { return (( i % 2 ) == 1 ); }, 0 ); cout << \"v6 contains:\" ; for ( vector < int >:: iterator it = v6 . begin (); it != v6 . end (); ++ it ) { cout << ' ' << * it ; } cout << '\\n' ; return 0 ; }","title":"Lambda"},{"location":"basic-syntax/functions/lambda/#lambda","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 #include <algorithm> #include <array> #include <functional> #include <iostream> #include <numeric> #include <vector> class add { public : add (){}; double operator ()( double left , double right ) { return left + right ; } }; using namespace std ; int main () { // The old way: Functors // - Function objects overload operator() to hold functions double number = add ()( 2 , 3 ); cout << number << endl ; // The modern way // - Keeping inline lambda functions in variables // - This is a good place to use auto auto function = []() { cout << \"Hello, world! \" ; }; function (); // Using the lambda functions as arguments to other functions // Sort in increasing order vector < int > v { 4 , 3 , 1 , 2 }; auto comparison = []( int a , int b ) { return a < b ; }; sort ( v . begin (), v . end (), comparison ); // Using lambda functions directly // Sort in decreasing order sort ( v . begin (), v . end (), []( int a , int b ) { return a > b ; }); for_each ( v . begin (), v . end (), []( const double c ) { cout << c << \" \" ; }); cout << endl ; // Function type std :: function < int ( int ) > func = []( int i ) { return i + 10 ; }; cout << \"func(6): \" << func ( 6 ) << endl ; // Capturing values in lambda function // - These values are external to the function parameters int x = 10 ; std :: function < int ( int ) > func2 = [ x ]( int i ) { return i + x ; }; cout << \"func2(6): \" << func2 ( 6 ) << endl ; // Automatic parameters auto decreasing_comparison = []( auto a , auto b ) { return b < a ; }; vector < double > v2 = { 3.6 , 3.2 , 7.5 , 2.4 }; sort ( v . begin (), v . end (), decreasing_comparison ); // Binding parameters to the function // - Creates new functions from existing functions auto my_divide = []( double x , double y ) { return x / y ; }; // returns x/y cout << \"my_divide(4,7): \" << my_divide ( 4 , 7 ) << endl ; // Make x and y always 10 and 2 // - Function has no parameters now auto fn_five = bind ( my_divide , 10 , 2 ); cout << \"fn_five(): \" << fn_five () << endl ; // Make y always 2 // - Function has only one parameter now auto fn_half = bind ( my_divide , placeholders :: _1 , 2 ); // returns x/2 cout << \"fn_half(10): \" << fn_half ( 10 ) << endl ; // Keep parameters but convert the return type auto fn_floor = bind < int > ( my_divide , placeholders :: _1 , placeholders :: _2 ); // returns int(x/y) cout << \"fn_floor(10,2): \" << fn_floor ( 13 , 2 ) << endl ; // Sorting with lambdas vector < int > myvector = { 32 , 71 , 12 , 45 , 26 , 80 , 53 , 33 }; sort ( myvector . begin (), myvector . begin () + 4 ); sort ( myvector . begin () + 4 , myvector . end (), []( auto x , auto y ) { return x > y ; }); // Checking condition on all elements // - This algorithm (like some others) only makes sense with lambdas vector < int > foo = { 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 }; if ( all_of ( foo . begin (), foo . end (), []( int i ) { return i % 2 ; })) { cout << \"All the elements are odd numbers. \\n \" ; } // Any of array < int , 7 > foo2 = { 0 , 1 , -1 , 3 , -3 , 5 , -5 }; if ( any_of ( foo2 . begin (), foo2 . end (), []( int i ) { return i < 0 ; })) { cout << \"There are negative elements in the range. \\n \" ; } // None of array < int , 8 > foo3 = { 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 }; if ( none_of ( foo3 . begin (), foo3 . end (), []( int i ) { return i < 0 ; })) { cout << \"There are no negative elements in the range. \\n \" ; } // Find if... vector < int > v3 = { 10 , 25 , 40 , 55 }; auto it = find_if ( v3 . begin (), v3 . end (), []( auto i ) { return i % 2 == 1 ; }); cout << \"The first odd value is \" << * it << '\\n' ; // Removing if... vector < int > v4 { 1 , 2 , 3 , 4 , 5 , 6 , 7 }; auto last = remove_if ( v4 . begin (), v4 . end (), []( int n ) { return n < 6 ; }); v4 . erase ( last , v4 . end ()); for_each ( v4 . begin (), v4 . end (), []( const double c ) { cout << c << \" \" ; }); cout << endl ; x = 5 ; v4 . erase ( remove_if ( v4 . begin (), v4 . end (), [ x ]( int n ) { return n < x ; }), v4 . end ()); for_each ( v4 . begin (), v4 . end (), []( const double c ) { cout << c << \" \" ; }); cout << endl ; // Counting if... vector < int > v5 ( 9 ); iota ( v5 . begin (), v5 . end (), 1 ); int mycount = count_if ( v5 . begin (), v5 . end (), []( int i ) { return (( i % 2 ) == 1 ); }); cout << \"My vector contains \" << mycount << \" odd values. \\n \" ; // Replacing if... vector < int > v6 ( 9 ); iota ( v6 . begin (), v6 . end (), 1 ); replace_if ( v6 . begin (), v6 . end (), []( int i ) { return (( i % 2 ) == 1 ); }, 0 ); cout << \"v6 contains:\" ; for ( vector < int >:: iterator it = v6 . begin (); it != v6 . end (); ++ it ) { cout << ' ' << * it ; } cout << '\\n' ; return 0 ; }","title":"Lambda"},{"location":"basic-syntax/input--output/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 add_executable ( hello_world hello_world.cpp ) add_executable ( cin cin.cpp ) add_executable ( printing printing.cpp ) FetchContent_Declare ( fmt GIT_REPOSITORY https://github.com/fmtlib/fmt.git GIT_TAG 6.1.2 ) FetchContent_MakeAvailable ( fmt ) add_executable ( format format.cpp ) target_link_libraries ( format fmt ) FetchContent_Declare ( tabulate GIT_REPOSITORY https://github.com/p-ranav/tabulate.git GIT_TAG v1.4 ) FetchContent_MakeAvailable ( tabulate ) add_executable ( tabulate_snippets tabulate.cpp ) target_link_libraries ( tabulate_snippets PRIVATE tabulate )","title":"Build script"},{"location":"basic-syntax/input--output/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 add_executable ( hello_world hello_world.cpp ) add_executable ( cin cin.cpp ) add_executable ( printing printing.cpp ) FetchContent_Declare ( fmt GIT_REPOSITORY https://github.com/fmtlib/fmt.git GIT_TAG 6.1.2 ) FetchContent_MakeAvailable ( fmt ) add_executable ( format format.cpp ) target_link_libraries ( format fmt ) FetchContent_Declare ( tabulate GIT_REPOSITORY https://github.com/p-ranav/tabulate.git GIT_TAG v1.4 ) FetchContent_MakeAvailable ( tabulate ) add_executable ( tabulate_snippets tabulate.cpp ) target_link_libraries ( tabulate_snippets PRIVATE tabulate )","title":"Build script"},{"location":"basic-syntax/input--output/format/","text":"Format 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include <chrono> #include <string> #include <tuple> #include <vector> #include <fmt/chrono.h> #include <fmt/color.h> #include <fmt/format.h> #include <fmt/ostream.h> #include <fmt/ranges.h> int main () { /* * About fmt/format: * - fmt/format has been accepted into C++20 * - It has the best of printf and cout * - Many compilers don't implement it yet * - We still depend on <fmt/format.h> */ using namespace std ; using namespace fmt ; using namespace std :: literals :: chrono_literals ; // Simple print print ( \"Hello, world! \\n \" ); // Format to string string s = format ( \"The answer is {}. \\n \" , 42 ); print ( s ); // Format with order s = format ( \"I'd rather be {1} than {0}. \\n \" , \"right\" , \"happy\" ); print ( s ); // Chrono literals print ( \"Default format: {} {} \\n \" , 42 s , 100 ms ); print ( \"strftime-like format: {:%H:%M:%S} \\n \" , 3 h + 15 min + 30 s ); time_t t = time ( nullptr ); print ( \"The date is {:%Y-%m-%d}.\" , localtime ( t )); // Format ranges vector < int > v = { 1 , 2 , 3 }; print ( \"{} \\n \" , v ); tuple < char , int , float > t2 { 'a' , 1 , 2.0f }; print ( \"{}\" , t2 ); // Color support print ( fg ( color :: crimson ) | emphasis :: bold , \"Hello, {}! \\n \" , \"world\" ); print ( fg ( color :: floral_white ) | bg ( color :: slate_gray ) | emphasis :: underline , \"Hello, {}! \\n \" , \"\u043c\u0438\u0440\" ); print ( fg ( color :: steel_blue ) | emphasis :: italic , \"Hello, {}! \\n \" , \"\u4e16\u754c\" ); // Format to memory memory_buffer out ; format_to ( out , \"For a moment, {} happened.\" , \"nothing\" ); print ( out . data ()); }","title":"Format"},{"location":"basic-syntax/input--output/format/#format","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include <chrono> #include <string> #include <tuple> #include <vector> #include <fmt/chrono.h> #include <fmt/color.h> #include <fmt/format.h> #include <fmt/ostream.h> #include <fmt/ranges.h> int main () { /* * About fmt/format: * - fmt/format has been accepted into C++20 * - It has the best of printf and cout * - Many compilers don't implement it yet * - We still depend on <fmt/format.h> */ using namespace std ; using namespace fmt ; using namespace std :: literals :: chrono_literals ; // Simple print print ( \"Hello, world! \\n \" ); // Format to string string s = format ( \"The answer is {}. \\n \" , 42 ); print ( s ); // Format with order s = format ( \"I'd rather be {1} than {0}. \\n \" , \"right\" , \"happy\" ); print ( s ); // Chrono literals print ( \"Default format: {} {} \\n \" , 42 s , 100 ms ); print ( \"strftime-like format: {:%H:%M:%S} \\n \" , 3 h + 15 min + 30 s ); time_t t = time ( nullptr ); print ( \"The date is {:%Y-%m-%d}.\" , localtime ( t )); // Format ranges vector < int > v = { 1 , 2 , 3 }; print ( \"{} \\n \" , v ); tuple < char , int , float > t2 { 'a' , 1 , 2.0f }; print ( \"{}\" , t2 ); // Color support print ( fg ( color :: crimson ) | emphasis :: bold , \"Hello, {}! \\n \" , \"world\" ); print ( fg ( color :: floral_white ) | bg ( color :: slate_gray ) | emphasis :: underline , \"Hello, {}! \\n \" , \"\u043c\u0438\u0440\" ); print ( fg ( color :: steel_blue ) | emphasis :: italic , \"Hello, {}! \\n \" , \"\u4e16\u754c\" ); // Format to memory memory_buffer out ; format_to ( out , \"For a moment, {} happened.\" , \"nothing\" ); print ( out . data ()); }","title":"Format"},{"location":"basic-syntax/input--output/hello-world/","text":"Hello World 1 2 3 4 5 6 #include <iostream> int main () { std :: cout << \"Hello world\" << std :: endl ; return 0 ; }","title":"Hello World"},{"location":"basic-syntax/input--output/hello-world/#hello-world","text":"1 2 3 4 5 6 #include <iostream> int main () { std :: cout << \"Hello world\" << std :: endl ; return 0 ; }","title":"Hello World"},{"location":"basic-syntax/input--output/input/","text":"Input 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include <cmath> #include <iostream> using namespace std ; int main () { // User input int age ; std :: cout << \"How old are you? \" ; std :: cin >> age ; if ( age >= 18 ) { std :: cout << \"Welcome! \\n \" ; } else { std :: cout << \"Sorry. \\n \" ; return 1 ; } // User input (Handling error) std :: cout << \"How old are you again? \" ; if ( ! ( std :: cin >> age )) { std :: cout << \"There is an error in your input \\n \" ; return 1 ; } if ( age >= 18 ) { std :: cout << \"Welcome! \\n \" ; } else { std :: cout << \"Sorry. \\n \" ; return 1 ; } return 0 ; }","title":"Input"},{"location":"basic-syntax/input--output/input/#input","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include <cmath> #include <iostream> using namespace std ; int main () { // User input int age ; std :: cout << \"How old are you? \" ; std :: cin >> age ; if ( age >= 18 ) { std :: cout << \"Welcome! \\n \" ; } else { std :: cout << \"Sorry. \\n \" ; return 1 ; } // User input (Handling error) std :: cout << \"How old are you again? \" ; if ( ! ( std :: cin >> age )) { std :: cout << \"There is an error in your input \\n \" ; return 1 ; } if ( age >= 18 ) { std :: cout << \"Welcome! \\n \" ; } else { std :: cout << \"Sorry. \\n \" ; return 1 ; } return 0 ; }","title":"Input"},{"location":"basic-syntax/input--output/output/","text":"Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <iostream> using namespace std ; int main () { int age ; std :: cout << \"How old are you? \" ; std :: cin >> age ; if ( age >= 18 ) { // The \"old\" way printf ( \"Welcome! You are %d years old.\" , age ); // The C++ way std :: cout << \"Welcome! You are \" << age << \" years old.\" << '\\n' ; // The C++ way (flushing output) std :: cout << \"Welcome! You are \" << age << \" years old.\" << std :: endl ; // See the format example for another way // std::cout << std::format(...); } else { // The \"old\" way printf ( \"Sorry.\" ); // The C++ way std :: cout << \"Sorry.\" << '\\n' ; // The C++ way (flushing output) std :: cout << \"Sorry.\" << std :: endl ; // See the format example for another way // std::cout << std::format(...); } return 0 ; } Related examples: examples/datetime/flushtime.cpp","title":"Output"},{"location":"basic-syntax/input--output/output/#output","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <iostream> using namespace std ; int main () { int age ; std :: cout << \"How old are you? \" ; std :: cin >> age ; if ( age >= 18 ) { // The \"old\" way printf ( \"Welcome! You are %d years old.\" , age ); // The C++ way std :: cout << \"Welcome! You are \" << age << \" years old.\" << '\\n' ; // The C++ way (flushing output) std :: cout << \"Welcome! You are \" << age << \" years old.\" << std :: endl ; // See the format example for another way // std::cout << std::format(...); } else { // The \"old\" way printf ( \"Sorry.\" ); // The C++ way std :: cout << \"Sorry.\" << '\\n' ; // The C++ way (flushing output) std :: cout << \"Sorry.\" << std :: endl ; // See the format example for another way // std::cout << std::format(...); } return 0 ; } Related examples: examples/datetime/flushtime.cpp","title":"Output"},{"location":"basic-syntax/input--output/tabulate/","text":"Tabulate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include <iostream> #include <tabulate/table.hpp> int main () { using namespace std ; using namespace tabulate ; // Create table Table universal_constants ; // Add rows universal_constants . add_row ({ \"Quantity\" , \"Value\" }); universal_constants . add_row ( { \"Characteristic impedance of vacuum\" , \"376.730 313 461... \u03a9\" }); universal_constants . add_row ( { \"Electric constant (permittivity of free space)\" , \"8.854 187 817... \u00d7 10\u207b\u00b9\u00b2F\u00b7m\u207b\u00b9\" }); universal_constants . add_row ( { \"Magnetic constant (permeability of free space)\" , \"4\u03c0 \u00d7 10\u207b\u2077 N\u00b7A\u207b\u00b2 = 1.2566 370 614... \u00d7 10\u207b\u2076 N\u00b7A\u207b\u00b2\" }); universal_constants . add_row ( { \"Gravitational constant (Newtonian constant of gravitation)\" , \"6.6742(10) \u00d7 10\u207b\u00b9\u00b9m\u00b3\u00b7kg\u207b\u00b9\u00b7s\u207b\u00b2\" }); universal_constants . add_row ( { \"Planck's constant\" , \"6.626 0693(11) \u00d7 10\u207b\u00b3\u2074 J\u00b7s\" }); universal_constants . add_row ( { \"Dirac's constant\" , \"1.054 571 68(18) \u00d7 10\u207b\u00b3\u2074 J\u00b7s\" }); universal_constants . add_row ( { \"Speed of light in vacuum\" , \"299 792 458 m\u00b7s\u207b\u00b9\" }); // Format table universal_constants . format () . font_style ({ FontStyle :: bold }) . border_top ( \"-\" ) . border_bottom ( \"-\" ) . border_left ( \" \" ) . border_right ( \" \" ) . corner ( \"-\" ); // Format rows universal_constants [ 0 ] . format () . padding_top ( 1 ) . padding_bottom ( 1 ) . font_align ( FontAlign :: center ) . font_style ({ FontStyle :: underline }) . font_background_color ( Color :: red ); // Format columns universal_constants . column ( 1 ). format (). font_color ( Color :: yellow ); // Format cells universal_constants [ 0 ][ 1 ] . format () . font_background_color ( Color :: blue ) . font_color ( Color :: white ); // Print table std :: cout << universal_constants << std :: endl ; return 0 ; }","title":"Tabulate"},{"location":"basic-syntax/input--output/tabulate/#tabulate","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include <iostream> #include <tabulate/table.hpp> int main () { using namespace std ; using namespace tabulate ; // Create table Table universal_constants ; // Add rows universal_constants . add_row ({ \"Quantity\" , \"Value\" }); universal_constants . add_row ( { \"Characteristic impedance of vacuum\" , \"376.730 313 461... \u03a9\" }); universal_constants . add_row ( { \"Electric constant (permittivity of free space)\" , \"8.854 187 817... \u00d7 10\u207b\u00b9\u00b2F\u00b7m\u207b\u00b9\" }); universal_constants . add_row ( { \"Magnetic constant (permeability of free space)\" , \"4\u03c0 \u00d7 10\u207b\u2077 N\u00b7A\u207b\u00b2 = 1.2566 370 614... \u00d7 10\u207b\u2076 N\u00b7A\u207b\u00b2\" }); universal_constants . add_row ( { \"Gravitational constant (Newtonian constant of gravitation)\" , \"6.6742(10) \u00d7 10\u207b\u00b9\u00b9m\u00b3\u00b7kg\u207b\u00b9\u00b7s\u207b\u00b2\" }); universal_constants . add_row ( { \"Planck's constant\" , \"6.626 0693(11) \u00d7 10\u207b\u00b3\u2074 J\u00b7s\" }); universal_constants . add_row ( { \"Dirac's constant\" , \"1.054 571 68(18) \u00d7 10\u207b\u00b3\u2074 J\u00b7s\" }); universal_constants . add_row ( { \"Speed of light in vacuum\" , \"299 792 458 m\u00b7s\u207b\u00b9\" }); // Format table universal_constants . format () . font_style ({ FontStyle :: bold }) . border_top ( \"-\" ) . border_bottom ( \"-\" ) . border_left ( \" \" ) . border_right ( \" \" ) . corner ( \"-\" ); // Format rows universal_constants [ 0 ] . format () . padding_top ( 1 ) . padding_bottom ( 1 ) . font_align ( FontAlign :: center ) . font_style ({ FontStyle :: underline }) . font_background_color ( Color :: red ); // Format columns universal_constants . column ( 1 ). format (). font_color ( Color :: yellow ); // Format cells universal_constants [ 0 ][ 1 ] . format () . font_background_color ( Color :: blue ) . font_color ( Color :: white ); // Print table std :: cout << universal_constants << std :: endl ; return 0 ; }","title":"Tabulate"},{"location":"basic-syntax/pointers/build-script/","text":"Build script 1 2 3 add_executable ( raw_pointers raw_pointers.cpp ) add_executable ( smart_pointers smart_pointers.cpp )","title":"Build script"},{"location":"basic-syntax/pointers/build-script/#build-script","text":"1 2 3 add_executable ( raw_pointers raw_pointers.cpp ) add_executable ( smart_pointers smart_pointers.cpp )","title":"Build script"},{"location":"basic-syntax/pointers/raw-pointers/","text":"Raw Pointers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #include <array> #include <iostream> #include <memory> #include <random> #include <string> using namespace std ; int main () { // Raw pointers are dangerous // Try to avoid them (few exceptions) // Pointer to an int int * x = new int ( 5 ); std :: cout << \"x: \" << x << std :: endl ; if ( x ) { std :: cout << \"*x: \" << * x << std :: endl ; } else { std :: cout << \"*x: empty\" << std :: endl ; } // Delete x // - Forgetting to delete causes memory leaks // - Smart pointers delete the data automatically delete x ; // Update to nullptr // - Nullptr indicates the pointer is free // - It means the pointer points to no one // - Forgetting to update to nullptr might lead to segmentation faults // - Smart pointers do that automatically x = nullptr ; // Testing pointer again std :: cout << \"x: \" << x << std :: endl ; if ( x ) { std :: cout << \"*x: \" << * x << std :: endl ; } else { std :: cout << \"*x: empty\" << std :: endl ; } // Pointers to dynamic arrays // Very dangerous if you forget to deallocate int i = 0 ; while ( i < 1000000 ) { // Point to a new value x = new int ( i ); // Deallocate the value pointed by x // - Forget to do that and we'll have a big problem! delete x ; x = nullptr ; ++ i ; } // Another danger: pointer arithmetic // We might access invalid addresses x = new int ( i ); int * tmp = x ; for ( int i = 0 ; i < 30 ; ++ i ) { // Go to new address // - But what's in there? std :: cout << \"x++: \" << x ++ << std :: endl ; } // This would cause an error now: // delete x; // Use tmp, which is fortunately pointing to the address we need to delete delete tmp ; delete x ; // Raw dynamic arrays // - This is what existed before vectors // - Point to a sequence of values // - Always use vectors instead of this // - If you need to access the raw data, use vector::data() int * x2 = new int [ 10 ]; for ( int i2 = 0 ; i2 < 10 ; ++ i2 ) { x2 [ i2 ] = 10 + i2 * 10 ; } std :: cout << \"x2: \" << x2 << std :: endl ; std :: cout << \"&x2[0]: \" << & x2 [ 0 ] << std :: endl ; std :: cout << \"x2[0]: \" << x2 [ 0 ] << std :: endl ; // x2 is pointing to the first number in the sequence std :: cout << \"*x2: \" << * x2 << std :: endl ; std :: cout << \"x2[3]: \" << x2 [ 3 ] << std :: endl ; std :: cout << \"*(x2+3): \" << * ( x2 + 3 ) << std :: endl ; // Deallocate sequence // - Different command - more danger delete [] x2 ; return 0 ; }","title":"Raw Pointers"},{"location":"basic-syntax/pointers/raw-pointers/#raw-pointers","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #include <array> #include <iostream> #include <memory> #include <random> #include <string> using namespace std ; int main () { // Raw pointers are dangerous // Try to avoid them (few exceptions) // Pointer to an int int * x = new int ( 5 ); std :: cout << \"x: \" << x << std :: endl ; if ( x ) { std :: cout << \"*x: \" << * x << std :: endl ; } else { std :: cout << \"*x: empty\" << std :: endl ; } // Delete x // - Forgetting to delete causes memory leaks // - Smart pointers delete the data automatically delete x ; // Update to nullptr // - Nullptr indicates the pointer is free // - It means the pointer points to no one // - Forgetting to update to nullptr might lead to segmentation faults // - Smart pointers do that automatically x = nullptr ; // Testing pointer again std :: cout << \"x: \" << x << std :: endl ; if ( x ) { std :: cout << \"*x: \" << * x << std :: endl ; } else { std :: cout << \"*x: empty\" << std :: endl ; } // Pointers to dynamic arrays // Very dangerous if you forget to deallocate int i = 0 ; while ( i < 1000000 ) { // Point to a new value x = new int ( i ); // Deallocate the value pointed by x // - Forget to do that and we'll have a big problem! delete x ; x = nullptr ; ++ i ; } // Another danger: pointer arithmetic // We might access invalid addresses x = new int ( i ); int * tmp = x ; for ( int i = 0 ; i < 30 ; ++ i ) { // Go to new address // - But what's in there? std :: cout << \"x++: \" << x ++ << std :: endl ; } // This would cause an error now: // delete x; // Use tmp, which is fortunately pointing to the address we need to delete delete tmp ; delete x ; // Raw dynamic arrays // - This is what existed before vectors // - Point to a sequence of values // - Always use vectors instead of this // - If you need to access the raw data, use vector::data() int * x2 = new int [ 10 ]; for ( int i2 = 0 ; i2 < 10 ; ++ i2 ) { x2 [ i2 ] = 10 + i2 * 10 ; } std :: cout << \"x2: \" << x2 << std :: endl ; std :: cout << \"&x2[0]: \" << & x2 [ 0 ] << std :: endl ; std :: cout << \"x2[0]: \" << x2 [ 0 ] << std :: endl ; // x2 is pointing to the first number in the sequence std :: cout << \"*x2: \" << * x2 << std :: endl ; std :: cout << \"x2[3]: \" << x2 [ 3 ] << std :: endl ; std :: cout << \"*(x2+3): \" << * ( x2 + 3 ) << std :: endl ; // Deallocate sequence // - Different command - more danger delete [] x2 ; return 0 ; }","title":"Raw Pointers"},{"location":"basic-syntax/pointers/smart-pointers/","text":"Smart pointers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 #include <iostream> #include <memory> using namespace std ; int main () { // Use smart pointers instead of raw pointer whenever possible // - But you can't do it without understanding raw pointers // - Recur to raw *non-owning* pointers if they are needed // In general, use: // 1) No pointers // 2) Raw non-owning pointers if they are needed // 3) Smart pointers IF owning pointers can not be averted // 4) Owning raw pointers if you know exactly what you are doing // and need them (e.g. interfacing with C code). // Only one unique pointer can point to an address std :: unique_ptr < int > c ; if ( c ) { std :: cout << \"*c : \" << * c << std :: endl ; } else { std :: cout << \"c is empty\" << std :: endl ; } // Changing value c = std :: make_unique < int > ( 2 ); if ( c ) { std :: cout << \"*c : \" << * c << std :: endl ; } else { std :: cout << \"c is empty\" << std :: endl ; } // Invalid: // c = new int(2); // Another unique pointer std :: unique_ptr < int > c2 ( new int ( 3 )); // Invalid: // c = c2; doesn't work // Swapping values is valid c . swap ( c2 ); // Moving values is valid c = std :: move ( c2 ); if ( c ) { std :: cout << \"New *c : \" << * c << std :: endl ; } else { std :: cout << \"c is empty\" << std :: endl ; } if ( c2 ) { std :: cout << \"New *c2 : \" << * c << std :: endl ; } else { std :: cout << \"c2 is empty\" << std :: endl ; } // Shared pointers // - More than one pointer can point to the same address // - Deletes data automatically when the last pointer is over // - More expensive than unique pointers std :: shared_ptr < int > sp ( new int ( 2 )); if ( sp ) { std :: cout << \"New *sp : \" << * sp << std :: endl ; } else { std :: cout << \"sp is empty\" << std :: endl ; } // Another pointer // This is valid now: std :: shared_ptr < int > sp2 = sp ; * sp2 = 3 ; if ( sp ) { cout << \"New *sp : \" << * sp << endl ; } else { cout << \"sp is empty\" << endl ; } if ( sp2 ) { cout << \"New *sp2 : \" << * sp << endl ; } else { cout << \"sp2 is empty\" << endl ; } // How many pointers are pointing to this number 3? std :: cout << \"There are \" << sp . use_count () << \" pointers to \" << sp . get () << std :: endl ; return 0 ; }","title":"Smart pointers"},{"location":"basic-syntax/pointers/smart-pointers/#smart-pointers","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 #include <iostream> #include <memory> using namespace std ; int main () { // Use smart pointers instead of raw pointer whenever possible // - But you can't do it without understanding raw pointers // - Recur to raw *non-owning* pointers if they are needed // In general, use: // 1) No pointers // 2) Raw non-owning pointers if they are needed // 3) Smart pointers IF owning pointers can not be averted // 4) Owning raw pointers if you know exactly what you are doing // and need them (e.g. interfacing with C code). // Only one unique pointer can point to an address std :: unique_ptr < int > c ; if ( c ) { std :: cout << \"*c : \" << * c << std :: endl ; } else { std :: cout << \"c is empty\" << std :: endl ; } // Changing value c = std :: make_unique < int > ( 2 ); if ( c ) { std :: cout << \"*c : \" << * c << std :: endl ; } else { std :: cout << \"c is empty\" << std :: endl ; } // Invalid: // c = new int(2); // Another unique pointer std :: unique_ptr < int > c2 ( new int ( 3 )); // Invalid: // c = c2; doesn't work // Swapping values is valid c . swap ( c2 ); // Moving values is valid c = std :: move ( c2 ); if ( c ) { std :: cout << \"New *c : \" << * c << std :: endl ; } else { std :: cout << \"c is empty\" << std :: endl ; } if ( c2 ) { std :: cout << \"New *c2 : \" << * c << std :: endl ; } else { std :: cout << \"c2 is empty\" << std :: endl ; } // Shared pointers // - More than one pointer can point to the same address // - Deletes data automatically when the last pointer is over // - More expensive than unique pointers std :: shared_ptr < int > sp ( new int ( 2 )); if ( sp ) { std :: cout << \"New *sp : \" << * sp << std :: endl ; } else { std :: cout << \"sp is empty\" << std :: endl ; } // Another pointer // This is valid now: std :: shared_ptr < int > sp2 = sp ; * sp2 = 3 ; if ( sp ) { cout << \"New *sp : \" << * sp << endl ; } else { cout << \"sp is empty\" << endl ; } if ( sp2 ) { cout << \"New *sp2 : \" << * sp << endl ; } else { cout << \"sp2 is empty\" << endl ; } // How many pointers are pointing to this number 3? std :: cout << \"There are \" << sp . use_count () << \" pointers to \" << sp . get () << std :: endl ; return 0 ; }","title":"Smart pointers"},{"location":"guis/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 add_subdirectory ( qt ) add_subdirectory ( webview ) add_subdirectory ( opengl ) add_subdirectory ( imgui ) add_subdirectory ( tray )","title":"Build script"},{"location":"guis/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 add_subdirectory ( qt ) add_subdirectory ( webview ) add_subdirectory ( opengl ) add_subdirectory ( imgui ) add_subdirectory ( tray )","title":"Build script"},{"location":"guis/imgui/","text":"IMGUI 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 // dear imgui: standalone example application for GLFW + OpenGL 3, using // programmable pipeline If you are new to dear imgui, see examples/README.txt // and documentation at the top of imgui.cpp. (GLFW is a cross-platform general // purpose library for handling windows, inputs, OpenGL/Vulkan/Metal graphics // context creation, etc.) #include \"examples/imgui_impl_glfw.h\" #include \"examples/imgui_impl_opengl3.h\" #include \"imgui.h\" #include <stdio.h> // About Desktop OpenGL function loaders: // Modern desktop OpenGL doesn't have a standard portable header file to load // OpenGL function pointers. Helper libraries are often used for this purpose! // Here we are supporting a few common ones (gl3w, glew, glad). You may use // another loader/header of your choice (glext, glLoadGen, etc.), or chose to // manually implement your own. #if defined(IMGUI_IMPL_OPENGL_LOADER_GL3W) #include <GL/gl3w.h> // Initialize with gl3wInit() #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLEW) #include <GL/glew.h> // Initialize with glewInit() #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD) #include <glad/glad.h> // Initialize with gladLoadGL() #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING2) #define GLFW_INCLUDE_NONE // GLFW including OpenGL headers causes ambiguity or // multiple definition errors. #include <glbinding/Binding.h> // Initialize with glbinding::Binding::initialize() #include <glbinding/gl/gl.h> using namespace gl ; #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING3) #define GLFW_INCLUDE_NONE // GLFW including OpenGL headers causes ambiguity or // multiple definition errors. #include <glbinding/gl/gl.h> #include <glbinding/glbinding.h> // Initialize with glbinding::initialize() using namespace gl ; #else #include IMGUI_IMPL_OPENGL_LOADER_CUSTOM #endif // Include glfw3.h after our OpenGL definitions #include <GLFW/glfw3.h> // [Win32] Our example includes a copy of glfw3.lib pre-compiled with VS2010 to // maximize ease of testing and compatibility with old VS compilers. To link // with VS2010-era libraries, VS2015+ requires linking with // legacy_stdio_definitions.lib, which we do using this pragma. Your own project // should not be affected, as you are likely to link with a newer binary of GLFW // that is adequate for your version of Visual Studio. #if defined(_MSC_VER) && (_MSC_VER >= 1900) && \\ !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) #pragma comment(lib, \"legacy_stdio_definitions\") #endif static void glfw_error_callback ( int error , const char * description ) { fprintf ( stderr , \"Glfw Error %d: %s \\n \" , error , description ); } int main ( int , char ** ) { // Setup window glfwSetErrorCallback ( glfw_error_callback ); if ( ! glfwInit ()) return 1 ; // Decide GL+GLSL versions #if __APPLE__ // GL 3.2 + GLSL 150 const char * glsl_version = \"#version 150\" ; glfwWindowHint ( GLFW_CONTEXT_VERSION_MAJOR , 3 ); glfwWindowHint ( GLFW_CONTEXT_VERSION_MINOR , 2 ); glfwWindowHint ( GLFW_OPENGL_PROFILE , GLFW_OPENGL_CORE_PROFILE ); // 3.2+ only glfwWindowHint ( GLFW_OPENGL_FORWARD_COMPAT , GL_TRUE ); // Required on Mac #else // GL 3.0 + GLSL 130 const char * glsl_version = \"#version 130\" ; glfwWindowHint ( GLFW_CONTEXT_VERSION_MAJOR , 3 ); glfwWindowHint ( GLFW_CONTEXT_VERSION_MINOR , 0 ); // glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 3.2+ // only glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // 3.0+ only #endif // Create window with graphics context GLFWwindow * window = glfwCreateWindow ( 1280 , 720 , \"Dear ImGui GLFW+OpenGL3 example\" , NULL , NULL ); if ( window == NULL ) return 1 ; glfwMakeContextCurrent ( window ); glfwSwapInterval ( 1 ); // Enable vsync // Initialize OpenGL loader #if defined(IMGUI_IMPL_OPENGL_LOADER_GL3W) bool err = gl3wInit () != 0 ; #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLEW) bool err = glewInit () != GLEW_OK ; #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD) bool err = gladLoadGL () == 0 ; #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING2) bool err = false ; glbinding :: Binding :: initialize (); #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING3) bool err = false ; glbinding :: initialize ([]( const char * name ) { return ( glbinding :: ProcAddress ) glfwGetProcAddress ( name ); }); #else bool err = false ; // If you use IMGUI_IMPL_OPENGL_LOADER_CUSTOM, your loader // is likely to requires some form of initialization. #endif if ( err ) { fprintf ( stderr , \"Failed to initialize OpenGL loader! \\n \" ); return 1 ; } // Setup Dear ImGui context IMGUI_CHECKVERSION (); ImGui :: CreateContext (); ImGuiIO & io = ImGui :: GetIO (); ( void ) io ; // io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable // Keyboard Controls io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad; // // Enable Gamepad Controls // Setup Dear ImGui style ImGui :: StyleColorsDark (); // ImGui::StyleColorsClassic(); // Setup Platform/Renderer bindings ImGui_ImplGlfw_InitForOpenGL ( window , true ); ImGui_ImplOpenGL3_Init ( glsl_version ); // Load Fonts // - If no fonts are loaded, dear imgui will use the default font. You can // also load multiple fonts and use ImGui::PushFont()/PopFont() to select // them. // - AddFontFromFileTTF() will return the ImFont* so you can store it if you // need to select the font among multiple. // - If the file cannot be loaded, the function will return NULL. Please // handle those errors in your application (e.g. use an assertion, or // display an error and quit). // - The fonts will be rasterized at a given size (w/ oversampling) and // stored into a texture when calling // ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame // below will call. // - Read 'docs/FONTS.txt' for more instructions and details. // - Remember that in C/C++ if you want to include a backslash \\ in a string // literal you need to write a double backslash \\\\ ! // io.Fonts->AddFontDefault(); // io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Roboto-Medium.ttf\", 16.0f); // io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Cousine-Regular.ttf\", 15.0f); // io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/DroidSans.ttf\", 16.0f); // io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/ProggyTiny.ttf\", 10.0f); // ImFont* font = // io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\ArialUni.ttf\", 18.0f, // NULL, io.Fonts->GetGlyphRangesJapanese()); IM_ASSERT(font != NULL); // Our state bool show_demo_window = true ; bool show_another_window = false ; ImVec4 clear_color = ImVec4 ( 0.45f , 0.55f , 0.60f , 1.00f ); // Main loop while ( ! glfwWindowShouldClose ( window )) { // Poll and handle events (inputs, window resize, etc.) // You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to // tell if dear imgui wants to use your inputs. // - When io.WantCaptureMouse is true, do not dispatch mouse input data // to your main application. // - When io.WantCaptureKeyboard is true, do not dispatch keyboard input // data to your main application. Generally you may always pass all // inputs to dear imgui, and hide them from your application based on // those two flags. glfwPollEvents (); // Start the Dear ImGui frame ImGui_ImplOpenGL3_NewFrame (); ImGui_ImplGlfw_NewFrame (); ImGui :: NewFrame (); // 1. Show the big demo window (Most of the sample code is in // ImGui::ShowDemoWindow()! You can browse its code to learn more about // Dear ImGui!). if ( show_demo_window ) ImGui :: ShowDemoWindow ( & show_demo_window ); // 2. Show a simple window that we create ourselves. We use a Begin/End // pair to created a named window. { static float f = 0.0f ; static int counter = 0 ; ImGui :: Begin ( \"Hello, world!\" ); // Create a window called \"Hello, // world!\" and append into it. ImGui :: Text ( \"This is some useful text.\" ); // Display some text (you can use // a format strings too) ImGui :: Checkbox ( \"Demo Window\" , & show_demo_window ); // Edit bools storing our window // open/close state ImGui :: Checkbox ( \"Another Window\" , & show_another_window ); ImGui :: SliderFloat ( \"float\" , & f , 0.0f , 1.0f ); // Edit 1 float using a slider from 0.0f to 1.0f ImGui :: ColorEdit3 ( \"clear color\" , ( float * ) & clear_color ); // Edit 3 floats representing a color if ( ImGui :: Button ( \"Button\" )) // Buttons return true when clicked (most widgets // return true when edited/activated) counter ++ ; ImGui :: SameLine (); ImGui :: Text ( \"counter = %d\" , counter ); ImGui :: Text ( \"Application average %.3f ms/frame (%.1f FPS)\" , 1000.0f / ImGui :: GetIO (). Framerate , ImGui :: GetIO (). Framerate ); ImGui :: End (); } // 3. Show another simple window. if ( show_another_window ) { ImGui :: Begin ( \"Another Window\" , & show_another_window ); // Pass a pointer to our bool variable // (the window will have a closing button // that will clear the bool when clicked) ImGui :: Text ( \"Hello from another window!\" ); if ( ImGui :: Button ( \"Close Me\" )) show_another_window = false ; ImGui :: End (); } // Rendering ImGui :: Render (); int display_w , display_h ; glfwGetFramebufferSize ( window , & display_w , & display_h ); glViewport ( 0 , 0 , display_w , display_h ); glClearColor ( clear_color . x , clear_color . y , clear_color . z , clear_color . w ); glClear ( GL_COLOR_BUFFER_BIT ); ImGui_ImplOpenGL3_RenderDrawData ( ImGui :: GetDrawData ()); glfwSwapBuffers ( window ); } // Cleanup ImGui_ImplOpenGL3_Shutdown (); ImGui_ImplGlfw_Shutdown (); ImGui :: DestroyContext (); glfwDestroyWindow ( window ); glfwTerminate (); return 0 ; } Build script: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 find_package ( OpenGL ) if ( NOT OPENGL_FOUND OR NOT EXPECTED_COMPILER ) return () endif () if ( CMAKE_SYSTEM_NAME STREQUAL Linux ) find_package ( X11 REQUIRED ) if ( NOT X11_Xi_FOUND ) message ( FATAL_ERROR \"X11 Xi library is required\" ) endif () endif () if ( NOT TARGET glad AND EXPECTED_COMPILER ) FetchContent_Declare ( glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9 ) FetchContent_MakeAvailable ( glad ) endif () if ( NOT TARGET glfw AND EXPECTED_COMPILER ) set ( GLFW_BUILD_DOCS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_TESTS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_INSTALL OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( glfw GIT_REPOSITORY https://github.com/glfw/glfw.git GIT_TAG 3.3.2 ) FetchContent_MakeAvailable ( glfw ) if ( MSVC ) # target_compile_options(glfw PRIVATE /Wno-pedantic) else () target_compile_options ( glfw PRIVATE -Wno-pedantic -Wno-missing-field-initializers -Wno-unused-parameter ) endif () endif () set ( GLFW_INSTALL OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( imgui GIT_REPOSITORY https://github.com/ocornut/imgui.git GIT_TAG v1.77 ) FetchContent_GetProperties ( imgui ) if ( NOT imgui_POPULATED ) FetchContent_Populate ( imgui ) set ( IMGUI_INCLUDE_DIR ${ imgui_SOURCE_DIR } / ) file ( GLOB IMGUI_SOURCES ${ imgui_SOURCE_DIR } /*.cpp ) file ( GLOB IMGUI_HEADERS ${ imgui_SOURCE_DIR } /*.h ) add_library ( imgui STATIC ${ IMGUI_SOURCES } ${ IMGUI_SOURCES } ${ imgui_SOURCE_DIR } /examples/imgui_impl_glfw.cpp ${ imgui_SOURCE_DIR } /examples/imgui_impl_opengl3.cpp ) add_definitions ( -DIMGUI_IMPL_OPENGL_LOADER_GLAD ) target_include_directories ( imgui PUBLIC ${ IMGUI_INCLUDE_DIR } ${ OPENGL_INCLUDE_DIR } ${ GLFW_INCLUDE_DIR } ${ GLAD_INCLUDE_DIR } ) target_link_libraries ( imgui ${ OPENGL_LIBRARIES } glfw glad ) endif () if ( EXPECTED_COMPILER ) add_executable ( imgui_hello imgui_hello.cpp ) target_link_libraries ( imgui_hello PUBLIC imgui ) endif ()","title":"IMGUI"},{"location":"guis/imgui/#imgui","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 // dear imgui: standalone example application for GLFW + OpenGL 3, using // programmable pipeline If you are new to dear imgui, see examples/README.txt // and documentation at the top of imgui.cpp. (GLFW is a cross-platform general // purpose library for handling windows, inputs, OpenGL/Vulkan/Metal graphics // context creation, etc.) #include \"examples/imgui_impl_glfw.h\" #include \"examples/imgui_impl_opengl3.h\" #include \"imgui.h\" #include <stdio.h> // About Desktop OpenGL function loaders: // Modern desktop OpenGL doesn't have a standard portable header file to load // OpenGL function pointers. Helper libraries are often used for this purpose! // Here we are supporting a few common ones (gl3w, glew, glad). You may use // another loader/header of your choice (glext, glLoadGen, etc.), or chose to // manually implement your own. #if defined(IMGUI_IMPL_OPENGL_LOADER_GL3W) #include <GL/gl3w.h> // Initialize with gl3wInit() #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLEW) #include <GL/glew.h> // Initialize with glewInit() #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD) #include <glad/glad.h> // Initialize with gladLoadGL() #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING2) #define GLFW_INCLUDE_NONE // GLFW including OpenGL headers causes ambiguity or // multiple definition errors. #include <glbinding/Binding.h> // Initialize with glbinding::Binding::initialize() #include <glbinding/gl/gl.h> using namespace gl ; #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING3) #define GLFW_INCLUDE_NONE // GLFW including OpenGL headers causes ambiguity or // multiple definition errors. #include <glbinding/gl/gl.h> #include <glbinding/glbinding.h> // Initialize with glbinding::initialize() using namespace gl ; #else #include IMGUI_IMPL_OPENGL_LOADER_CUSTOM #endif // Include glfw3.h after our OpenGL definitions #include <GLFW/glfw3.h> // [Win32] Our example includes a copy of glfw3.lib pre-compiled with VS2010 to // maximize ease of testing and compatibility with old VS compilers. To link // with VS2010-era libraries, VS2015+ requires linking with // legacy_stdio_definitions.lib, which we do using this pragma. Your own project // should not be affected, as you are likely to link with a newer binary of GLFW // that is adequate for your version of Visual Studio. #if defined(_MSC_VER) && (_MSC_VER >= 1900) && \\ !defined(IMGUI_DISABLE_WIN32_FUNCTIONS) #pragma comment(lib, \"legacy_stdio_definitions\") #endif static void glfw_error_callback ( int error , const char * description ) { fprintf ( stderr , \"Glfw Error %d: %s \\n \" , error , description ); } int main ( int , char ** ) { // Setup window glfwSetErrorCallback ( glfw_error_callback ); if ( ! glfwInit ()) return 1 ; // Decide GL+GLSL versions #if __APPLE__ // GL 3.2 + GLSL 150 const char * glsl_version = \"#version 150\" ; glfwWindowHint ( GLFW_CONTEXT_VERSION_MAJOR , 3 ); glfwWindowHint ( GLFW_CONTEXT_VERSION_MINOR , 2 ); glfwWindowHint ( GLFW_OPENGL_PROFILE , GLFW_OPENGL_CORE_PROFILE ); // 3.2+ only glfwWindowHint ( GLFW_OPENGL_FORWARD_COMPAT , GL_TRUE ); // Required on Mac #else // GL 3.0 + GLSL 130 const char * glsl_version = \"#version 130\" ; glfwWindowHint ( GLFW_CONTEXT_VERSION_MAJOR , 3 ); glfwWindowHint ( GLFW_CONTEXT_VERSION_MINOR , 0 ); // glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 3.2+ // only glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // 3.0+ only #endif // Create window with graphics context GLFWwindow * window = glfwCreateWindow ( 1280 , 720 , \"Dear ImGui GLFW+OpenGL3 example\" , NULL , NULL ); if ( window == NULL ) return 1 ; glfwMakeContextCurrent ( window ); glfwSwapInterval ( 1 ); // Enable vsync // Initialize OpenGL loader #if defined(IMGUI_IMPL_OPENGL_LOADER_GL3W) bool err = gl3wInit () != 0 ; #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLEW) bool err = glewInit () != GLEW_OK ; #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLAD) bool err = gladLoadGL () == 0 ; #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING2) bool err = false ; glbinding :: Binding :: initialize (); #elif defined(IMGUI_IMPL_OPENGL_LOADER_GLBINDING3) bool err = false ; glbinding :: initialize ([]( const char * name ) { return ( glbinding :: ProcAddress ) glfwGetProcAddress ( name ); }); #else bool err = false ; // If you use IMGUI_IMPL_OPENGL_LOADER_CUSTOM, your loader // is likely to requires some form of initialization. #endif if ( err ) { fprintf ( stderr , \"Failed to initialize OpenGL loader! \\n \" ); return 1 ; } // Setup Dear ImGui context IMGUI_CHECKVERSION (); ImGui :: CreateContext (); ImGuiIO & io = ImGui :: GetIO (); ( void ) io ; // io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard; // Enable // Keyboard Controls io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad; // // Enable Gamepad Controls // Setup Dear ImGui style ImGui :: StyleColorsDark (); // ImGui::StyleColorsClassic(); // Setup Platform/Renderer bindings ImGui_ImplGlfw_InitForOpenGL ( window , true ); ImGui_ImplOpenGL3_Init ( glsl_version ); // Load Fonts // - If no fonts are loaded, dear imgui will use the default font. You can // also load multiple fonts and use ImGui::PushFont()/PopFont() to select // them. // - AddFontFromFileTTF() will return the ImFont* so you can store it if you // need to select the font among multiple. // - If the file cannot be loaded, the function will return NULL. Please // handle those errors in your application (e.g. use an assertion, or // display an error and quit). // - The fonts will be rasterized at a given size (w/ oversampling) and // stored into a texture when calling // ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame // below will call. // - Read 'docs/FONTS.txt' for more instructions and details. // - Remember that in C/C++ if you want to include a backslash \\ in a string // literal you need to write a double backslash \\\\ ! // io.Fonts->AddFontDefault(); // io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Roboto-Medium.ttf\", 16.0f); // io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Cousine-Regular.ttf\", 15.0f); // io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/DroidSans.ttf\", 16.0f); // io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/ProggyTiny.ttf\", 10.0f); // ImFont* font = // io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\ArialUni.ttf\", 18.0f, // NULL, io.Fonts->GetGlyphRangesJapanese()); IM_ASSERT(font != NULL); // Our state bool show_demo_window = true ; bool show_another_window = false ; ImVec4 clear_color = ImVec4 ( 0.45f , 0.55f , 0.60f , 1.00f ); // Main loop while ( ! glfwWindowShouldClose ( window )) { // Poll and handle events (inputs, window resize, etc.) // You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to // tell if dear imgui wants to use your inputs. // - When io.WantCaptureMouse is true, do not dispatch mouse input data // to your main application. // - When io.WantCaptureKeyboard is true, do not dispatch keyboard input // data to your main application. Generally you may always pass all // inputs to dear imgui, and hide them from your application based on // those two flags. glfwPollEvents (); // Start the Dear ImGui frame ImGui_ImplOpenGL3_NewFrame (); ImGui_ImplGlfw_NewFrame (); ImGui :: NewFrame (); // 1. Show the big demo window (Most of the sample code is in // ImGui::ShowDemoWindow()! You can browse its code to learn more about // Dear ImGui!). if ( show_demo_window ) ImGui :: ShowDemoWindow ( & show_demo_window ); // 2. Show a simple window that we create ourselves. We use a Begin/End // pair to created a named window. { static float f = 0.0f ; static int counter = 0 ; ImGui :: Begin ( \"Hello, world!\" ); // Create a window called \"Hello, // world!\" and append into it. ImGui :: Text ( \"This is some useful text.\" ); // Display some text (you can use // a format strings too) ImGui :: Checkbox ( \"Demo Window\" , & show_demo_window ); // Edit bools storing our window // open/close state ImGui :: Checkbox ( \"Another Window\" , & show_another_window ); ImGui :: SliderFloat ( \"float\" , & f , 0.0f , 1.0f ); // Edit 1 float using a slider from 0.0f to 1.0f ImGui :: ColorEdit3 ( \"clear color\" , ( float * ) & clear_color ); // Edit 3 floats representing a color if ( ImGui :: Button ( \"Button\" )) // Buttons return true when clicked (most widgets // return true when edited/activated) counter ++ ; ImGui :: SameLine (); ImGui :: Text ( \"counter = %d\" , counter ); ImGui :: Text ( \"Application average %.3f ms/frame (%.1f FPS)\" , 1000.0f / ImGui :: GetIO (). Framerate , ImGui :: GetIO (). Framerate ); ImGui :: End (); } // 3. Show another simple window. if ( show_another_window ) { ImGui :: Begin ( \"Another Window\" , & show_another_window ); // Pass a pointer to our bool variable // (the window will have a closing button // that will clear the bool when clicked) ImGui :: Text ( \"Hello from another window!\" ); if ( ImGui :: Button ( \"Close Me\" )) show_another_window = false ; ImGui :: End (); } // Rendering ImGui :: Render (); int display_w , display_h ; glfwGetFramebufferSize ( window , & display_w , & display_h ); glViewport ( 0 , 0 , display_w , display_h ); glClearColor ( clear_color . x , clear_color . y , clear_color . z , clear_color . w ); glClear ( GL_COLOR_BUFFER_BIT ); ImGui_ImplOpenGL3_RenderDrawData ( ImGui :: GetDrawData ()); glfwSwapBuffers ( window ); } // Cleanup ImGui_ImplOpenGL3_Shutdown (); ImGui_ImplGlfw_Shutdown (); ImGui :: DestroyContext (); glfwDestroyWindow ( window ); glfwTerminate (); return 0 ; } Build script: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 find_package ( OpenGL ) if ( NOT OPENGL_FOUND OR NOT EXPECTED_COMPILER ) return () endif () if ( CMAKE_SYSTEM_NAME STREQUAL Linux ) find_package ( X11 REQUIRED ) if ( NOT X11_Xi_FOUND ) message ( FATAL_ERROR \"X11 Xi library is required\" ) endif () endif () if ( NOT TARGET glad AND EXPECTED_COMPILER ) FetchContent_Declare ( glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9 ) FetchContent_MakeAvailable ( glad ) endif () if ( NOT TARGET glfw AND EXPECTED_COMPILER ) set ( GLFW_BUILD_DOCS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_TESTS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_INSTALL OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( glfw GIT_REPOSITORY https://github.com/glfw/glfw.git GIT_TAG 3.3.2 ) FetchContent_MakeAvailable ( glfw ) if ( MSVC ) # target_compile_options(glfw PRIVATE /Wno-pedantic) else () target_compile_options ( glfw PRIVATE -Wno-pedantic -Wno-missing-field-initializers -Wno-unused-parameter ) endif () endif () set ( GLFW_INSTALL OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( imgui GIT_REPOSITORY https://github.com/ocornut/imgui.git GIT_TAG v1.77 ) FetchContent_GetProperties ( imgui ) if ( NOT imgui_POPULATED ) FetchContent_Populate ( imgui ) set ( IMGUI_INCLUDE_DIR ${ imgui_SOURCE_DIR } / ) file ( GLOB IMGUI_SOURCES ${ imgui_SOURCE_DIR } /*.cpp ) file ( GLOB IMGUI_HEADERS ${ imgui_SOURCE_DIR } /*.h ) add_library ( imgui STATIC ${ IMGUI_SOURCES } ${ IMGUI_SOURCES } ${ imgui_SOURCE_DIR } /examples/imgui_impl_glfw.cpp ${ imgui_SOURCE_DIR } /examples/imgui_impl_opengl3.cpp ) add_definitions ( -DIMGUI_IMPL_OPENGL_LOADER_GLAD ) target_include_directories ( imgui PUBLIC ${ IMGUI_INCLUDE_DIR } ${ OPENGL_INCLUDE_DIR } ${ GLFW_INCLUDE_DIR } ${ GLAD_INCLUDE_DIR } ) target_link_libraries ( imgui ${ OPENGL_LIBRARIES } glfw glad ) endif () if ( EXPECTED_COMPILER ) add_executable ( imgui_hello imgui_hello.cpp ) target_link_libraries ( imgui_hello PUBLIC imgui ) endif ()","title":"IMGUI"},{"location":"guis/opengl--glfw/","text":"OpenGL + GLFW 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #include <glad/glad.h> #include <GLFW/glfw3.h> #include <iostream> void framebuffer_size_callback ( GLFWwindow * window , int width , int height ); void processInput ( GLFWwindow * window ); // settings const unsigned int SCR_WIDTH = 800 ; const unsigned int SCR_HEIGHT = 600 ; int main () { // glfw: initialize and configure // ------------------------------ glfwInit (); glfwWindowHint ( GLFW_CONTEXT_VERSION_MAJOR , 3 ); glfwWindowHint ( GLFW_CONTEXT_VERSION_MINOR , 3 ); glfwWindowHint ( GLFW_OPENGL_PROFILE , GLFW_OPENGL_CORE_PROFILE ); #ifdef __APPLE__ glfwWindowHint ( GLFW_OPENGL_FORWARD_COMPAT , GL_TRUE ); #endif // glfw window creation // -------------------- GLFWwindow * window = glfwCreateWindow ( SCR_WIDTH , SCR_HEIGHT , \"LearnOpenGL\" , NULL , NULL ); if ( window == NULL ) { std :: cout << \"Failed to create GLFW window\" << std :: endl ; glfwTerminate (); return -1 ; } glfwMakeContextCurrent ( window ); glfwSetFramebufferSizeCallback ( window , framebuffer_size_callback ); // glad: load all OpenGL function pointers // --------------------------------------- if ( ! gladLoadGLLoader (( GLADloadproc ) glfwGetProcAddress )) { std :: cout << \"Failed to initialize GLAD\" << std :: endl ; return -1 ; } // render loop // ----------- while ( ! glfwWindowShouldClose ( window )) { // input // ----- processInput ( window ); // render // ------ glClearColor ( 0.2f , 0.3f , 0.3f , 1.0f ); glClear ( GL_COLOR_BUFFER_BIT ); // glfw: swap buffers and poll IO events (keys pressed/released, mouse // moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers ( window ); glfwPollEvents (); } // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate (); return 0 ; } // process all input: query GLFW whether relevant keys are pressed/released this // frame and react accordingly // --------------------------------------------------------------------------------------------------------- void processInput ( GLFWwindow * window ) { if ( glfwGetKey ( window , GLFW_KEY_ESCAPE ) == GLFW_PRESS ) glfwSetWindowShouldClose ( window , true ); } // glfw: whenever the window size changed (by OS or user resize) this callback // function executes // --------------------------------------------------------------------------------------------- void framebuffer_size_callback ([[ maybe_unused ]] GLFWwindow * window , int width , int height ) { // make sure the viewport matches the new window dimensions; note that width // and height will be significantly larger than specified on retina // displays. glViewport ( 0 , 0 , width , height ); } Build script: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 find_package ( OpenGL ) if ( NOT OPENGL_FOUND OR NOT EXPECTED_COMPILER ) return () endif () if ( NOT TARGET glad AND EXPECTED_COMPILER ) FetchContent_Declare ( glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9 ) FetchContent_MakeAvailable ( glad ) endif () if ( NOT TARGET glfw AND EXPECTED_COMPILER ) set ( GLFW_BUILD_DOCS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_TESTS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_INSTALL OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( glfw GIT_REPOSITORY https://github.com/glfw/glfw.git GIT_TAG 3.3.2 ) FetchContent_MakeAvailable ( glfw ) if ( MSVC ) # target_compile_options(glfw PUBLIC /Wno-pedantic) else () target_compile_options ( glfw PRIVATE -Wno-pedantic -Wno-missing-field-initializers -Wno-unused-parameter ) endif () endif () if ( EXPECTED_COMPILER ) add_executable ( opengl_hello opengl_hello.cpp ) target_link_libraries ( opengl_hello PUBLIC glad glfw ) endif ()","title":"OpenGL + GLFW"},{"location":"guis/opengl--glfw/#opengl-glfw","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #include <glad/glad.h> #include <GLFW/glfw3.h> #include <iostream> void framebuffer_size_callback ( GLFWwindow * window , int width , int height ); void processInput ( GLFWwindow * window ); // settings const unsigned int SCR_WIDTH = 800 ; const unsigned int SCR_HEIGHT = 600 ; int main () { // glfw: initialize and configure // ------------------------------ glfwInit (); glfwWindowHint ( GLFW_CONTEXT_VERSION_MAJOR , 3 ); glfwWindowHint ( GLFW_CONTEXT_VERSION_MINOR , 3 ); glfwWindowHint ( GLFW_OPENGL_PROFILE , GLFW_OPENGL_CORE_PROFILE ); #ifdef __APPLE__ glfwWindowHint ( GLFW_OPENGL_FORWARD_COMPAT , GL_TRUE ); #endif // glfw window creation // -------------------- GLFWwindow * window = glfwCreateWindow ( SCR_WIDTH , SCR_HEIGHT , \"LearnOpenGL\" , NULL , NULL ); if ( window == NULL ) { std :: cout << \"Failed to create GLFW window\" << std :: endl ; glfwTerminate (); return -1 ; } glfwMakeContextCurrent ( window ); glfwSetFramebufferSizeCallback ( window , framebuffer_size_callback ); // glad: load all OpenGL function pointers // --------------------------------------- if ( ! gladLoadGLLoader (( GLADloadproc ) glfwGetProcAddress )) { std :: cout << \"Failed to initialize GLAD\" << std :: endl ; return -1 ; } // render loop // ----------- while ( ! glfwWindowShouldClose ( window )) { // input // ----- processInput ( window ); // render // ------ glClearColor ( 0.2f , 0.3f , 0.3f , 1.0f ); glClear ( GL_COLOR_BUFFER_BIT ); // glfw: swap buffers and poll IO events (keys pressed/released, mouse // moved etc.) // ------------------------------------------------------------------------------- glfwSwapBuffers ( window ); glfwPollEvents (); } // glfw: terminate, clearing all previously allocated GLFW resources. // ------------------------------------------------------------------ glfwTerminate (); return 0 ; } // process all input: query GLFW whether relevant keys are pressed/released this // frame and react accordingly // --------------------------------------------------------------------------------------------------------- void processInput ( GLFWwindow * window ) { if ( glfwGetKey ( window , GLFW_KEY_ESCAPE ) == GLFW_PRESS ) glfwSetWindowShouldClose ( window , true ); } // glfw: whenever the window size changed (by OS or user resize) this callback // function executes // --------------------------------------------------------------------------------------------- void framebuffer_size_callback ([[ maybe_unused ]] GLFWwindow * window , int width , int height ) { // make sure the viewport matches the new window dimensions; note that width // and height will be significantly larger than specified on retina // displays. glViewport ( 0 , 0 , width , height ); } Build script: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 find_package ( OpenGL ) if ( NOT OPENGL_FOUND OR NOT EXPECTED_COMPILER ) return () endif () if ( NOT TARGET glad AND EXPECTED_COMPILER ) FetchContent_Declare ( glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9 ) FetchContent_MakeAvailable ( glad ) endif () if ( NOT TARGET glfw AND EXPECTED_COMPILER ) set ( GLFW_BUILD_DOCS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_EXAMPLES OFF CACHE BOOL \"\" FORCE ) set ( GLFW_BUILD_TESTS OFF CACHE BOOL \"\" FORCE ) set ( GLFW_INSTALL OFF CACHE BOOL \"\" FORCE ) FetchContent_Declare ( glfw GIT_REPOSITORY https://github.com/glfw/glfw.git GIT_TAG 3.3.2 ) FetchContent_MakeAvailable ( glfw ) if ( MSVC ) # target_compile_options(glfw PUBLIC /Wno-pedantic) else () target_compile_options ( glfw PRIVATE -Wno-pedantic -Wno-missing-field-initializers -Wno-unused-parameter ) endif () endif () if ( EXPECTED_COMPILER ) add_executable ( opengl_hello opengl_hello.cpp ) target_link_libraries ( opengl_hello PUBLIC glad glfw ) endif ()","title":"OpenGL + GLFW"},{"location":"guis/opengl--sdl/","text":"OpenGL + SDL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include <glad/glad.h> // SDL #include <SDL.h> #include <SDL_syswm.h> #if defined(__APPLE__) #include \"TargetConditionals.h\" #endif #include <cstdio> #include <thread> int main () { // Setup SDL // (Some versions of SDL before <2.0.10 appears to have performance/stalling // issues on a minority of Windows systems, depending on whether // SDL_INIT_GAMECONTROLLER is enabled or disabled.. updating to latest // version of SDL is recommended!) if ( SDL_Init ( SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMECONTROLLER ) != 0 ) { printf ( \"Error: %s \\n \" , SDL_GetError ()); return -1 ; } // Decide GL+GLSL versions #if __APPLE__ // GL 3.2 Core + GLSL 150 // const char *glsl_version = \"#version 150\"; SDL_GL_SetAttribute ( SDL_GL_CONTEXT_FLAGS , SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG ); // Always required on Mac SDL_GL_SetAttribute ( SDL_GL_CONTEXT_PROFILE_MASK , SDL_GL_CONTEXT_PROFILE_CORE ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MAJOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MINOR_VERSION , 2 ); #else // GL 3.0 + GLSL 130 const char * glsl_version = \"#version 130\" ; SDL_GL_SetAttribute ( SDL_GL_CONTEXT_FLAGS , 0 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_PROFILE_MASK , SDL_GL_CONTEXT_PROFILE_CORE ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MAJOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MINOR_VERSION , 0 ); #endif // Create window with graphics context SDL_GL_SetAttribute ( SDL_GL_DOUBLEBUFFER , 1 ); SDL_GL_SetAttribute ( SDL_GL_DEPTH_SIZE , 24 ); SDL_GL_SetAttribute ( SDL_GL_STENCIL_SIZE , 8 ); SDL_WindowFlags window_flags = ( SDL_WindowFlags )( SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI ); SDL_Window * window = SDL_CreateWindow ( \"SDL2 Example\" , SDL_WINDOWPOS_CENTERED , SDL_WINDOWPOS_CENTERED , 1280 , 720 , window_flags ); SDL_GLContext gl_context = SDL_GL_CreateContext ( window ); SDL_GL_MakeCurrent ( window , gl_context ); SDL_GL_SetSwapInterval ( 1 ); // Enable vsync // Initialize OpenGL loader bool err = gladLoadGL () == 0 ; if ( err ) { fprintf ( stderr , \"Failed to initialize OpenGL loader! \\n \" ); return 1 ; } bool done = false ; while ( ! done ) { SDL_Event event ; while ( SDL_PollEvent ( & event )) { if ( event . type == SDL_QUIT ) { done = true ; } if ( event . type == SDL_WINDOWEVENT && event . window . event == SDL_WINDOWEVENT_CLOSE && event . window . windowID == SDL_GetWindowID ( window )) { done = true ; } } glViewport ( 0 , 0 , 600 , 400 ); glClearColor ( 0.45f , 0.55f , 0.60f , 1.00f ); glClear ( GL_COLOR_BUFFER_BIT ); SDL_GL_SwapWindow ( window ); } SDL_GL_DeleteContext ( gl_context ); SDL_DestroyWindow ( window ); SDL_Quit (); return 0 ; } Build script: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if ( NOT EXPECTED_COMPILER ) return () endif () find_package ( SDL2 ) if ( SDL2_FOUND ) if ( NOT TARGET glad AND EXPECTED_COMPILER ) FetchContent_Declare ( glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9 ) FetchContent_MakeAvailable ( glad ) endif () if ( SDL2_FOUND AND EXPECTED_COMPILER ) add_executable ( sdl_hello sdl_hello.cpp ) target_link_libraries ( sdl_hello PUBLIC ${ SDL2_LIBRARIES } glad ) target_include_directories ( sdl_hello PRIVATE ${ SDL2_INCLUDE_DIRS } ) endif () endif ()","title":"OpenGL + SDL"},{"location":"guis/opengl--sdl/#opengl-sdl","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 #include <glad/glad.h> // SDL #include <SDL.h> #include <SDL_syswm.h> #if defined(__APPLE__) #include \"TargetConditionals.h\" #endif #include <cstdio> #include <thread> int main () { // Setup SDL // (Some versions of SDL before <2.0.10 appears to have performance/stalling // issues on a minority of Windows systems, depending on whether // SDL_INIT_GAMECONTROLLER is enabled or disabled.. updating to latest // version of SDL is recommended!) if ( SDL_Init ( SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMECONTROLLER ) != 0 ) { printf ( \"Error: %s \\n \" , SDL_GetError ()); return -1 ; } // Decide GL+GLSL versions #if __APPLE__ // GL 3.2 Core + GLSL 150 // const char *glsl_version = \"#version 150\"; SDL_GL_SetAttribute ( SDL_GL_CONTEXT_FLAGS , SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG ); // Always required on Mac SDL_GL_SetAttribute ( SDL_GL_CONTEXT_PROFILE_MASK , SDL_GL_CONTEXT_PROFILE_CORE ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MAJOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MINOR_VERSION , 2 ); #else // GL 3.0 + GLSL 130 const char * glsl_version = \"#version 130\" ; SDL_GL_SetAttribute ( SDL_GL_CONTEXT_FLAGS , 0 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_PROFILE_MASK , SDL_GL_CONTEXT_PROFILE_CORE ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MAJOR_VERSION , 3 ); SDL_GL_SetAttribute ( SDL_GL_CONTEXT_MINOR_VERSION , 0 ); #endif // Create window with graphics context SDL_GL_SetAttribute ( SDL_GL_DOUBLEBUFFER , 1 ); SDL_GL_SetAttribute ( SDL_GL_DEPTH_SIZE , 24 ); SDL_GL_SetAttribute ( SDL_GL_STENCIL_SIZE , 8 ); SDL_WindowFlags window_flags = ( SDL_WindowFlags )( SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI ); SDL_Window * window = SDL_CreateWindow ( \"SDL2 Example\" , SDL_WINDOWPOS_CENTERED , SDL_WINDOWPOS_CENTERED , 1280 , 720 , window_flags ); SDL_GLContext gl_context = SDL_GL_CreateContext ( window ); SDL_GL_MakeCurrent ( window , gl_context ); SDL_GL_SetSwapInterval ( 1 ); // Enable vsync // Initialize OpenGL loader bool err = gladLoadGL () == 0 ; if ( err ) { fprintf ( stderr , \"Failed to initialize OpenGL loader! \\n \" ); return 1 ; } bool done = false ; while ( ! done ) { SDL_Event event ; while ( SDL_PollEvent ( & event )) { if ( event . type == SDL_QUIT ) { done = true ; } if ( event . type == SDL_WINDOWEVENT && event . window . event == SDL_WINDOWEVENT_CLOSE && event . window . windowID == SDL_GetWindowID ( window )) { done = true ; } } glViewport ( 0 , 0 , 600 , 400 ); glClearColor ( 0.45f , 0.55f , 0.60f , 1.00f ); glClear ( GL_COLOR_BUFFER_BIT ); SDL_GL_SwapWindow ( window ); } SDL_GL_DeleteContext ( gl_context ); SDL_DestroyWindow ( window ); SDL_Quit (); return 0 ; } Build script: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if ( NOT EXPECTED_COMPILER ) return () endif () find_package ( SDL2 ) if ( SDL2_FOUND ) if ( NOT TARGET glad AND EXPECTED_COMPILER ) FetchContent_Declare ( glad GIT_REPOSITORY https://github.com/Dav1dde/glad.git GIT_TAG df8e9e16110b305479a875399cee13daa0ccadd9 ) FetchContent_MakeAvailable ( glad ) endif () if ( SDL2_FOUND AND EXPECTED_COMPILER ) add_executable ( sdl_hello sdl_hello.cpp ) target_link_libraries ( sdl_hello PUBLIC ${ SDL2_LIBRARIES } glad ) target_include_directories ( sdl_hello PRIVATE ${ SDL2_INCLUDE_DIRS } ) endif () endif ()","title":"OpenGL + SDL"},{"location":"guis/qt/","text":"Qt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <QApplication> #include <QPushButton> #include <iostream> int main ( int argc , char ** argv ) { QApplication app ( argc , argv ); QWidget window ; window . setFixedSize ( 100 , 80 ); auto * buttonInfo = new QPushButton ( \"Info\" , & window ); buttonInfo -> setGeometry ( 10 , 10 , 80 , 30 ); QApplication :: connect ( buttonInfo , & QPushButton :: clicked , [] { std :: cout << \"Info\" << std :: endl ; }); auto * buttonQuit = new QPushButton ( \"Quit\" , & window ); buttonQuit -> setGeometry ( 10 , 40 , 80 , 30 ); QApplication :: connect ( buttonQuit , & QPushButton :: clicked , [] { QApplication :: quit (); }); window . show (); return QApplication :: exec (); } Build script: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 # If the user has not set the Qt prefix path if ( NOT CMAKE_PREFIX_PATH ) # Loop through some reasonable candidates # This code can be improved a lot foreach ( QT_V1_CANDIDATE 5 4 ) foreach ( QT_V2_CANDIDATE 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 ) foreach ( QT_V3_CANDIDATE 10 9 8 7 6 5 4 3 2 1 0 ) set ( QT_VERSION_CANDIDATES ${ QT_VERSION_CANDIDATES } ${ QT_V1_CANDIDATE } . ${ QT_V2_CANDIDATE } . ${ QT_V2_CANDIDATE } ) endforeach () endforeach () endforeach () set ( QT_PATH_CANDIDATES /usr/local/qt/ /usr/local/Cellar/qt/ \"C:\\\\Qt\\\\\" ) foreach ( QT_PATH_CANDIDATE ${ QT_PATH_CANDIDATES } ) if ( EXISTS ${ QT_PATH_CANDIDATE } ) foreach ( QT_VERSION_CANDIDATE ${ QT_VERSION_CANDIDATES } ) set ( FULL_PATH_CANDIDATE ${ QT_PATH_CANDIDATE } / ${ QT_VERSION_CANDIDATE } ) if ( EXISTS ${ FULL_PATH_CANDIDATE } ) set ( CMAKE_PREFIX_PATH ${ CMAKE_PREFIX_PATH } ${ FULL_PATH_CANDIDATE } ) endif () set ( FULL_PATH_CANDIDATE ${ QT_PATH_CANDIDATE } / ${ QT_VERSION_CANDIDATE } /lib/cmake/Qt5 ) if ( EXISTS ${ FULL_PATH_CANDIDATE } ) set ( CMAKE_PREFIX_PATH ${ CMAKE_PREFIX_PATH } ${ FULL_PATH_CANDIDATE } ) endif () endforeach () endif () endforeach () endif () # If we still don't have a CMAKE_PREFIX_PATH if ( NOT CMAKE_PREFIX_PATH AND NOT Qt5Widgets_DIR ) message ( WARNING \"CMAKE_PREFIX_PATH is not defined, you may need to set it \" \"(-DCMAKE_PREFIX_PATH=\\\" path/to/Qt/lib/cmake\\ \" or -DCMAKE_PREFIX_PATH=/usr/include/{host}/qt{version}/ on Ubuntu)\" ) message ( \"find_package(Qt5) is probably not going to work. Set the CMAKE_PREFIX_PATH \" \"environment variable to the install prefix of Qt 5, either on the command line as \" \"-DCMAKE_PREFIX_PATH=\\\" path/to/Qt5/lib/cmake\\ \" or with set(CMAKE_PREFIX_PATH path/to/Qt5/lib/cmake)\" ) endif () # Try to find qt anyway find_package ( Qt5 COMPONENTS Widgets QUIET ) if ( NOT Qt5_FOUND ) return () endif () # Create example set ( CMAKE_AUTOMOC ON ) set ( CMAKE_AUTORCC ON ) set ( CMAKE_AUTOUIC ON ) add_executable ( qt_helloworld qt_hello.cpp ) target_link_libraries ( qt_helloworld Qt5::Widgets ) set ( CMAKE_AUTOMOC OFF ) set ( CMAKE_AUTORCC OFF ) set ( CMAKE_AUTOUIC OFF )","title":"Qt"},{"location":"guis/qt/#qt","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <QApplication> #include <QPushButton> #include <iostream> int main ( int argc , char ** argv ) { QApplication app ( argc , argv ); QWidget window ; window . setFixedSize ( 100 , 80 ); auto * buttonInfo = new QPushButton ( \"Info\" , & window ); buttonInfo -> setGeometry ( 10 , 10 , 80 , 30 ); QApplication :: connect ( buttonInfo , & QPushButton :: clicked , [] { std :: cout << \"Info\" << std :: endl ; }); auto * buttonQuit = new QPushButton ( \"Quit\" , & window ); buttonQuit -> setGeometry ( 10 , 40 , 80 , 30 ); QApplication :: connect ( buttonQuit , & QPushButton :: clicked , [] { QApplication :: quit (); }); window . show (); return QApplication :: exec (); } Build script: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 # If the user has not set the Qt prefix path if ( NOT CMAKE_PREFIX_PATH ) # Loop through some reasonable candidates # This code can be improved a lot foreach ( QT_V1_CANDIDATE 5 4 ) foreach ( QT_V2_CANDIDATE 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 ) foreach ( QT_V3_CANDIDATE 10 9 8 7 6 5 4 3 2 1 0 ) set ( QT_VERSION_CANDIDATES ${ QT_VERSION_CANDIDATES } ${ QT_V1_CANDIDATE } . ${ QT_V2_CANDIDATE } . ${ QT_V2_CANDIDATE } ) endforeach () endforeach () endforeach () set ( QT_PATH_CANDIDATES /usr/local/qt/ /usr/local/Cellar/qt/ \"C:\\\\Qt\\\\\" ) foreach ( QT_PATH_CANDIDATE ${ QT_PATH_CANDIDATES } ) if ( EXISTS ${ QT_PATH_CANDIDATE } ) foreach ( QT_VERSION_CANDIDATE ${ QT_VERSION_CANDIDATES } ) set ( FULL_PATH_CANDIDATE ${ QT_PATH_CANDIDATE } / ${ QT_VERSION_CANDIDATE } ) if ( EXISTS ${ FULL_PATH_CANDIDATE } ) set ( CMAKE_PREFIX_PATH ${ CMAKE_PREFIX_PATH } ${ FULL_PATH_CANDIDATE } ) endif () set ( FULL_PATH_CANDIDATE ${ QT_PATH_CANDIDATE } / ${ QT_VERSION_CANDIDATE } /lib/cmake/Qt5 ) if ( EXISTS ${ FULL_PATH_CANDIDATE } ) set ( CMAKE_PREFIX_PATH ${ CMAKE_PREFIX_PATH } ${ FULL_PATH_CANDIDATE } ) endif () endforeach () endif () endforeach () endif () # If we still don't have a CMAKE_PREFIX_PATH if ( NOT CMAKE_PREFIX_PATH AND NOT Qt5Widgets_DIR ) message ( WARNING \"CMAKE_PREFIX_PATH is not defined, you may need to set it \" \"(-DCMAKE_PREFIX_PATH=\\\" path/to/Qt/lib/cmake\\ \" or -DCMAKE_PREFIX_PATH=/usr/include/{host}/qt{version}/ on Ubuntu)\" ) message ( \"find_package(Qt5) is probably not going to work. Set the CMAKE_PREFIX_PATH \" \"environment variable to the install prefix of Qt 5, either on the command line as \" \"-DCMAKE_PREFIX_PATH=\\\" path/to/Qt5/lib/cmake\\ \" or with set(CMAKE_PREFIX_PATH path/to/Qt5/lib/cmake)\" ) endif () # Try to find qt anyway find_package ( Qt5 COMPONENTS Widgets QUIET ) if ( NOT Qt5_FOUND ) return () endif () # Create example set ( CMAKE_AUTOMOC ON ) set ( CMAKE_AUTORCC ON ) set ( CMAKE_AUTOUIC ON ) add_executable ( qt_helloworld qt_hello.cpp ) target_link_libraries ( qt_helloworld Qt5::Widgets ) set ( CMAKE_AUTOMOC OFF ) set ( CMAKE_AUTORCC OFF ) set ( CMAKE_AUTOUIC OFF )","title":"Qt"},{"location":"guis/system-tray/","text":"System tray 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 #include <cstring> #include <iostream> #include <tray.h> // Set string with the icon file for your OS #if TRAY_APPINDICATOR #define TRAY_ICON1 \"indicator-messages\" #define TRAY_ICON2 \"indicator-messages-new\" #elif TRAY_APPKIT #define TRAY_ICON1 \"icon.png\" #define TRAY_ICON2 \"icon.png\" #elif TRAY_WINAPI #define TRAY_ICON1 \"icon.ico\" #define TRAY_ICON2 \"icon.ico\" #endif // Encapsulate tray and menu options into a class class tray_and_menu { public : tray_and_menu () { // Setup arrays with tray items if ( tray_ . menu != nullptr ) { return ; } tray_ . menu = new tray_menu [ 8 ]; tray_ . menu [ 0 ] = {. text = \"Hello\" , . cb = hello_cb , . submenu = nullptr }; tray_ . menu [ 1 ] = { . text = \"Checked\" , . cb = toggle_cb , . submenu = nullptr }; tray_ . menu [ 2 ] = {. text = \"Disabled\" , . disabled = 1 , . submenu = nullptr }; tray_ . menu [ 3 ] = {. text = \"-\" , . submenu = nullptr }; tray_ . menu [ 4 ] = {. text = \"SubMenu\" , . submenu = new tray_menu [ 3 ]}; tray_ . menu [ 5 ] = {. text = \"-\" , . submenu = nullptr }; tray_ . menu [ 6 ] = {. text = \"Quit\" , . cb = quit_cb , . submenu = nullptr }; tray_ . menu [ 7 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 0 ] = {. text = \"FIRST\" , . checked = 1 , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ] = {. text = \"SECOND\" , . submenu = new tray_menu [ 6 ]}; tray_ . menu [ 4 ]. submenu [ 2 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ] = {. text = \"THIRD\" , . submenu = new tray_menu [ 4 ]}; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ] = {. text = \"FOUR\" , . submenu = new tray_menu [ 3 ]}; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 2 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 0 ] = { . text = \"7\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 1 ] = {. text = \"-\" , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 2 ] = { . text = \"8\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 3 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu [ 0 ] = { . text = \"5\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu [ 1 ] = { . text = \"6\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu [ 2 ] = { . text = nullptr , . cb = submenu_cb , . submenu = nullptr }; if ( tray_init ( & tray_ ) < 0 ) { std :: runtime_error ( \"failed to create tray_\" ); } } ~ tray_and_menu () { delete [] tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu ; delete [] tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu ; delete [] tray_ . menu [ 4 ]. submenu [ 1 ]. submenu ; delete [] tray_ . menu [ 4 ]. submenu ; delete [] tray_ . menu [ 3 ]. submenu ; delete [] tray_ . menu -> submenu ; tray_ . menu -> submenu = nullptr ; } static void run_tray () { while ( tray_loop ( 1 ) == 0 ) { std :: cout << \"Iteration\" << std :: endl ; } } private : static void toggle_cb ( struct tray_menu * item ) { std :: cout << \"toggle cb\" << std :: endl ; item -> checked = ! item -> checked ; tray_update ( & tray_ ); } static void hello_cb ( struct tray_menu * item ) { ( void ) item ; std :: cout << \"hello cb\" << std :: endl ; // NOLINTNEXTLINE(bugprone-branch-clone) if ( strcmp ( tray_ . icon , TRAY_ICON1 ) == 0 ) { tray_ . icon = TRAY_ICON2 ; } else { tray_ . icon = TRAY_ICON1 ; } tray_update ( & tray_ ); } static void quit_cb ( struct tray_menu * item ) { ( void ) item ; std :: cout << \"quit cb\" << std :: endl ; tray_exit (); } static void submenu_cb ( struct tray_menu * item ) { ( void ) item ; std :: cout << \"submenu: clicked on \" << item -> text << std :: endl ; tray_update ( & tray_ ); } private /* members */ : // Tray with pointers to menu static tray tray_ ; }; tray tray_and_menu :: tray_ {. icon = TRAY_ICON1 , . menu = nullptr }; int main () { tray_and_menu t ; tray_and_menu :: run_tray (); return 0 ; } Build script: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # This hasn't been tested on all OSs if ( NOT APPLE OR NOT EXPECTED_COMPILER ) return () endif () # Library: https://github.com/zserge/tray # Patch: https://github.com/wormyrocks/tray # - GUIs with system tray_ icons are great for deamons # - This is a C99 library that seems to be abandoned # - wormyrocks/tray includes a patch fixing some issues # - So far, there is no good C++ library for the same task # - The library is quite simple though # - This can serve as inspiration for a C++ implementation FetchContent_Declare ( tray GIT_REPOSITORY https://github.com/wormyrocks/tray.git GIT_TAG 3e4a1447bff413e6907c5e43ac8d65e36866fdfd ) FetchContent_GetProperties ( tray ) if ( NOT tray_POPULATED ) FetchContent_Populate ( tray ) add_library ( tray INTERFACE ) target_sources ( tray INTERFACE ${ tray_SOURCE_DIR } /tray.h ) target_include_directories ( tray INTERFACE ${ tray_SOURCE_DIR } ) if ( WIN32 ) target_compile_definitions ( tray INTERFACE TRAY_WINAPI ) elseif ( APPLE ) target_compile_definitions ( tray INTERFACE TRAY_APPKIT ) target_link_libraries ( tray INTERFACE \"-framework Cocoa\" ) # Some warnings the library doesn't deal with target_compile_options ( tray INTERFACE -Wno-unused-parameter ) target_compile_options ( tray INTERFACE -Wno-unused-variable ) target_compile_options ( tray INTERFACE -Wno-writable-strings ) target_compile_options ( tray INTERFACE -Wno-misleading-indentation ) elseif ( UNIX ) target_compile_definitions ( tray INTERFACE TRAY_APPINDICATOR ) target_link_libraries ( tray INTERFACE \"$(shell pkg-config --cflags appindicator3-0.1 --libs appindicator3-0.1)\" ) # Some warnings the library doesn't deal with target_compile_options ( tray INTERFACE -Wno-unused-parameter ) target_compile_options ( tray INTERFACE -Wno-unused-variable ) target_compile_options ( tray INTERFACE -Wno-writable-strings ) target_compile_options ( tray INTERFACE -Wno-misleading-indentation ) endif () endif () # Create example add_executable ( tray_helloworld tray_hello.cpp ) target_link_libraries ( tray_helloworld tray ) # Copy icons if ( WIN32 ) file ( COPY ${ tray_SOURCE_DIR } /icon.ico DESTINATION ${ CMAKE_CURRENT_BINARY_DIR } ) elseif ( APPLE ) file ( COPY ${ tray_SOURCE_DIR } /icon.png DESTINATION ${ CMAKE_CURRENT_BINARY_DIR } ) endif ()","title":"System tray"},{"location":"guis/system-tray/#system-tray","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 #include <cstring> #include <iostream> #include <tray.h> // Set string with the icon file for your OS #if TRAY_APPINDICATOR #define TRAY_ICON1 \"indicator-messages\" #define TRAY_ICON2 \"indicator-messages-new\" #elif TRAY_APPKIT #define TRAY_ICON1 \"icon.png\" #define TRAY_ICON2 \"icon.png\" #elif TRAY_WINAPI #define TRAY_ICON1 \"icon.ico\" #define TRAY_ICON2 \"icon.ico\" #endif // Encapsulate tray and menu options into a class class tray_and_menu { public : tray_and_menu () { // Setup arrays with tray items if ( tray_ . menu != nullptr ) { return ; } tray_ . menu = new tray_menu [ 8 ]; tray_ . menu [ 0 ] = {. text = \"Hello\" , . cb = hello_cb , . submenu = nullptr }; tray_ . menu [ 1 ] = { . text = \"Checked\" , . cb = toggle_cb , . submenu = nullptr }; tray_ . menu [ 2 ] = {. text = \"Disabled\" , . disabled = 1 , . submenu = nullptr }; tray_ . menu [ 3 ] = {. text = \"-\" , . submenu = nullptr }; tray_ . menu [ 4 ] = {. text = \"SubMenu\" , . submenu = new tray_menu [ 3 ]}; tray_ . menu [ 5 ] = {. text = \"-\" , . submenu = nullptr }; tray_ . menu [ 6 ] = {. text = \"Quit\" , . cb = quit_cb , . submenu = nullptr }; tray_ . menu [ 7 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 0 ] = {. text = \"FIRST\" , . checked = 1 , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ] = {. text = \"SECOND\" , . submenu = new tray_menu [ 6 ]}; tray_ . menu [ 4 ]. submenu [ 2 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ] = {. text = \"THIRD\" , . submenu = new tray_menu [ 4 ]}; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ] = {. text = \"FOUR\" , . submenu = new tray_menu [ 3 ]}; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 2 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 0 ] = { . text = \"7\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 1 ] = {. text = \"-\" , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 2 ] = { . text = \"8\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu [ 3 ] = {. text = nullptr , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu [ 0 ] = { . text = \"5\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu [ 1 ] = { . text = \"6\" , . cb = submenu_cb , . submenu = nullptr }; tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu [ 2 ] = { . text = nullptr , . cb = submenu_cb , . submenu = nullptr }; if ( tray_init ( & tray_ ) < 0 ) { std :: runtime_error ( \"failed to create tray_\" ); } } ~ tray_and_menu () { delete [] tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 1 ]. submenu ; delete [] tray_ . menu [ 4 ]. submenu [ 1 ]. submenu [ 0 ]. submenu ; delete [] tray_ . menu [ 4 ]. submenu [ 1 ]. submenu ; delete [] tray_ . menu [ 4 ]. submenu ; delete [] tray_ . menu [ 3 ]. submenu ; delete [] tray_ . menu -> submenu ; tray_ . menu -> submenu = nullptr ; } static void run_tray () { while ( tray_loop ( 1 ) == 0 ) { std :: cout << \"Iteration\" << std :: endl ; } } private : static void toggle_cb ( struct tray_menu * item ) { std :: cout << \"toggle cb\" << std :: endl ; item -> checked = ! item -> checked ; tray_update ( & tray_ ); } static void hello_cb ( struct tray_menu * item ) { ( void ) item ; std :: cout << \"hello cb\" << std :: endl ; // NOLINTNEXTLINE(bugprone-branch-clone) if ( strcmp ( tray_ . icon , TRAY_ICON1 ) == 0 ) { tray_ . icon = TRAY_ICON2 ; } else { tray_ . icon = TRAY_ICON1 ; } tray_update ( & tray_ ); } static void quit_cb ( struct tray_menu * item ) { ( void ) item ; std :: cout << \"quit cb\" << std :: endl ; tray_exit (); } static void submenu_cb ( struct tray_menu * item ) { ( void ) item ; std :: cout << \"submenu: clicked on \" << item -> text << std :: endl ; tray_update ( & tray_ ); } private /* members */ : // Tray with pointers to menu static tray tray_ ; }; tray tray_and_menu :: tray_ {. icon = TRAY_ICON1 , . menu = nullptr }; int main () { tray_and_menu t ; tray_and_menu :: run_tray (); return 0 ; } Build script: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # This hasn't been tested on all OSs if ( NOT APPLE OR NOT EXPECTED_COMPILER ) return () endif () # Library: https://github.com/zserge/tray # Patch: https://github.com/wormyrocks/tray # - GUIs with system tray_ icons are great for deamons # - This is a C99 library that seems to be abandoned # - wormyrocks/tray includes a patch fixing some issues # - So far, there is no good C++ library for the same task # - The library is quite simple though # - This can serve as inspiration for a C++ implementation FetchContent_Declare ( tray GIT_REPOSITORY https://github.com/wormyrocks/tray.git GIT_TAG 3e4a1447bff413e6907c5e43ac8d65e36866fdfd ) FetchContent_GetProperties ( tray ) if ( NOT tray_POPULATED ) FetchContent_Populate ( tray ) add_library ( tray INTERFACE ) target_sources ( tray INTERFACE ${ tray_SOURCE_DIR } /tray.h ) target_include_directories ( tray INTERFACE ${ tray_SOURCE_DIR } ) if ( WIN32 ) target_compile_definitions ( tray INTERFACE TRAY_WINAPI ) elseif ( APPLE ) target_compile_definitions ( tray INTERFACE TRAY_APPKIT ) target_link_libraries ( tray INTERFACE \"-framework Cocoa\" ) # Some warnings the library doesn't deal with target_compile_options ( tray INTERFACE -Wno-unused-parameter ) target_compile_options ( tray INTERFACE -Wno-unused-variable ) target_compile_options ( tray INTERFACE -Wno-writable-strings ) target_compile_options ( tray INTERFACE -Wno-misleading-indentation ) elseif ( UNIX ) target_compile_definitions ( tray INTERFACE TRAY_APPINDICATOR ) target_link_libraries ( tray INTERFACE \"$(shell pkg-config --cflags appindicator3-0.1 --libs appindicator3-0.1)\" ) # Some warnings the library doesn't deal with target_compile_options ( tray INTERFACE -Wno-unused-parameter ) target_compile_options ( tray INTERFACE -Wno-unused-variable ) target_compile_options ( tray INTERFACE -Wno-writable-strings ) target_compile_options ( tray INTERFACE -Wno-misleading-indentation ) endif () endif () # Create example add_executable ( tray_helloworld tray_hello.cpp ) target_link_libraries ( tray_helloworld tray ) # Copy icons if ( WIN32 ) file ( COPY ${ tray_SOURCE_DIR } /icon.ico DESTINATION ${ CMAKE_CURRENT_BINARY_DIR } ) elseif ( APPLE ) file ( COPY ${ tray_SOURCE_DIR } /icon.png DESTINATION ${ CMAKE_CURRENT_BINARY_DIR } ) endif ()","title":"System tray"},{"location":"guis/webview/","text":"Webview 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <webview.h> #include <iostream> #ifdef _WIN32 int CALLBACK WinMain ( HINSTANCE hInstance , HINSTANCE hPrevInstance , LPSTR lpCmdLine , int nCmdShow ) #else int main () #endif { webview :: webview w ( true , nullptr ); w . set_title ( \"Example\" ); w . set_size ( 480 , 320 , WEBVIEW_HINT_NONE ); w . set_size ( 180 , 120 , WEBVIEW_HINT_MIN ); w . bind ( \"noop\" , []( std :: string s ) -> std :: string { std :: cout << s << std :: endl ; return s ; }); w . bind ( \"add\" , []( std :: string s ) -> std :: string { auto a = std :: stoi ( webview :: json_parse ( s , \"\" , 0 )); auto b = std :: stoi ( webview :: json_parse ( s , \"\" , 1 )); return std :: to_string ( a + b ); }); w . navigate ( R \" ( data:text/html, <!doctype html> <html> <body>hello</body> <script> window.onload = function() { document.body.innerText = `hello, ${navigator.userAgent}`; noop('hello').then(function(res) { console.log('noop res', res); }); add(1, 2).then(function(res) { console.log('add res', res); }); }; </script> </html> ) \" ); w . run (); return 0 ; } Build script: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # This hasn't been tested on all OSs if ( NOT APPLE OR NOT EXPECTED_COMPILER ) return () endif () # Library: https://github.com/zserge/tray # - Webviews are great for GUIs to work cross-platform # - They are also great for mobile GUIs # - So far, there is no good pure C++ library for the same task # - The C++ interface in this repository is still changing often # - The library is quite simple though # - This can serve as inspiration for a C++ implementation # - There's no CMake build script for this library yet # - There's a CMake build script in the master branch but # still does not work for some platforms FetchContent_Declare ( webview GIT_REPOSITORY https://github.com/webview/webview.git GIT_TAG 50e4bcc420abdc7be96a54b7c79934a000b76901 ) FetchContent_GetProperties ( webview ) if ( NOT webview_POPULATED ) # Library does not have a CMake build script # We have to do it ourselves FetchContent_Populate ( webview ) add_library ( webview INTERFACE ) target_sources ( webview INTERFACE ${ webview_SOURCE_DIR } /webview.h ) target_include_directories ( webview INTERFACE ${ webview_SOURCE_DIR } ) # Set compile options # See: https://github.com/webview/webview/blob/master/script/build.sh if ( WIN32 ) target_compile_definitions ( webview INTERFACE WEBVIEW_EDGE ) # See: https://github.com/webview/webview/blob/master/script/build.bat target_link_libraries ( webview INTERFACE \"-mwindows -L./dll/x64 -lwebview -lWebView2Loader\" ) # target_compile_options(...) ? elseif ( APPLE ) target_compile_definitions ( webview INTERFACE WEBVIEW_COCOA ) target_compile_definitions ( webview INTERFACE \"GUI_SOURCE_DIR=\\\" ${ CMAKE_CURRENT_SOURCE_DIR } \\\"\") target_compile_options(webview INTERFACE -Wno-all -Wno-extra -Wno-pedantic -Wno-delete-non-abstract-non-virtual-dtor ) target_link_libraries ( webview INTERFACE \"-framework WebKit\" ) elseif ( UNIX ) target_compile_definitions ( webview INTERFACE WEBVIEW_GTK ) target_compile_options ( webview INTERFACE -Wall -Wextra -Wpedantic ) target_link_libraries ( webview INTERFACE \"$(pkg-config --cflags --libs gtk+-3.0 webkit2gtk-4.0)\" ) endif () endif () # Create example add_executable ( webview_hello webview_hello.cpp ) target_link_libraries ( webview_hello PUBLIC webview )","title":"Webview"},{"location":"guis/webview/#webview","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include <webview.h> #include <iostream> #ifdef _WIN32 int CALLBACK WinMain ( HINSTANCE hInstance , HINSTANCE hPrevInstance , LPSTR lpCmdLine , int nCmdShow ) #else int main () #endif { webview :: webview w ( true , nullptr ); w . set_title ( \"Example\" ); w . set_size ( 480 , 320 , WEBVIEW_HINT_NONE ); w . set_size ( 180 , 120 , WEBVIEW_HINT_MIN ); w . bind ( \"noop\" , []( std :: string s ) -> std :: string { std :: cout << s << std :: endl ; return s ; }); w . bind ( \"add\" , []( std :: string s ) -> std :: string { auto a = std :: stoi ( webview :: json_parse ( s , \"\" , 0 )); auto b = std :: stoi ( webview :: json_parse ( s , \"\" , 1 )); return std :: to_string ( a + b ); }); w . navigate ( R \" ( data:text/html, <!doctype html> <html> <body>hello</body> <script> window.onload = function() { document.body.innerText = `hello, ${navigator.userAgent}`; noop('hello').then(function(res) { console.log('noop res', res); }); add(1, 2).then(function(res) { console.log('add res', res); }); }; </script> </html> ) \" ); w . run (); return 0 ; } Build script: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # This hasn't been tested on all OSs if ( NOT APPLE OR NOT EXPECTED_COMPILER ) return () endif () # Library: https://github.com/zserge/tray # - Webviews are great for GUIs to work cross-platform # - They are also great for mobile GUIs # - So far, there is no good pure C++ library for the same task # - The C++ interface in this repository is still changing often # - The library is quite simple though # - This can serve as inspiration for a C++ implementation # - There's no CMake build script for this library yet # - There's a CMake build script in the master branch but # still does not work for some platforms FetchContent_Declare ( webview GIT_REPOSITORY https://github.com/webview/webview.git GIT_TAG 50e4bcc420abdc7be96a54b7c79934a000b76901 ) FetchContent_GetProperties ( webview ) if ( NOT webview_POPULATED ) # Library does not have a CMake build script # We have to do it ourselves FetchContent_Populate ( webview ) add_library ( webview INTERFACE ) target_sources ( webview INTERFACE ${ webview_SOURCE_DIR } /webview.h ) target_include_directories ( webview INTERFACE ${ webview_SOURCE_DIR } ) # Set compile options # See: https://github.com/webview/webview/blob/master/script/build.sh if ( WIN32 ) target_compile_definitions ( webview INTERFACE WEBVIEW_EDGE ) # See: https://github.com/webview/webview/blob/master/script/build.bat target_link_libraries ( webview INTERFACE \"-mwindows -L./dll/x64 -lwebview -lWebView2Loader\" ) # target_compile_options(...) ? elseif ( APPLE ) target_compile_definitions ( webview INTERFACE WEBVIEW_COCOA ) target_compile_definitions ( webview INTERFACE \"GUI_SOURCE_DIR=\\\" ${ CMAKE_CURRENT_SOURCE_DIR } \\\"\") target_compile_options(webview INTERFACE -Wno-all -Wno-extra -Wno-pedantic -Wno-delete-non-abstract-non-virtual-dtor ) target_link_libraries ( webview INTERFACE \"-framework WebKit\" ) elseif ( UNIX ) target_compile_definitions ( webview INTERFACE WEBVIEW_GTK ) target_compile_options ( webview INTERFACE -Wall -Wextra -Wpedantic ) target_link_libraries ( webview INTERFACE \"$(pkg-config --cflags --libs gtk+-3.0 webkit2gtk-4.0)\" ) endif () endif () # Create example add_executable ( webview_hello webview_hello.cpp ) target_link_libraries ( webview_hello PUBLIC webview )","title":"Webview"},{"location":"installing-a-c20-compiler/","text":"Installing a C++20 compiler Many operating systems don't come with C++20 by default. Follow these instructions to install C++20.","title":"Introduction"},{"location":"installing-a-c20-compiler/#installing-a-c20-compiler","text":"Many operating systems don't come with C++20 by default. Follow these instructions to install C++20.","title":"Installing a C++20 compiler"},{"location":"installing-a-c20-compiler/linux/","text":"Linux Update GCC: 1 2 3 4 5 6 7 sudo apt install build-essential sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt install gcc-10 sudo apt install g++-10 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 10 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-10 10 Set your default compiler with: 1 update-alternatives --config g++","title":"Linux"},{"location":"installing-a-c20-compiler/linux/#linux","text":"Update GCC: 1 2 3 4 5 6 7 sudo apt install build-essential sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt install gcc-10 sudo apt install g++-10 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 10 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-10 10 Set your default compiler with: 1 update-alternatives --config g++","title":"Linux"},{"location":"installing-a-c20-compiler/mac-os/","text":"Mac OS Download a recent version of Clang. 1 2 3 curl --output clang.tar.xz -L https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/clang+llvm-11.0.0-x86_64-apple-darwin.tar.xz mkdir clang tar -xvJf clang.tar.xz -C clang Copy the files to usr/local/ : 1 2 cd clang/clang+llvm-11.0.0-x86_64-apple-darwin sudo cp -R * /usr/local/ Let CMake know that's the compiler you want to use. If you want this to be your default compiler, you can set the CXX environment variable: 1 export CXX = /usr/local/bin/clang++ If you want to use this compiler in a single project, run CMake with these options: 1 -DCMAKE_C_COMPILER = /usr/local/bin/clang -DCMAKE_CXX_COMPILER = /usr/local/bin/clang++ Or tell you IDE to pass these options to CMake:","title":"Mac OS"},{"location":"installing-a-c20-compiler/mac-os/#mac-os","text":"Download a recent version of Clang. 1 2 3 curl --output clang.tar.xz -L https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/clang+llvm-11.0.0-x86_64-apple-darwin.tar.xz mkdir clang tar -xvJf clang.tar.xz -C clang Copy the files to usr/local/ : 1 2 cd clang/clang+llvm-11.0.0-x86_64-apple-darwin sudo cp -R * /usr/local/ Let CMake know that's the compiler you want to use. If you want this to be your default compiler, you can set the CXX environment variable: 1 export CXX = /usr/local/bin/clang++ If you want to use this compiler in a single project, run CMake with these options: 1 -DCMAKE_C_COMPILER = /usr/local/bin/clang -DCMAKE_CXX_COMPILER = /usr/local/bin/clang++ Or tell you IDE to pass these options to CMake:","title":"Mac OS"},{"location":"installing-a-c20-compiler/windows/","text":"Windows Update your Visual Studio Compiler. The most recent version of Visual Studio should include C++20. Warning We still don't know of a script for installing C++20 on Windows from the terminal. This would be especially useful for our build workflow , which has not been testing MSVC since we moved to C++20. Please let us know or open a PR if you know of such a script.","title":"Windows"},{"location":"installing-a-c20-compiler/windows/#windows","text":"Update your Visual Studio Compiler. The most recent version of Visual Studio should include C++20. Warning We still don't know of a script for installing C++20 on Windows from the terminal. This would be especially useful for our build workflow , which has not been testing MSVC since we moved to C++20. Please let us know or open a PR if you know of such a script.","title":"Windows"},{"location":"programming-paradigms/basic-paradigms/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 add_executable ( metaprogramming metaprogramming.cpp ) add_executable ( SFINAE SFINAE.cpp ) add_executable ( polymorphism polymorphism.cpp ) add_executable ( shared_from_this shared_from_this.cpp ) add_executable ( CRTP CRTP.cpp )","title":"Build script"},{"location":"programming-paradigms/basic-paradigms/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 add_executable ( metaprogramming metaprogramming.cpp ) add_executable ( SFINAE SFINAE.cpp ) add_executable ( polymorphism polymorphism.cpp ) add_executable ( shared_from_this shared_from_this.cpp ) add_executable ( CRTP CRTP.cpp )","title":"Build script"},{"location":"programming-paradigms/basic-paradigms/crtp/","text":"CRTP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> template < typename derived > class shape { public : virtual derived clone () { return static_cast < derived > ( * this ); }; }; class square : public shape < square > { public : square () = default ; explicit square ( const shape & ){}; // CRTP: Clone can return a square even though it's derived from shape square clone () override { return * this ; } }; int main () { square a ; square b = a . clone (); std :: cout << \"The square has been cloned as a real square\" << std :: endl ; std :: cout << \"&a: \" << & a << std :: endl ; std :: cout << \"&b: \" << & b << std :: endl ; return 0 ; }","title":"CRTP"},{"location":"programming-paradigms/basic-paradigms/crtp/#crtp","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> template < typename derived > class shape { public : virtual derived clone () { return static_cast < derived > ( * this ); }; }; class square : public shape < square > { public : square () = default ; explicit square ( const shape & ){}; // CRTP: Clone can return a square even though it's derived from shape square clone () override { return * this ; } }; int main () { square a ; square b = a . clone (); std :: cout << \"The square has been cloned as a real square\" << std :: endl ; std :: cout << \"&a: \" << & a << std :: endl ; std :: cout << \"&b: \" << & b << std :: endl ; return 0 ; }","title":"CRTP"},{"location":"programming-paradigms/basic-paradigms/metaprogramming/","text":"Metaprogramming 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <iostream> #include <numeric> #include <string> #include <unordered_map> // Meta-programming with templates template < unsigned n > struct factorial { enum { value = n * factorial < n - 1 >:: value }; }; template <> struct factorial < 0 > { enum { value = 1 }; }; // Meta-programming with constexpr constexpr int factorial2 ( int n ) { return n <= 1 ? 1 : ( n * factorial2 ( n - 1 )); } struct MyClass { template < typename ... Tail > static int count () { return 0 ; } template < char Head , char ... Tail > static int count () { return 1 + count < Tail ... > (); } }; int main () { std :: cout << \"factorial<7>::value : \" << factorial < 7 >:: value << std :: endl ; std :: cout << \"factorial2(7) : \" << factorial2 ( 7 ) << std :: endl ; std :: cout << \"MyClass::count<'f','o','o'>(): \" << MyClass :: count < 'f' , 'o' , 'o' > () << std :: endl ; return 0 ; }","title":"Metaprogramming"},{"location":"programming-paradigms/basic-paradigms/metaprogramming/#metaprogramming","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <iostream> #include <numeric> #include <string> #include <unordered_map> // Meta-programming with templates template < unsigned n > struct factorial { enum { value = n * factorial < n - 1 >:: value }; }; template <> struct factorial < 0 > { enum { value = 1 }; }; // Meta-programming with constexpr constexpr int factorial2 ( int n ) { return n <= 1 ? 1 : ( n * factorial2 ( n - 1 )); } struct MyClass { template < typename ... Tail > static int count () { return 0 ; } template < char Head , char ... Tail > static int count () { return 1 + count < Tail ... > (); } }; int main () { std :: cout << \"factorial<7>::value : \" << factorial < 7 >:: value << std :: endl ; std :: cout << \"factorial2(7) : \" << factorial2 ( 7 ) << std :: endl ; std :: cout << \"MyClass::count<'f','o','o'>(): \" << MyClass :: count < 'f' , 'o' , 'o' > () << std :: endl ; return 0 ; }","title":"Metaprogramming"},{"location":"programming-paradigms/basic-paradigms/polymorphism/","text":"Polymorphism 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 #include <iostream> #include <memory> #include <vector> class shape { public : shape () : _side1 ( 0 ), _side2 ( 0 ) {} explicit shape ( double side ) : _side1 ( side ), _side2 ( side ) {} shape ( double side1 , double side2 ) : _side1 ( side1 ), _side2 ( side2 ) {} virtual ~ shape () = default ; virtual double area () { return 0 ; } double _side1 ; double _side2 ; bool operator == ( const shape & rhs ) const { return _side1 == rhs . _side1 && _side2 == rhs . _side2 ; } bool operator != ( const shape & rhs ) const { return ! ( rhs == * this ); } }; class triangle : public shape { public : using shape :: shape ; ~ triangle () override = default ; double area () override { return this -> _side1 * this -> _side2 / 2 ; } }; class square : public shape { public : using shape :: shape ; ~ square () override = default ; double area () override { return this -> _side1 * this -> _side2 ; } }; std :: vector < shape *> load_shapes_old_cpp () { std :: vector < shape *> v ( 30 ); for ( size_t i = 0 ; i < v . size (); ++ i ) { if ( i % 2 ) { v [ i ] = new triangle ( static_cast < double > ( i + 30 )); } else { v [ i ] = new square ( static_cast < double > ( i + 30 )); } } return v ; } std :: vector < std :: shared_ptr < shape >> load_shapes_modern_cpp () { std :: vector < std :: shared_ptr < shape >> v ( 30 ); for ( size_t i = 0 ; i < v . size (); ++ i ) { if ( i % 2 ) { v [ i ] = std :: make_shared < triangle > ( i + 30 ); } else { v [ i ] = std :: make_shared < square > ( i + 30 ); } } return v ; } int main () { // using raw pointers // - Don't do that shape * rp = new square ( 42 ); std :: vector < shape *> rv = load_shapes_old_cpp (); for ( std :: vector < shape *>:: iterator i = rv . begin (); i != rv . end (); ++ i ) { if ( dynamic_cast < triangle *> ( * i )) { std :: cout << \"This is a triangle\" << std :: endl ; } else if ( dynamic_cast < square *> ( * i )) { std :: cout << \"This is a square\" << std :: endl ; } else if ( dynamic_cast < shape *> ( * i )) { std :: cout << \"This is a shape\" << std :: endl ; } if ( * i && ** i == * rp ) { std :: cout << \"It has the same area as rp: \" << ( * i ) -> area () << std :: endl ; } } /* for (std::vector<shape *>::iterator i = rv.begin(); i != rv.end(); ++i) { delete *i; // not exception safe } delete rp; */ // Smart pointers std :: shared_ptr < shape > p = std :: make_shared < square > ( 42 ); std :: vector < std :: shared_ptr < shape >> v = load_shapes_modern_cpp (); for ( std :: shared_ptr < shape > & item : v ) { if ( dynamic_cast < triangle *> ( item . get ())) { std :: cout << \"This is a triangle\" << std :: endl ; } else if ( dynamic_cast < square *> ( item . get ())) { std :: cout << \"This is a square\" << std :: endl ; } else if ( dynamic_cast < shape *> ( item . get ())) { std :: cout << \"This is a shape\" << std :: endl ; } if ( item && * item == * p ) { std :: cout << \"It has the same area as p: \" << item -> area () << std :: endl ; } } return 0 ; }","title":"Polymorphism"},{"location":"programming-paradigms/basic-paradigms/polymorphism/#polymorphism","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 #include <iostream> #include <memory> #include <vector> class shape { public : shape () : _side1 ( 0 ), _side2 ( 0 ) {} explicit shape ( double side ) : _side1 ( side ), _side2 ( side ) {} shape ( double side1 , double side2 ) : _side1 ( side1 ), _side2 ( side2 ) {} virtual ~ shape () = default ; virtual double area () { return 0 ; } double _side1 ; double _side2 ; bool operator == ( const shape & rhs ) const { return _side1 == rhs . _side1 && _side2 == rhs . _side2 ; } bool operator != ( const shape & rhs ) const { return ! ( rhs == * this ); } }; class triangle : public shape { public : using shape :: shape ; ~ triangle () override = default ; double area () override { return this -> _side1 * this -> _side2 / 2 ; } }; class square : public shape { public : using shape :: shape ; ~ square () override = default ; double area () override { return this -> _side1 * this -> _side2 ; } }; std :: vector < shape *> load_shapes_old_cpp () { std :: vector < shape *> v ( 30 ); for ( size_t i = 0 ; i < v . size (); ++ i ) { if ( i % 2 ) { v [ i ] = new triangle ( static_cast < double > ( i + 30 )); } else { v [ i ] = new square ( static_cast < double > ( i + 30 )); } } return v ; } std :: vector < std :: shared_ptr < shape >> load_shapes_modern_cpp () { std :: vector < std :: shared_ptr < shape >> v ( 30 ); for ( size_t i = 0 ; i < v . size (); ++ i ) { if ( i % 2 ) { v [ i ] = std :: make_shared < triangle > ( i + 30 ); } else { v [ i ] = std :: make_shared < square > ( i + 30 ); } } return v ; } int main () { // using raw pointers // - Don't do that shape * rp = new square ( 42 ); std :: vector < shape *> rv = load_shapes_old_cpp (); for ( std :: vector < shape *>:: iterator i = rv . begin (); i != rv . end (); ++ i ) { if ( dynamic_cast < triangle *> ( * i )) { std :: cout << \"This is a triangle\" << std :: endl ; } else if ( dynamic_cast < square *> ( * i )) { std :: cout << \"This is a square\" << std :: endl ; } else if ( dynamic_cast < shape *> ( * i )) { std :: cout << \"This is a shape\" << std :: endl ; } if ( * i && ** i == * rp ) { std :: cout << \"It has the same area as rp: \" << ( * i ) -> area () << std :: endl ; } } /* for (std::vector<shape *>::iterator i = rv.begin(); i != rv.end(); ++i) { delete *i; // not exception safe } delete rp; */ // Smart pointers std :: shared_ptr < shape > p = std :: make_shared < square > ( 42 ); std :: vector < std :: shared_ptr < shape >> v = load_shapes_modern_cpp (); for ( std :: shared_ptr < shape > & item : v ) { if ( dynamic_cast < triangle *> ( item . get ())) { std :: cout << \"This is a triangle\" << std :: endl ; } else if ( dynamic_cast < square *> ( item . get ())) { std :: cout << \"This is a square\" << std :: endl ; } else if ( dynamic_cast < shape *> ( item . get ())) { std :: cout << \"This is a shape\" << std :: endl ; } if ( item && * item == * p ) { std :: cout << \"It has the same area as p: \" << item -> area () << std :: endl ; } } return 0 ; }","title":"Polymorphism"},{"location":"programming-paradigms/basic-paradigms/sfinae/","text":"SFINAE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 #include <iostream> #include <numeric> #include <type_traits> #include <array> // 1. the return type (bool) is only valid if T is an integral type: template < class T > typename std :: enable_if < std :: is_integral < T >:: value , bool >:: type is_odd ( T i ) { return bool ( i % 2 ); } // 2. the second template argument is only valid if T is an integral type: template < class T , class = typename std :: enable_if < std :: is_integral < T >:: value >:: type > bool is_even ( T i ) { return ! bool ( i % 2 ); } struct A {}; class B {}; union C { int i ; float f ; }; enum class D { x , y , z }; int main () { std :: cout << \"Modern C++:\" << std :: endl ; { // Run-time SFINAE std :: cout << \"int: \" << std :: is_floating_point < int >:: value << std :: endl ; std :: cout << \"float: \" << std :: is_floating_point < float >:: value << std :: endl ; std :: cout << \"const double: \" << std :: is_floating_point < const double >:: value << std :: endl ; std :: cout << \"int: \" << std :: is_array < int >:: value << std :: endl ; std :: cout << \"int[3]: \" << std :: is_array < int [ 3 ] >:: value << std :: endl ; std :: cout << \"array<int,3>: \" << std :: is_array < std :: array < int , 3 >>:: value << std :: endl ; std :: cout << \"string: \" << std :: is_array < std :: string >:: value << std :: endl ; std :: cout << \"string[3]: \" << std :: is_array < std :: string [ 3 ] >:: value << std :: endl ; std :: cout << \"A: \" << std :: is_class < A >:: value << std :: endl ; std :: cout << \"B: \" << std :: is_class < B >:: value << std :: endl ; std :: cout << \"C: \" << std :: is_class < C >:: value << std :: endl ; std :: cout << \"D: \" << std :: is_class < D >:: value << std :: endl ; std :: cout << \"A: \" << std :: is_enum < A >:: value << std :: endl ; std :: cout << \"B: \" << std :: is_enum < B >:: value << std :: endl ; std :: cout << \"C: \" << std :: is_enum < C >:: value << std :: endl ; std :: cout << \"is_odd: \" << std :: is_function < decltype ( is_odd < int > ) >:: value << std :: endl ; std :: cout << \"id_even: \" << std :: is_function < decltype ( is_even < int > ) >:: value << std :: endl ; std :: cout << \"decltype(c): \" << std :: is_function < C >:: value << std :: endl ; std :: cout << \"char: \" << std :: is_integral < char >:: value << std :: endl ; std :: cout << \"int: \" << std :: is_integral < int >:: value << std :: endl ; std :: cout << \"float: \" << std :: is_integral < float >:: value << std :: endl ; std :: cout << \"int: \" << std :: is_pointer < int >:: value << std :: endl ; std :: cout << \"int*: \" << std :: is_pointer < int *>:: value << std :: endl ; std :: cout << \"int**: \" << std :: is_pointer < int **>:: value << std :: endl ; std :: cout << \"int(*)(int): \" << std :: is_pointer < int ( * )( int ) >:: value << std :: endl ; std :: cout << \"int: \" << std :: is_scalar < int >:: value << std :: endl ; std :: cout << \"A: \" << std :: is_scalar < A >:: value << std :: endl ; std :: cout << \"A&: \" << std :: is_scalar < A &>:: value << std :: endl ; std :: cout << \"A*: \" << std :: is_scalar < A *>:: value << std :: endl ; std :: cout << \"int(int): \" << std :: is_scalar < int ( int ) >:: value << std :: endl ; std :: cout << \"int(*)(int): \" << std :: is_scalar < int ( * )( int ) >:: value << std :: endl ; std :: cout << \"char: \" << std :: is_arithmetic < char >:: value << std :: endl ; std :: cout << \"float: \" << std :: is_arithmetic < float >:: value << std :: endl ; std :: cout << \"float*: \" << std :: is_arithmetic < float *>:: value << std :: endl ; // SFINAE on functions std :: cout << \"i is odd: \" << is_odd ( 1 ) << std :: endl ; // is_odd(1.2) wouldn't work std :: cout << \"i is even: \" << is_even ( 1 ) << std :: endl ; // is_even(1.2) wouldn't work } return 0 ; } /* // Concepts are only available in C++20 (not the final version yet) // We have to use SFINAE (Substitution error is not a failure) in the meanwhile template <class T> concept bool EqualityComparable() { return requires(T a, T b) { {a == b} -> Boolean; // Boolean is the concept defining a type usable in boolean context {a != b} -> Boolean; }; } void f(const EqualityComparable&); // constrained function template declaration https://www.boost.org/doc/libs/1_60_0/libs/concept_check/using_concept_check.htm */","title":"SFINAE"},{"location":"programming-paradigms/basic-paradigms/sfinae/#sfinae","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 #include <iostream> #include <numeric> #include <type_traits> #include <array> // 1. the return type (bool) is only valid if T is an integral type: template < class T > typename std :: enable_if < std :: is_integral < T >:: value , bool >:: type is_odd ( T i ) { return bool ( i % 2 ); } // 2. the second template argument is only valid if T is an integral type: template < class T , class = typename std :: enable_if < std :: is_integral < T >:: value >:: type > bool is_even ( T i ) { return ! bool ( i % 2 ); } struct A {}; class B {}; union C { int i ; float f ; }; enum class D { x , y , z }; int main () { std :: cout << \"Modern C++:\" << std :: endl ; { // Run-time SFINAE std :: cout << \"int: \" << std :: is_floating_point < int >:: value << std :: endl ; std :: cout << \"float: \" << std :: is_floating_point < float >:: value << std :: endl ; std :: cout << \"const double: \" << std :: is_floating_point < const double >:: value << std :: endl ; std :: cout << \"int: \" << std :: is_array < int >:: value << std :: endl ; std :: cout << \"int[3]: \" << std :: is_array < int [ 3 ] >:: value << std :: endl ; std :: cout << \"array<int,3>: \" << std :: is_array < std :: array < int , 3 >>:: value << std :: endl ; std :: cout << \"string: \" << std :: is_array < std :: string >:: value << std :: endl ; std :: cout << \"string[3]: \" << std :: is_array < std :: string [ 3 ] >:: value << std :: endl ; std :: cout << \"A: \" << std :: is_class < A >:: value << std :: endl ; std :: cout << \"B: \" << std :: is_class < B >:: value << std :: endl ; std :: cout << \"C: \" << std :: is_class < C >:: value << std :: endl ; std :: cout << \"D: \" << std :: is_class < D >:: value << std :: endl ; std :: cout << \"A: \" << std :: is_enum < A >:: value << std :: endl ; std :: cout << \"B: \" << std :: is_enum < B >:: value << std :: endl ; std :: cout << \"C: \" << std :: is_enum < C >:: value << std :: endl ; std :: cout << \"is_odd: \" << std :: is_function < decltype ( is_odd < int > ) >:: value << std :: endl ; std :: cout << \"id_even: \" << std :: is_function < decltype ( is_even < int > ) >:: value << std :: endl ; std :: cout << \"decltype(c): \" << std :: is_function < C >:: value << std :: endl ; std :: cout << \"char: \" << std :: is_integral < char >:: value << std :: endl ; std :: cout << \"int: \" << std :: is_integral < int >:: value << std :: endl ; std :: cout << \"float: \" << std :: is_integral < float >:: value << std :: endl ; std :: cout << \"int: \" << std :: is_pointer < int >:: value << std :: endl ; std :: cout << \"int*: \" << std :: is_pointer < int *>:: value << std :: endl ; std :: cout << \"int**: \" << std :: is_pointer < int **>:: value << std :: endl ; std :: cout << \"int(*)(int): \" << std :: is_pointer < int ( * )( int ) >:: value << std :: endl ; std :: cout << \"int: \" << std :: is_scalar < int >:: value << std :: endl ; std :: cout << \"A: \" << std :: is_scalar < A >:: value << std :: endl ; std :: cout << \"A&: \" << std :: is_scalar < A &>:: value << std :: endl ; std :: cout << \"A*: \" << std :: is_scalar < A *>:: value << std :: endl ; std :: cout << \"int(int): \" << std :: is_scalar < int ( int ) >:: value << std :: endl ; std :: cout << \"int(*)(int): \" << std :: is_scalar < int ( * )( int ) >:: value << std :: endl ; std :: cout << \"char: \" << std :: is_arithmetic < char >:: value << std :: endl ; std :: cout << \"float: \" << std :: is_arithmetic < float >:: value << std :: endl ; std :: cout << \"float*: \" << std :: is_arithmetic < float *>:: value << std :: endl ; // SFINAE on functions std :: cout << \"i is odd: \" << is_odd ( 1 ) << std :: endl ; // is_odd(1.2) wouldn't work std :: cout << \"i is even: \" << is_even ( 1 ) << std :: endl ; // is_even(1.2) wouldn't work } return 0 ; } /* // Concepts are only available in C++20 (not the final version yet) // We have to use SFINAE (Substitution error is not a failure) in the meanwhile template <class T> concept bool EqualityComparable() { return requires(T a, T b) { {a == b} -> Boolean; // Boolean is the concept defining a type usable in boolean context {a != b} -> Boolean; }; } void f(const EqualityComparable&); // constrained function template declaration https://www.boost.org/doc/libs/1_60_0/libs/concept_check/using_concept_check.htm */","title":"SFINAE"},{"location":"programming-paradigms/basic-paradigms/shared-from-this/","text":"Shared from this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include <cassert> #include <iostream> #include <memory> #include <optional> #include <string> #include <thread> #include <variant> #include <vector> class hello_printer : public std :: enable_shared_from_this < hello_printer > { public : void say_hello () { std :: cout << \"Hello, World!\" << std :: endl ; } static std :: shared_ptr < hello_printer > create () { return std :: make_shared < hello_printer > (); } }; class hello_class : public std :: shared_ptr < hello_printer > { public : hello_class () : std :: shared_ptr < hello_printer > ( std :: make_shared < hello_printer > ()) {} hello_class ( hello_class & rhs ) : std :: shared_ptr < hello_printer > ( rhs -> shared_from_this ()) {} }; int main () { // y points to a hello_printer std :: shared_ptr < hello_printer > y = std :: make_shared < hello_printer > (); y -> say_hello (); std :: cout << \"y.get() = \" << y . get () << std :: endl ; std :: cout << \"&y = \" << & y << std :: endl ; // z will also point to the same object as y std :: shared_ptr < hello_printer > y2 = y -> shared_from_this (); y2 -> say_hello (); std :: cout << \"y2.get() = \" << y2 . get () << std :: endl ; std :: cout << \"&y2 = \" << & y2 << std :: endl ; // the create function makes it more convenient to create a new pointer to a // hello_printer auto z = hello_printer :: create (); z -> say_hello (); std :: cout << \"z.get() = \" << z . get () << std :: endl ; std :: cout << \"&z = \" << & z << std :: endl ; // x IS a hello_printer (instead of just pointing to one) hello_printer x ; x . say_hello (); std :: cout << \"&x = \" << & x << std :: endl ; // We cannot get a shared pointer from x because x is not a pointer. It is // an object on the stack. try { std :: shared_ptr < hello_printer > x2 = x . shared_from_this (); x2 -> say_hello (); std :: cout << \"x2.get() = \" << x2 . get () << std :: endl ; std :: cout << \"&x2 = \" << & x2 << std :: endl ; } catch ( std :: exception & e ) { std :: cout << \"Cannot create a pointer from x: \" << e . what () << std :: endl ; } // However, we can encapsulate the basic hello_printer into another class // This second class object in the stack will look like it's not a pointer // But, in fact, it's just an usual pointer to a hello class // This is making C++ only work with references without the user knowing // about it hello_class x2 ; x2 -> say_hello (); std :: cout << \"x2.get() = \" << x2 . get () << std :: endl ; std :: cout << \"&x2 = \" << & x2 << std :: endl ; // x3 can now be copied from x2 because their are just wrappers from the // shared_ptrs the real thing is implemented in hello_printer hello_class x3 = x2 ; x3 -> say_hello (); std :: cout << \"x3.get() = \" << x3 . get () << std :: endl ; std :: cout << \"&x3 = \" << & x3 << std :: endl ; return 0 ; }","title":"Shared from this"},{"location":"programming-paradigms/basic-paradigms/shared-from-this/#shared-from-this","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 #include <cassert> #include <iostream> #include <memory> #include <optional> #include <string> #include <thread> #include <variant> #include <vector> class hello_printer : public std :: enable_shared_from_this < hello_printer > { public : void say_hello () { std :: cout << \"Hello, World!\" << std :: endl ; } static std :: shared_ptr < hello_printer > create () { return std :: make_shared < hello_printer > (); } }; class hello_class : public std :: shared_ptr < hello_printer > { public : hello_class () : std :: shared_ptr < hello_printer > ( std :: make_shared < hello_printer > ()) {} hello_class ( hello_class & rhs ) : std :: shared_ptr < hello_printer > ( rhs -> shared_from_this ()) {} }; int main () { // y points to a hello_printer std :: shared_ptr < hello_printer > y = std :: make_shared < hello_printer > (); y -> say_hello (); std :: cout << \"y.get() = \" << y . get () << std :: endl ; std :: cout << \"&y = \" << & y << std :: endl ; // z will also point to the same object as y std :: shared_ptr < hello_printer > y2 = y -> shared_from_this (); y2 -> say_hello (); std :: cout << \"y2.get() = \" << y2 . get () << std :: endl ; std :: cout << \"&y2 = \" << & y2 << std :: endl ; // the create function makes it more convenient to create a new pointer to a // hello_printer auto z = hello_printer :: create (); z -> say_hello (); std :: cout << \"z.get() = \" << z . get () << std :: endl ; std :: cout << \"&z = \" << & z << std :: endl ; // x IS a hello_printer (instead of just pointing to one) hello_printer x ; x . say_hello (); std :: cout << \"&x = \" << & x << std :: endl ; // We cannot get a shared pointer from x because x is not a pointer. It is // an object on the stack. try { std :: shared_ptr < hello_printer > x2 = x . shared_from_this (); x2 -> say_hello (); std :: cout << \"x2.get() = \" << x2 . get () << std :: endl ; std :: cout << \"&x2 = \" << & x2 << std :: endl ; } catch ( std :: exception & e ) { std :: cout << \"Cannot create a pointer from x: \" << e . what () << std :: endl ; } // However, we can encapsulate the basic hello_printer into another class // This second class object in the stack will look like it's not a pointer // But, in fact, it's just an usual pointer to a hello class // This is making C++ only work with references without the user knowing // about it hello_class x2 ; x2 -> say_hello (); std :: cout << \"x2.get() = \" << x2 . get () << std :: endl ; std :: cout << \"&x2 = \" << & x2 << std :: endl ; // x3 can now be copied from x2 because their are just wrappers from the // shared_ptrs the real thing is implemented in hello_printer hello_class x3 = x2 ; x3 -> say_hello (); std :: cout << \"x3.get() = \" << x3 . get () << std :: endl ; std :: cout << \"&x3 = \" << & x3 << std :: endl ; return 0 ; }","title":"Shared from this"},{"location":"programming-paradigms/parallelism/async/","text":"Async++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <async++.h> #include <iostream> int main () { auto task1 = async :: spawn ( [] { std :: cout << \"Task 1 executes asynchronously\" << std :: endl ; }); auto task2 = async :: spawn ([]() -> int { std :: cout << \"Task 2 executes in parallel with task 1\" << std :: endl ; return 42 ; }); auto task3 = task2 . then ([]( int value ) -> int { std :: cout << \"Task 3 executes after task 2, which returned \" << value << std :: endl ; return value * 3 ; }); auto task4 = async :: when_all ( task1 , task3 ); auto task5 = task4 . then ([]( std :: tuple < async :: task < void > , async :: task < int >> results ) { std :: cout << \"Task 5 executes after tasks 1 and 3. Task 3 returned \" << std :: get < 1 > ( results ). get () << std :: endl ; }); task5 . get (); std :: cout << \"Task 5 has completed\" << std :: endl ; async :: parallel_invoke ( [] { std :: cout << \"This is executed in parallel...\" << std :: endl ; }, [] { std :: cout << \"with this\" << std :: endl ; }); async :: parallel_for ( async :: irange ( 0 , 5 ), []( int x ) { std :: cout << x ; }); std :: cout << std :: endl ; int r = async :: parallel_reduce ({ 1 , 2 , 3 , 4 }, 0 , []( int x , int y ) { return x + y ; }); std :: cout << \"The sum of {1, 2, 3, 4} is \" << r << std :: endl ; }","title":"Async++"},{"location":"programming-paradigms/parallelism/async/#async","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <async++.h> #include <iostream> int main () { auto task1 = async :: spawn ( [] { std :: cout << \"Task 1 executes asynchronously\" << std :: endl ; }); auto task2 = async :: spawn ([]() -> int { std :: cout << \"Task 2 executes in parallel with task 1\" << std :: endl ; return 42 ; }); auto task3 = task2 . then ([]( int value ) -> int { std :: cout << \"Task 3 executes after task 2, which returned \" << value << std :: endl ; return value * 3 ; }); auto task4 = async :: when_all ( task1 , task3 ); auto task5 = task4 . then ([]( std :: tuple < async :: task < void > , async :: task < int >> results ) { std :: cout << \"Task 5 executes after tasks 1 and 3. Task 3 returned \" << std :: get < 1 > ( results ). get () << std :: endl ; }); task5 . get (); std :: cout << \"Task 5 has completed\" << std :: endl ; async :: parallel_invoke ( [] { std :: cout << \"This is executed in parallel...\" << std :: endl ; }, [] { std :: cout << \"with this\" << std :: endl ; }); async :: parallel_for ( async :: irange ( 0 , 5 ), []( int x ) { std :: cout << x ; }); std :: cout << std :: endl ; int r = async :: parallel_reduce ({ 1 , 2 , 3 , 4 }, 0 , []( int x , int y ) { return x + y ; }); std :: cout << \"The sum of {1, 2, 3, 4} is \" << r << std :: endl ; }","title":"Async++"},{"location":"programming-paradigms/parallelism/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # Threads find_package ( Threads ) find_package ( Execution ) if ( Execution_FOUND ) add_executable ( policies policies.cpp ) target_link_libraries ( policies PUBLIC std::execution Threads::Threads ) else () message ( \"Your compiler does not support *execution* yet\" ) endif () add_executable ( multithreading multithreading.cpp ) target_link_libraries ( multithreading PUBLIC Threads::Threads ) # ASIO FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-18-1 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () # The executor libraries in ASIO do not have lots of convenience functions # but they are a good reference for the executor proposal coming to C++23 add_executable ( executors executors.cpp ) target_link_libraries ( executors asio ) add_executable ( timers timers.cpp ) target_link_libraries ( timers asio ) add_executable ( signals signals.cpp ) target_link_libraries ( signals asio ) # Async++ has good convenience functions/algorithms for parallel computing # But it's about to be completely replaced by the traditional executors in C++23 # Replace this library as soon as we have an alternative based on executors # Async++ # The build script has a problem because it assumes stdlib++ # whenever the platform is APPLE. The user might not be using stdlib++ if ( EXPECTED_COMPILER ) FetchContent_Declare ( asyncplusplus GIT_REPOSITORY https://github.com/Amanieu/asyncplusplus.git GIT_TAG v1.1 ) FetchContent_MakeAvailable ( asyncplusplus ) add_executable ( async_pools async_pools.cpp ) target_link_libraries ( async_pools PUBLIC Async++ ) endif ()","title":"Build script"},{"location":"programming-paradigms/parallelism/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 # Threads find_package ( Threads ) find_package ( Execution ) if ( Execution_FOUND ) add_executable ( policies policies.cpp ) target_link_libraries ( policies PUBLIC std::execution Threads::Threads ) else () message ( \"Your compiler does not support *execution* yet\" ) endif () add_executable ( multithreading multithreading.cpp ) target_link_libraries ( multithreading PUBLIC Threads::Threads ) # ASIO FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-18-1 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () # The executor libraries in ASIO do not have lots of convenience functions # but they are a good reference for the executor proposal coming to C++23 add_executable ( executors executors.cpp ) target_link_libraries ( executors asio ) add_executable ( timers timers.cpp ) target_link_libraries ( timers asio ) add_executable ( signals signals.cpp ) target_link_libraries ( signals asio ) # Async++ has good convenience functions/algorithms for parallel computing # But it's about to be completely replaced by the traditional executors in C++23 # Replace this library as soon as we have an alternative based on executors # Async++ # The build script has a problem because it assumes stdlib++ # whenever the platform is APPLE. The user might not be using stdlib++ if ( EXPECTED_COMPILER ) FetchContent_Declare ( asyncplusplus GIT_REPOSITORY https://github.com/Amanieu/asyncplusplus.git GIT_TAG v1.1 ) FetchContent_MakeAvailable ( asyncplusplus ) add_executable ( async_pools async_pools.cpp ) target_link_libraries ( async_pools PUBLIC Async++ ) endif ()","title":"Build script"},{"location":"programming-paradigms/parallelism/execution-policies/","text":"Execution Policies 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <execution> #include <iostream> int main () { // Execution may not be parallelized std :: vector < int > x { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: seq , x . begin (), x . end ()); std :: copy ( x . begin (), x . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << std :: endl ; // Execution may be parallelized std :: vector < int > y { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: par , y . begin (), y . end ()); std :: copy ( y . begin (), y . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << std :: endl ; // Execution may be parallelized, vectorized, or migrated across threads std :: vector < int > z { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: par_unseq , z . begin (), z . end ()); std :: copy ( z . begin (), z . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << std :: endl ; // Execution may be vectorized std :: vector < int > w { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: unseq , w . begin (), w . end ()); std :: copy ( w . begin (), w . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << std :: endl ; return 0 ; }","title":"Execution Policies"},{"location":"programming-paradigms/parallelism/execution-policies/#execution-policies","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <execution> #include <iostream> int main () { // Execution may not be parallelized std :: vector < int > x { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: seq , x . begin (), x . end ()); std :: copy ( x . begin (), x . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << std :: endl ; // Execution may be parallelized std :: vector < int > y { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: par , y . begin (), y . end ()); std :: copy ( y . begin (), y . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << std :: endl ; // Execution may be parallelized, vectorized, or migrated across threads std :: vector < int > z { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: par_unseq , z . begin (), z . end ()); std :: copy ( z . begin (), z . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << std :: endl ; // Execution may be vectorized std :: vector < int > w { 5 , 7 , 6 , 4 , 8 , 2 }; std :: sort ( std :: execution :: unseq , w . begin (), w . end ()); std :: copy ( w . begin (), w . end (), std :: ostream_iterator < int > { std :: cout , \" \" }); std :: cout << std :: endl ; return 0 ; }","title":"Execution Policies"},{"location":"programming-paradigms/parallelism/executors/","text":"Executors 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 #include <asio.hpp> #include <future> #include <iostream> template < class T > auto make_ready_future ( T && value ) { std :: promise < std :: decay_t < T >> result_promise ; std :: future < std :: decay_t < T >> result_future = result_promise . get_future (); result_promise . set_value ( value ); return result_future ; } template < class FN , class Iterator > auto parallel_reduce ( auto ex , Iterator begin , Iterator end , FN fn ) { auto second = std :: next ( begin ); const bool is_single_element = second == end ; const bool is_single_pair = ! is_single_element && ( std :: next ( second ) == end ); if ( is_single_element ) { return make_ready_future ( * begin ); } else if ( is_single_pair ) { return asio :: post ( ex , asio :: use_future ([ begin , second , & fn ] { return fn ( * begin , * second ); })); } else { // we would probably add an heuristic here for small ranges size_t n = std :: distance ( begin , end ); auto half = std :: next ( begin , n / 2 ); auto lhs = parallel_reduce ( ex , begin , half , fn ); auto rhs = parallel_reduce ( ex , half , end , fn ); return make_ready_future ( lhs . get () + rhs . get ()); } } int main () { // Some references: // - https://think-async.com/Asio/ // - https://think-async.com/Asio/asio-1.18.1/doc/asio/std_executors.html // - https://github.com/chriskohlhoff/executors // - https://taskflow.github.io/taskflow/index.html // - Read the unit tests, such as asio/src/tests/unit/thread_pool.cpp /* * Executors and execution contexts */ // Creating an execution context: a thread pool // - Execution context: place where we can execute functions // - A thread pool is an execution context. // An execution context is: // - Usually long lived. // - Non-copyable. // - May contain additional state, such as timers, and threads asio :: thread_pool pool ; // Creating an executor from an executor context // - Executor: set of rules governing where, when and how to run // a function object // - A thread pool has an executor. // - Its executor rule is: Run function objects in the pool and nowhere // else. An executor is: // - May be long or short lived. // - Lightweight and copyable. // - May be customized on a fine-grained basis, such as exception behavior, // and order auto ex = pool . executor (); std :: cout << ( & pool == & ex . context ()) << std :: endl ; // Executing simple function ex . execute ([ & ex ] { std :: cout << \"Task in executor\" << std :: endl ; std :: cout << \"ex.running_in_this_thread(): \" << ex . running_in_this_thread () << std :: endl ; }); std :: cout << \"ex.running_in_this_thread(): \" << ex . running_in_this_thread () << std :: endl ; /* * Queueing tasks */ // Executing directly in the thread pool // Execution behaviour according to eagerness: // - https://github.com/chriskohlhoff/executors // - Dispatch: Run the function object immediately if possible. // Most eager operation. // Might run before dispatch returns. // If inside pool, run immediately. // If outside pool, add to queue. asio :: dispatch ( ex , [ & ex ] { // This runs before finishing the function asio :: dispatch ( ex , [] { std :: cout << \"dispatch b\" << std :: endl ; }); std :: cout << \"dispatch a\" << std :: endl ; }); // - Post: Submit the function for later execution. // Never immediately in the same thread. // Always adds to pool queue. // Never blocking. asio :: post ( ex , [ & ex ] { // This will all run in parallel asio :: post ( ex , [] { std :: cout << \"post b\" << std :: endl ; }); asio :: post ( ex , [] { std :: cout << \"post c\" << std :: endl ; }); std :: cout << \"post a\" << std :: endl ; }); // - Defer: Submit the function for later execution. // Least eager. // Implies relationship between calling thread and function. // Used when function is a continuation to the calling function. // The function is added to the queue after the current function // ends. If inside pool, adds to a thread local queue. If outside // pool, add to queue. Thread posting might immediately run it. // Potentially blocking. asio :: defer ( ex , [ & ex ] { // This will all run only when this function is over asio :: defer ( ex , [] { std :: cout << \"defer b\" << std :: endl ; }); std :: cout << \"defer a\" << std :: endl ; }); /* * Returning values or waiting on tasks */ // Returning value std :: future < int > r1 = asio :: post ( ex , asio :: use_future ([]() { return 2 ; })); std :: cout << \"Result = \" << r1 . get () << std :: endl ; // Just waiting for task std :: future < void > r2 = asio :: post ( ex , asio :: use_future ([]() { std :: cout << \"Print message\" ; })); r2 . get (); std :: cout << \" -> Message printed\" << std :: endl ; /* * Limiting concurrency */ // Create an strand executor // - A strand is an executor and an executor adapter // - Its rule is: Run function objects according to the underlying // executor\u2019s rules, but also run them in FIFO order and not // concurrently. asio :: strand < asio :: thread_pool :: executor_type > ex2 ( ex ); ex2 . execute ([] { std :: cout << \"FIFO-1a\" << std :: endl ; }); asio :: post ( ex2 , [] { std :: cout << \"FIFO-1b\" << std :: endl ; }); auto fifo_r = asio :: post ( ex2 , asio :: use_future ([] { std :: cout << \"FIFO-1c\" << std :: endl ; })); fifo_r . wait (); std :: cout << \"FIFO tasks done\" << std :: endl ; // Creating a promise std :: promise < int > function_promise ; std :: future < int > function_future_result = function_promise . get_future (); auto fn2 = [ & ] { std :: cout << \"Task 2 executes asynchronously\" << std :: endl ; // \"return\" 2 by setting the promise value function_promise . set_value ( 2 ); }; ex . execute ( fn2 ); std :: cout << \"function_future_result.get(): \" << function_future_result . get () << std :: endl ; // Automating the process of creating a promise auto fn3 = [ & ] { std :: cout << \"Task 3 executes asynchronously\" << std :: endl ; return 3 ; }; std :: promise < int > function_promise2 ; std :: future < int > function_future2 = function_promise2 . get_future (); auto package = [ & ]( auto fn ) { return [ fn , & function_promise2 ] { function_promise2 . set_value ( fn ()); }; }; ex . execute ( package ( fn3 )); std :: cout << \"function_future2.get(): \" << function_future2 . get () << std :: endl ; /* * Ordering tasks */ auto task1 = asio :: post ( asio :: use_future ( [] { std :: cout << \"Task 1 executes asynchronously\" << std :: endl ; })); auto task2 = asio :: post ( asio :: use_future ([]() { std :: cout << \"Task 2 executes in parallel with task 1\" << std :: endl ; return 42 ; })); // something like task3 = task2.then([](int task2_output){...}); auto task3 = asio :: post ( asio :: use_future ([ & ]() { int task2_output = task2 . get (); std :: cout << \"Task 3 executes after task 2, which returned \" << task2_output << std :: endl ; return task2_output * 3 ; })); // something like task4 = when_all(task1, task3); auto task4 = asio :: post ( asio :: use_future ([ & ]() { task1 . wait (); auto task3_output = task3 . get (); return task3_output ; })); // something like task5 = task4.then([](std::tuple<void, int>)) auto task5 = asio :: post ( asio :: use_future ([ & ]() { auto task4_output = task4 . get (); std :: cout << \"Task 5 executes after tasks 1 and 3. Task 3 returned \" << task4_output << \".\" << std :: endl ; })); task5 . get (); std :: cout << \"Task 5 has completed\" << std :: endl ; /* * Making threads sleep */ // When the threads are sleeping, they do not open room for another // thread in the thread pool. // Thus, it's sometimes useful to have extra threads depending on // what they are doing. for ( int i = 0 ; i < 20 ; ++ i ) { asio :: post ( ex , [ i ] { std :: cout << \"Thread \" << i << \" going to sleep\" << std :: endl ; std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); std :: cout << \"Thread \" << i << \" awake\" << std :: endl ; }); } /* * Parallel algorithms */ auto parallel_invoke = []( auto ex , auto fn1 , auto fn2 ) { asio :: post ( ex , fn1 ); asio :: post ( ex , fn2 ); }; parallel_invoke ( ex , [] { std :: cout << \"parallel_invoke a\" << std :: endl ; }, [] { std :: cout << \"parallel_invoke b\" << std :: endl ; }); auto parallel_for = []( auto ex , auto begin , auto end , auto fn ) { while ( begin != end ) { asio :: post ( ex , [ begin , & fn ] { fn ( * begin ); }); ++ begin ; } }; std :: vector < int > v = { 0 , 1 , 2 , 3 , 4 , 5 }; parallel_for ( ex , v . begin (), v . end (), []( int x ) { std :: cout << x ; }); std :: cout << std :: endl ; std :: future < int > r = parallel_reduce ( ex , v . begin (), v . end (), []( int x , int y ) { return x + y ; }); std :: cout << \"The sum of {0, 1, 2, 3, 4, 5} is \" << r . get () << std :: endl ; }","title":"Executors"},{"location":"programming-paradigms/parallelism/executors/#executors","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 #include <asio.hpp> #include <future> #include <iostream> template < class T > auto make_ready_future ( T && value ) { std :: promise < std :: decay_t < T >> result_promise ; std :: future < std :: decay_t < T >> result_future = result_promise . get_future (); result_promise . set_value ( value ); return result_future ; } template < class FN , class Iterator > auto parallel_reduce ( auto ex , Iterator begin , Iterator end , FN fn ) { auto second = std :: next ( begin ); const bool is_single_element = second == end ; const bool is_single_pair = ! is_single_element && ( std :: next ( second ) == end ); if ( is_single_element ) { return make_ready_future ( * begin ); } else if ( is_single_pair ) { return asio :: post ( ex , asio :: use_future ([ begin , second , & fn ] { return fn ( * begin , * second ); })); } else { // we would probably add an heuristic here for small ranges size_t n = std :: distance ( begin , end ); auto half = std :: next ( begin , n / 2 ); auto lhs = parallel_reduce ( ex , begin , half , fn ); auto rhs = parallel_reduce ( ex , half , end , fn ); return make_ready_future ( lhs . get () + rhs . get ()); } } int main () { // Some references: // - https://think-async.com/Asio/ // - https://think-async.com/Asio/asio-1.18.1/doc/asio/std_executors.html // - https://github.com/chriskohlhoff/executors // - https://taskflow.github.io/taskflow/index.html // - Read the unit tests, such as asio/src/tests/unit/thread_pool.cpp /* * Executors and execution contexts */ // Creating an execution context: a thread pool // - Execution context: place where we can execute functions // - A thread pool is an execution context. // An execution context is: // - Usually long lived. // - Non-copyable. // - May contain additional state, such as timers, and threads asio :: thread_pool pool ; // Creating an executor from an executor context // - Executor: set of rules governing where, when and how to run // a function object // - A thread pool has an executor. // - Its executor rule is: Run function objects in the pool and nowhere // else. An executor is: // - May be long or short lived. // - Lightweight and copyable. // - May be customized on a fine-grained basis, such as exception behavior, // and order auto ex = pool . executor (); std :: cout << ( & pool == & ex . context ()) << std :: endl ; // Executing simple function ex . execute ([ & ex ] { std :: cout << \"Task in executor\" << std :: endl ; std :: cout << \"ex.running_in_this_thread(): \" << ex . running_in_this_thread () << std :: endl ; }); std :: cout << \"ex.running_in_this_thread(): \" << ex . running_in_this_thread () << std :: endl ; /* * Queueing tasks */ // Executing directly in the thread pool // Execution behaviour according to eagerness: // - https://github.com/chriskohlhoff/executors // - Dispatch: Run the function object immediately if possible. // Most eager operation. // Might run before dispatch returns. // If inside pool, run immediately. // If outside pool, add to queue. asio :: dispatch ( ex , [ & ex ] { // This runs before finishing the function asio :: dispatch ( ex , [] { std :: cout << \"dispatch b\" << std :: endl ; }); std :: cout << \"dispatch a\" << std :: endl ; }); // - Post: Submit the function for later execution. // Never immediately in the same thread. // Always adds to pool queue. // Never blocking. asio :: post ( ex , [ & ex ] { // This will all run in parallel asio :: post ( ex , [] { std :: cout << \"post b\" << std :: endl ; }); asio :: post ( ex , [] { std :: cout << \"post c\" << std :: endl ; }); std :: cout << \"post a\" << std :: endl ; }); // - Defer: Submit the function for later execution. // Least eager. // Implies relationship between calling thread and function. // Used when function is a continuation to the calling function. // The function is added to the queue after the current function // ends. If inside pool, adds to a thread local queue. If outside // pool, add to queue. Thread posting might immediately run it. // Potentially blocking. asio :: defer ( ex , [ & ex ] { // This will all run only when this function is over asio :: defer ( ex , [] { std :: cout << \"defer b\" << std :: endl ; }); std :: cout << \"defer a\" << std :: endl ; }); /* * Returning values or waiting on tasks */ // Returning value std :: future < int > r1 = asio :: post ( ex , asio :: use_future ([]() { return 2 ; })); std :: cout << \"Result = \" << r1 . get () << std :: endl ; // Just waiting for task std :: future < void > r2 = asio :: post ( ex , asio :: use_future ([]() { std :: cout << \"Print message\" ; })); r2 . get (); std :: cout << \" -> Message printed\" << std :: endl ; /* * Limiting concurrency */ // Create an strand executor // - A strand is an executor and an executor adapter // - Its rule is: Run function objects according to the underlying // executor\u2019s rules, but also run them in FIFO order and not // concurrently. asio :: strand < asio :: thread_pool :: executor_type > ex2 ( ex ); ex2 . execute ([] { std :: cout << \"FIFO-1a\" << std :: endl ; }); asio :: post ( ex2 , [] { std :: cout << \"FIFO-1b\" << std :: endl ; }); auto fifo_r = asio :: post ( ex2 , asio :: use_future ([] { std :: cout << \"FIFO-1c\" << std :: endl ; })); fifo_r . wait (); std :: cout << \"FIFO tasks done\" << std :: endl ; // Creating a promise std :: promise < int > function_promise ; std :: future < int > function_future_result = function_promise . get_future (); auto fn2 = [ & ] { std :: cout << \"Task 2 executes asynchronously\" << std :: endl ; // \"return\" 2 by setting the promise value function_promise . set_value ( 2 ); }; ex . execute ( fn2 ); std :: cout << \"function_future_result.get(): \" << function_future_result . get () << std :: endl ; // Automating the process of creating a promise auto fn3 = [ & ] { std :: cout << \"Task 3 executes asynchronously\" << std :: endl ; return 3 ; }; std :: promise < int > function_promise2 ; std :: future < int > function_future2 = function_promise2 . get_future (); auto package = [ & ]( auto fn ) { return [ fn , & function_promise2 ] { function_promise2 . set_value ( fn ()); }; }; ex . execute ( package ( fn3 )); std :: cout << \"function_future2.get(): \" << function_future2 . get () << std :: endl ; /* * Ordering tasks */ auto task1 = asio :: post ( asio :: use_future ( [] { std :: cout << \"Task 1 executes asynchronously\" << std :: endl ; })); auto task2 = asio :: post ( asio :: use_future ([]() { std :: cout << \"Task 2 executes in parallel with task 1\" << std :: endl ; return 42 ; })); // something like task3 = task2.then([](int task2_output){...}); auto task3 = asio :: post ( asio :: use_future ([ & ]() { int task2_output = task2 . get (); std :: cout << \"Task 3 executes after task 2, which returned \" << task2_output << std :: endl ; return task2_output * 3 ; })); // something like task4 = when_all(task1, task3); auto task4 = asio :: post ( asio :: use_future ([ & ]() { task1 . wait (); auto task3_output = task3 . get (); return task3_output ; })); // something like task5 = task4.then([](std::tuple<void, int>)) auto task5 = asio :: post ( asio :: use_future ([ & ]() { auto task4_output = task4 . get (); std :: cout << \"Task 5 executes after tasks 1 and 3. Task 3 returned \" << task4_output << \".\" << std :: endl ; })); task5 . get (); std :: cout << \"Task 5 has completed\" << std :: endl ; /* * Making threads sleep */ // When the threads are sleeping, they do not open room for another // thread in the thread pool. // Thus, it's sometimes useful to have extra threads depending on // what they are doing. for ( int i = 0 ; i < 20 ; ++ i ) { asio :: post ( ex , [ i ] { std :: cout << \"Thread \" << i << \" going to sleep\" << std :: endl ; std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); std :: cout << \"Thread \" << i << \" awake\" << std :: endl ; }); } /* * Parallel algorithms */ auto parallel_invoke = []( auto ex , auto fn1 , auto fn2 ) { asio :: post ( ex , fn1 ); asio :: post ( ex , fn2 ); }; parallel_invoke ( ex , [] { std :: cout << \"parallel_invoke a\" << std :: endl ; }, [] { std :: cout << \"parallel_invoke b\" << std :: endl ; }); auto parallel_for = []( auto ex , auto begin , auto end , auto fn ) { while ( begin != end ) { asio :: post ( ex , [ begin , & fn ] { fn ( * begin ); }); ++ begin ; } }; std :: vector < int > v = { 0 , 1 , 2 , 3 , 4 , 5 }; parallel_for ( ex , v . begin (), v . end (), []( int x ) { std :: cout << x ; }); std :: cout << std :: endl ; std :: future < int > r = parallel_reduce ( ex , v . begin (), v . end (), []( int x , int y ) { return x + y ; }); std :: cout << \"The sum of {0, 1, 2, 3, 4, 5} is \" << r . get () << std :: endl ; }","title":"Executors"},{"location":"programming-paradigms/parallelism/signals/","text":"Signals 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include <asio.hpp> #include <future> #include <iostream> int main () { // Signals are important to properly stop asynchronous operations asio :: io_context io_context ; // Create a signal that sets stop timer to true std :: atomic < bool > stop_timer = false ; asio :: signal_set signals ( io_context , SIGINT , SIGTERM ); signals . async_wait ([ & ]( const asio :: error_code & ec , int signal_number ) { if ( ! ec ) { std :: cout << \"Signal number \" << signal_number << std :: endl ; std :: cout << \"Gracefully stopping the timer and exiting\" << std :: endl ; stop_timer . store ( true ); } else { std :: cout << \"Error \" << ec . value () << \" - \" << ec . message () << \" - Signal number - \" << signal_number << std :: endl ; } }); // Create a timer that keeps counting until we have a signal int count = 0 ; asio :: steady_timer t ( io_context , asio :: chrono :: seconds ( 1 )); std :: function < void ( asio :: error_code ) > timer_callback ; timer_callback = [ & ]( asio :: error_code ec ) { if ( ! ec ) { if ( count < 30 && ! stop_timer . load ()) { std :: cout << count << std :: endl ; ++ count ; t . expires_at ( t . expiry () + std :: chrono :: seconds ( 1 )); t . async_wait ( timer_callback ); } else { std :: cout << \"Reached \" << count << std :: endl ; } } else { std :: cout << \"Timer Error\" << std :: endl ; } }; t . async_wait ( timer_callback ); asio :: thread_pool pool ; for ( size_t i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool , [ & ] { io_context . run (); }); } }","title":"Signals"},{"location":"programming-paradigms/parallelism/signals/#signals","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include <asio.hpp> #include <future> #include <iostream> int main () { // Signals are important to properly stop asynchronous operations asio :: io_context io_context ; // Create a signal that sets stop timer to true std :: atomic < bool > stop_timer = false ; asio :: signal_set signals ( io_context , SIGINT , SIGTERM ); signals . async_wait ([ & ]( const asio :: error_code & ec , int signal_number ) { if ( ! ec ) { std :: cout << \"Signal number \" << signal_number << std :: endl ; std :: cout << \"Gracefully stopping the timer and exiting\" << std :: endl ; stop_timer . store ( true ); } else { std :: cout << \"Error \" << ec . value () << \" - \" << ec . message () << \" - Signal number - \" << signal_number << std :: endl ; } }); // Create a timer that keeps counting until we have a signal int count = 0 ; asio :: steady_timer t ( io_context , asio :: chrono :: seconds ( 1 )); std :: function < void ( asio :: error_code ) > timer_callback ; timer_callback = [ & ]( asio :: error_code ec ) { if ( ! ec ) { if ( count < 30 && ! stop_timer . load ()) { std :: cout << count << std :: endl ; ++ count ; t . expires_at ( t . expiry () + std :: chrono :: seconds ( 1 )); t . async_wait ( timer_callback ); } else { std :: cout << \"Reached \" << count << std :: endl ; } } else { std :: cout << \"Timer Error\" << std :: endl ; } }; t . async_wait ( timer_callback ); asio :: thread_pool pool ; for ( size_t i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool , [ & ] { io_context . run (); }); } }","title":"Signals"},{"location":"programming-paradigms/parallelism/threads/","text":"Threads 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include <algorithm> #include <functional> #include <future> #include <iostream> #include <numeric> #include <string> #include <thread> #include <unordered_map> #include <vector> using namespace std ; template < typename RAIter > int parallel_sum ( RAIter beg , RAIter end ) { typename RAIter :: difference_type len = end - beg ; // Solve small problems in one thread if ( len < 1000 ) { return std :: accumulate ( beg , end , 0 ); } // Split large problems into two threads RAIter mid = beg + len / 2 ; std :: future < int > handle = std :: async ( std :: launch :: async , parallel_sum < RAIter > , mid , end ); int sum = parallel_sum ( beg , mid ); return sum + handle . get (); } int main () { // Simple algorithms std :: vector < int > a ( 10000 , 1 ); std :: cout << \"The sum is \" << std :: accumulate ( a . begin (), a . end (), 0 ) << '\\n' ; // Simple threads thread t1 ([]() { cout << \"function 1\" << endl ; }); thread t2 ([]( int x ) { cout << \"function 2: number \" << x << endl ; }, 10 ); auto fn = []( int x ) { cout << \"function 3: number \" << x << endl ; }; thread t3 ( fn , 2 ); cout << \"main, t1, t2, and t3 now execute concurrently... \\n \" ; t1 . join (); t2 . join (); t3 . join (); // Thread vector // - A vector can store lots of reusable threads // - This is probably inefficient because the cost of // creating threads is higher than the work they will do vector < thread > workers ; for ( int i = 0 ; i < 5 ; i ++ ) { workers . emplace_back ([ i ]() { cout << \"Thread function \" << i ; }); } cout << \"Main thread \\n \" ; for_each ( workers . begin (), workers . end (), []( thread & t ) { t . join (); }); // Future task // - Unfortunately, async does not necessarily go to a thread pool // - It's best to use a library if you need async(...) a lot // - A proposal is https://github.com/Amanieu/asyncplusplus future < int > f2 = async ( launch :: async , [] { return 8 ; }); while ( ! f2 . valid ()) { // do some other stuff this_thread :: sleep_for ( chrono :: seconds ( 1 )); } // wait until it's f2 ready to return f2 . wait (); // wait and get value cout << f2 . get () << endl ; // Parallel algorithm with async // - Same overhead applies here std :: vector < int > v ( 10000 , 1 ); std :: cout << \"The sum is \" << parallel_sum ( v . begin (), v . end ()) << '\\n' ; return 0 ; }","title":"Threads"},{"location":"programming-paradigms/parallelism/threads/#threads","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #include <algorithm> #include <functional> #include <future> #include <iostream> #include <numeric> #include <string> #include <thread> #include <unordered_map> #include <vector> using namespace std ; template < typename RAIter > int parallel_sum ( RAIter beg , RAIter end ) { typename RAIter :: difference_type len = end - beg ; // Solve small problems in one thread if ( len < 1000 ) { return std :: accumulate ( beg , end , 0 ); } // Split large problems into two threads RAIter mid = beg + len / 2 ; std :: future < int > handle = std :: async ( std :: launch :: async , parallel_sum < RAIter > , mid , end ); int sum = parallel_sum ( beg , mid ); return sum + handle . get (); } int main () { // Simple algorithms std :: vector < int > a ( 10000 , 1 ); std :: cout << \"The sum is \" << std :: accumulate ( a . begin (), a . end (), 0 ) << '\\n' ; // Simple threads thread t1 ([]() { cout << \"function 1\" << endl ; }); thread t2 ([]( int x ) { cout << \"function 2: number \" << x << endl ; }, 10 ); auto fn = []( int x ) { cout << \"function 3: number \" << x << endl ; }; thread t3 ( fn , 2 ); cout << \"main, t1, t2, and t3 now execute concurrently... \\n \" ; t1 . join (); t2 . join (); t3 . join (); // Thread vector // - A vector can store lots of reusable threads // - This is probably inefficient because the cost of // creating threads is higher than the work they will do vector < thread > workers ; for ( int i = 0 ; i < 5 ; i ++ ) { workers . emplace_back ([ i ]() { cout << \"Thread function \" << i ; }); } cout << \"Main thread \\n \" ; for_each ( workers . begin (), workers . end (), []( thread & t ) { t . join (); }); // Future task // - Unfortunately, async does not necessarily go to a thread pool // - It's best to use a library if you need async(...) a lot // - A proposal is https://github.com/Amanieu/asyncplusplus future < int > f2 = async ( launch :: async , [] { return 8 ; }); while ( ! f2 . valid ()) { // do some other stuff this_thread :: sleep_for ( chrono :: seconds ( 1 )); } // wait until it's f2 ready to return f2 . wait (); // wait and get value cout << f2 . get () << endl ; // Parallel algorithm with async // - Same overhead applies here std :: vector < int > v ( 10000 , 1 ); std :: cout << \"The sum is \" << parallel_sum ( v . begin (), v . end ()) << '\\n' ; return 0 ; }","title":"Threads"},{"location":"programming-paradigms/parallelism/timers/","text":"Timers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include <asio.hpp> #include <future> #include <iostream> int main () { // Timers are useful to applications that need to perform // some operations once every x time units, including timeouts // for servers asio :: io_context io_context ; // Sync timer std :: cout << \"Setting sync timer\" << std :: endl ; asio :: steady_timer t ( io_context , std :: chrono :: seconds ( 3 )); t . wait (); std :: cout << \"Sync Timer expired\" << std :: endl ; // Async Steady timer asio :: steady_timer t1 ( io_context , std :: chrono :: seconds ( 3 )); std :: cout << \"Setting timers\" << std :: endl ; t1 . async_wait ([]( std :: error_code ec ) { if ( ! ec ) { std :: cout << \"Timer 1 expired\" << std :: endl ; } else { std :: cout << \"Timer 1 error\" << std :: endl ; } }); // Async System timer asio :: system_timer t2 ( io_context , std :: chrono :: seconds ( 3 )); t2 . async_wait ([]( std :: error_code ec ) { if ( ! ec ) { std :: cout << \"Timer 2 expired\" << std :: endl ; } else { std :: cout << \"Timer 2 error\" << std :: endl ; } }); // Async High-resolution timer asio :: high_resolution_timer t3 ( io_context , std :: chrono :: seconds ( 3 )); t3 . async_wait ([]( std :: error_code ec ) { if ( ! ec ) { std :: cout << \"Timer 3 expired\" << std :: endl ; } else { std :: cout << \"Timer 3 error\" << std :: endl ; } }); asio :: thread_pool pool ; for ( size_t i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool , [ & ] { io_context . run (); }); } }","title":"Timers"},{"location":"programming-paradigms/parallelism/timers/#timers","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include <asio.hpp> #include <future> #include <iostream> int main () { // Timers are useful to applications that need to perform // some operations once every x time units, including timeouts // for servers asio :: io_context io_context ; // Sync timer std :: cout << \"Setting sync timer\" << std :: endl ; asio :: steady_timer t ( io_context , std :: chrono :: seconds ( 3 )); t . wait (); std :: cout << \"Sync Timer expired\" << std :: endl ; // Async Steady timer asio :: steady_timer t1 ( io_context , std :: chrono :: seconds ( 3 )); std :: cout << \"Setting timers\" << std :: endl ; t1 . async_wait ([]( std :: error_code ec ) { if ( ! ec ) { std :: cout << \"Timer 1 expired\" << std :: endl ; } else { std :: cout << \"Timer 1 error\" << std :: endl ; } }); // Async System timer asio :: system_timer t2 ( io_context , std :: chrono :: seconds ( 3 )); t2 . async_wait ([]( std :: error_code ec ) { if ( ! ec ) { std :: cout << \"Timer 2 expired\" << std :: endl ; } else { std :: cout << \"Timer 2 error\" << std :: endl ; } }); // Async High-resolution timer asio :: high_resolution_timer t3 ( io_context , std :: chrono :: seconds ( 3 )); t3 . async_wait ([]( std :: error_code ec ) { if ( ! ec ) { std :: cout << \"Timer 3 expired\" << std :: endl ; } else { std :: cout << \"Timer 3 error\" << std :: endl ; } }); asio :: thread_pool pool ; for ( size_t i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool , [ & ] { io_context . run (); }); } }","title":"Timers"},{"location":"testing/boostut/","text":"boost.ut 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 #include <boost/ut.hpp> #include <vector> /* * Test suites */ boost :: ut :: suite errors = [] { using namespace boost :: ut ; \"exception\" _test = [] { expect ( throws ([] { throw 0 ; })) << \"throws any exception\" ; }; \"failure\" _test = [] { expect ( aborts ([] { expect ( false ); })); }; }; int main () { using namespace boost :: ut ; /* * Requirements */ expect ( true ); expect ( 1 == 2 ); expect ( 1 _i == 2 ); // UDL syntax expect ( 1 == 2 _i ); // UDL syntax expect ( that % 1 == 2 ); // Matcher syntax expect ( eq ( 1 , 2 )); // eq/neq/gt/ge/lt/le expect (( 1 == 1 _i ) >> fatal ); // fatal assertion expect ( 1 _i == 2 ); // not executed expect ( 42l == 42 _l and 1 == 2 _i ) << \"additional info \\n \" ; /* * Test groups */ \"hello world\" _test = [] { int i = 42 ; expect ( 42 _i == i ); }; \"[vector]\" _test = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); should ( \"resize bigger\" ) = [ v ] { // or \"resize bigger\"_test mut ( v ). resize ( 10 ); expect ( 10 _ul == std :: size ( v )); }; expect (( 5 _ul == std :: size ( v )) >> fatal ); should ( \"resize smaller\" ) = [ = ]() mutable { // or \"resize smaller\"_test v . resize ( 0 ); expect ( 0 _ul == std :: size ( v )); }; }; /* * Behaviour Driven development */ using namespace boost :: ut :: bdd ; \"vector\" _test = [] { given ( \"I have a vector\" ) = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); when ( \"I resize bigger\" ) = [ = ] { mut ( v ). resize ( 10 ); then ( \"The size should increase\" ) = [ = ] { expect ( 10 _ul == std :: size ( v )); }; }; }; }; /* * BBD: feature / scenario */ feature ( \"vector\" ) = [] { scenario ( \"size\" ) = [] { given ( \"I have a vector\" ) = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); when ( \"I resize bigger\" ) = [ = ] { mut ( v ). resize ( 10 ); then ( \"The size should increase\" ) = [ = ] { expect ( 10 _ul == std :: size ( v )); }; }; }; }; }; /* * Same test / different parameters * (Catch2 does not support that) */ for ( auto i : std :: vector { 1 , 2 , 3 }) { test ( \"parameterized \" + std :: to_string ( i )) = [ i ] { // 3 tests expect ( that % i > 0 ); // 3 asserts }; } /* * Same test / different parameters */ \"args\" _test = []( const auto & arg ) { expect ( arg > 0 _i ) << \"all values greater than 0\" ; } | std :: vector { 1 , 2 , 3 }; /* * Nested tests */ \"vector\" _test = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); \"samesize\" _test = [ & ] { std :: vector < int > v2 ( 5 ); expect ( eq ( v . size (), v2 . size ())); }; }; /* * Logging */ \"logging\" _test = [] { log << \"pre\" ; expect ( 42 _i == 43 ) << \"message on failure\" ; log << \"post\" ; }; return 0 ; }","title":"boost.ut"},{"location":"testing/boostut/#boostut","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 #include <boost/ut.hpp> #include <vector> /* * Test suites */ boost :: ut :: suite errors = [] { using namespace boost :: ut ; \"exception\" _test = [] { expect ( throws ([] { throw 0 ; })) << \"throws any exception\" ; }; \"failure\" _test = [] { expect ( aborts ([] { expect ( false ); })); }; }; int main () { using namespace boost :: ut ; /* * Requirements */ expect ( true ); expect ( 1 == 2 ); expect ( 1 _i == 2 ); // UDL syntax expect ( 1 == 2 _i ); // UDL syntax expect ( that % 1 == 2 ); // Matcher syntax expect ( eq ( 1 , 2 )); // eq/neq/gt/ge/lt/le expect (( 1 == 1 _i ) >> fatal ); // fatal assertion expect ( 1 _i == 2 ); // not executed expect ( 42l == 42 _l and 1 == 2 _i ) << \"additional info \\n \" ; /* * Test groups */ \"hello world\" _test = [] { int i = 42 ; expect ( 42 _i == i ); }; \"[vector]\" _test = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); should ( \"resize bigger\" ) = [ v ] { // or \"resize bigger\"_test mut ( v ). resize ( 10 ); expect ( 10 _ul == std :: size ( v )); }; expect (( 5 _ul == std :: size ( v )) >> fatal ); should ( \"resize smaller\" ) = [ = ]() mutable { // or \"resize smaller\"_test v . resize ( 0 ); expect ( 0 _ul == std :: size ( v )); }; }; /* * Behaviour Driven development */ using namespace boost :: ut :: bdd ; \"vector\" _test = [] { given ( \"I have a vector\" ) = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); when ( \"I resize bigger\" ) = [ = ] { mut ( v ). resize ( 10 ); then ( \"The size should increase\" ) = [ = ] { expect ( 10 _ul == std :: size ( v )); }; }; }; }; /* * BBD: feature / scenario */ feature ( \"vector\" ) = [] { scenario ( \"size\" ) = [] { given ( \"I have a vector\" ) = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); when ( \"I resize bigger\" ) = [ = ] { mut ( v ). resize ( 10 ); then ( \"The size should increase\" ) = [ = ] { expect ( 10 _ul == std :: size ( v )); }; }; }; }; }; /* * Same test / different parameters * (Catch2 does not support that) */ for ( auto i : std :: vector { 1 , 2 , 3 }) { test ( \"parameterized \" + std :: to_string ( i )) = [ i ] { // 3 tests expect ( that % i > 0 ); // 3 asserts }; } /* * Same test / different parameters */ \"args\" _test = []( const auto & arg ) { expect ( arg > 0 _i ) << \"all values greater than 0\" ; } | std :: vector { 1 , 2 , 3 }; /* * Nested tests */ \"vector\" _test = [] { std :: vector < int > v ( 5 ); expect (( 5 _ul == std :: size ( v )) >> fatal ); \"samesize\" _test = [ & ] { std :: vector < int > v2 ( 5 ); expect ( eq ( v . size (), v2 . size ())); }; }; /* * Logging */ \"logging\" _test = [] { log << \"pre\" ; expect ( 42 _i == 43 ) << \"message on failure\" ; log << \"post\" ; }; return 0 ; }","title":"boost.ut"},{"location":"testing/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ####################################################### ### Utilities for testing ### ####################################################### # Print source location add_executable ( source_location source_location.cpp ) # Unit tests in C++20 only # boost.ut FetchContent_Declare ( boost.ut GIT_REPOSITORY https://github.com/boost-ext/ut GIT_TAG v1.1.8 ) FetchContent_MakeAvailable ( boost.ut ) add_executable ( unit_tests unit_tests_ut.cpp ) target_link_libraries ( unit_tests PRIVATE boost.ut ) if ( NOT MSVC ) target_compile_options ( unit_tests PRIVATE -Wno-comma ) endif () # Unit tests FetchContent_Declare ( Catch2 GIT_REPOSITORY https://github.com/catchorg/Catch2 GIT_TAG v3.0.0-preview3 ) FetchContent_MakeAvailable ( Catch2 ) add_executable ( unit_tests_catch unit_tests_catch.cpp ) target_link_libraries ( unit_tests_catch PRIVATE Catch2::Catch2WithMain ) # Plots if ( EXPECTED_COMPILER ) find_package ( Matplot++ QUIET ) if ( Matplot++_FOUND ) add_executable ( plots plots.cpp ) target_link_libraries ( plots PRIVATE Matplot++::matplot ) endif () endif ()","title":"Build script"},{"location":"testing/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ####################################################### ### Utilities for testing ### ####################################################### # Print source location add_executable ( source_location source_location.cpp ) # Unit tests in C++20 only # boost.ut FetchContent_Declare ( boost.ut GIT_REPOSITORY https://github.com/boost-ext/ut GIT_TAG v1.1.8 ) FetchContent_MakeAvailable ( boost.ut ) add_executable ( unit_tests unit_tests_ut.cpp ) target_link_libraries ( unit_tests PRIVATE boost.ut ) if ( NOT MSVC ) target_compile_options ( unit_tests PRIVATE -Wno-comma ) endif () # Unit tests FetchContent_Declare ( Catch2 GIT_REPOSITORY https://github.com/catchorg/Catch2 GIT_TAG v3.0.0-preview3 ) FetchContent_MakeAvailable ( Catch2 ) add_executable ( unit_tests_catch unit_tests_catch.cpp ) target_link_libraries ( unit_tests_catch PRIVATE Catch2::Catch2WithMain ) # Plots if ( EXPECTED_COMPILER ) find_package ( Matplot++ QUIET ) if ( Matplot++_FOUND ) add_executable ( plots plots.cpp ) target_link_libraries ( plots PRIVATE Matplot++::matplot ) endif () endif ()","title":"Build script"},{"location":"testing/catch2/","text":"Catch2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <catch2/catch_test_macros.hpp> static int Factorial ( int number ) { return number <= 1 ? number : Factorial ( number - 1 ) * number ; // fail // return number <= 1 ? 1 : Factorial( number - 1 ) * number; // pass } TEST_CASE ( \"Factorial of 0 is 1 (fail)\" , \"[single-file]\" ) { REQUIRE ( Factorial ( 0 ) == 1 ); } TEST_CASE ( \"Factorials of 1 and higher are computed (pass)\" , \"[single-file]\" ) { REQUIRE ( Factorial ( 1 ) == 1 ); REQUIRE ( Factorial ( 2 ) == 2 ); REQUIRE ( Factorial ( 3 ) == 6 ); REQUIRE ( Factorial ( 10 ) == 3628800 ); }","title":"Catch2"},{"location":"testing/catch2/#catch2","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <catch2/catch_test_macros.hpp> static int Factorial ( int number ) { return number <= 1 ? number : Factorial ( number - 1 ) * number ; // fail // return number <= 1 ? 1 : Factorial( number - 1 ) * number; // pass } TEST_CASE ( \"Factorial of 0 is 1 (fail)\" , \"[single-file]\" ) { REQUIRE ( Factorial ( 0 ) == 1 ); } TEST_CASE ( \"Factorials of 1 and higher are computed (pass)\" , \"[single-file]\" ) { REQUIRE ( Factorial ( 1 ) == 1 ); REQUIRE ( Factorial ( 2 ) == 2 ); REQUIRE ( Factorial ( 3 ) == 6 ); REQUIRE ( Factorial ( 10 ) == 3628800 ); }","title":"Catch2"},{"location":"testing/plots/","text":"Plots 1 2 3 4 5 6 7 8 #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( std :: vector { 1 , 2 , 3 , 4 , 5 , 6 }); show (); return 0 ; }","title":"Plots"},{"location":"testing/plots/#plots","text":"1 2 3 4 5 6 7 8 #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( std :: vector { 1 , 2 , 3 , 4 , 5 , 6 }); show (); return 0 ; }","title":"Plots"},{"location":"testing/source-location/","text":"Source Location 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <iostream> #include <string_view> #if defined(__has_include) && __has_include(\"source_location\") # include <source_location> #endif #include \"source_location.h\" void print_msg_with_line ( std :: string_view message , const std :: source_location & location = std :: source_location :: current ()) { std :: cout << \"info: \" << location . file_name () << ':' << location . line () << ' ' << message << '\\n' ; } int main () { print_msg_with_line ( \"Hello world!\" ); return 0 ; }","title":"Source Location"},{"location":"testing/source-location/#source-location","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <iostream> #include <string_view> #if defined(__has_include) && __has_include(\"source_location\") # include <source_location> #endif #include \"source_location.h\" void print_msg_with_line ( std :: string_view message , const std :: source_location & location = std :: source_location :: current ()) { std :: cout << \"info: \" << location . file_name () << ':' << location . line () << ' ' << message << '\\n' ; } int main () { print_msg_with_line ( \"Hello world!\" ); return 0 ; }","title":"Source Location"},{"location":"utilities/networking/async-network/","text":"Async Network 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 #include \"asio.hpp\" #include <iostream> #include <memory> #include <utility> // https://think-async.com/Asio/asio-1.16.1/src/examples/cpp11/echo/async_tcp_echo_server.cpp class session : public std :: enable_shared_from_this < session > { public : // Create a session to a client // The session just wraps a socket to communicate with the client explicit session ( asio :: ip :: tcp :: socket socket ) : socket_ ( std :: move ( socket )) {} // Start the session void start () { do_read (); } private : // Read whatever the client sent us void do_read () { // Create another pointer to this session // - These pointers are useful to make sure there is always // some shared pointer pointing to this session object auto self ( shared_from_this ()); // Read some data from the client // - We read little by little to make sure everything is OK // - This is better than reading all at once // - We read max_length bytes at a time // - We can also use a future instead of a callback: // std::future<size_t> r = // socket_.async_read_some(asio::buffer(...), asio::use_future); socket_ . async_read_some ( asio :: buffer ( data_ , max_length ), [ this , self ]( std :: error_code ec , std :: size_t length ) { // If there was no error reading the message, // write a response to the client if ( ! ec ) { std :: cout << \"Client sent: \" << std :: endl ; std :: cout << data_ << std :: endl << std :: endl ; do_write ( length ); } }); } // NOLINTNEXTLINE(readability-convert-member-functions-to-static) void do_write ( std :: size_t length ) { // Create another shared pointer to this to make sure it does die auto self ( shared_from_this ()); // Write a response asynchronously // - In this example, we write the same data back to the client asio :: async_write ( socket_ , asio :: buffer ( data_ , length ), [ this , self ]( std :: error_code ec , std :: size_t /*length*/ ) { // If there is no error if ( ! ec ) { std :: cout << \"Server replied with: \" << std :: endl ; std :: cout << data_ << std :: endl << std :: endl ; // Starting reading from the client again do_read (); } }); } // Socket representing connection to client asio :: ip :: tcp :: socket socket_ ; // Max length of the messages static constexpr size_t max_length = 1024 ; // Array to keep messages char data_ [ max_length ]{}; }; // Class to manage the acceptor class server { public : // Construct server on a port // - The server just wraps the acceptor and starts a session whenever // the client connects server ( asio :: io_context & io_context , short port ) : acceptor_ ( io_context , asio :: ip :: tcp :: endpoint ( asio :: ip :: tcp :: v4 (), port )) { do_accept (); } private : // Listen for connection void do_accept () { std :: cout << \"Listening on http://localhost:\" << acceptor_ . local_endpoint (). port () << std :: endl ; // Wait for connection // - Wait for a connection // - Open http://localhost:8080 in your browser acceptor_ . async_accept ( [ this ]( std :: error_code ec , asio :: ip :: tcp :: socket socket ) { // If there is no error, create a socket and reply // - The session object wraps the a socket to create response // - The session will manage a single connection to a user if ( ! ec ) { // Start the session std :: make_shared < session > ( std :: move ( socket )) -> start (); } // Accept another connection // - The session will work asynchronously // - While the session will start to read the message, // the server already starts listening no another connection. do_accept (); }); } private /* members */ : // The only member we need is an acceptor for the server asio :: ip :: tcp :: acceptor acceptor_ ; }; int main () { try { // Create io_context as usual asio :: io_context io_context ; // We put all the logic inside a server object // - Nothing forbids us from organizing the server // in any other way. server s ( io_context , 8080 ); // Run the io_context // - The server async functions will queue tasks in the io_context // - This function runs the io_context while there's work to do // - There is always going to be work to do because the server // is always listening asio :: thread_pool pool ; for ( unsigned i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool , [ & ] { // We run the io_context from the threads // - This allows us the io_context to send work to whatever // thread seems best io_context . run (); }); } } catch ( std :: exception & e ) { // Report any exceptions std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } return 0 ; }","title":"Async Network"},{"location":"utilities/networking/async-network/#async-network","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 #include \"asio.hpp\" #include <iostream> #include <memory> #include <utility> // https://think-async.com/Asio/asio-1.16.1/src/examples/cpp11/echo/async_tcp_echo_server.cpp class session : public std :: enable_shared_from_this < session > { public : // Create a session to a client // The session just wraps a socket to communicate with the client explicit session ( asio :: ip :: tcp :: socket socket ) : socket_ ( std :: move ( socket )) {} // Start the session void start () { do_read (); } private : // Read whatever the client sent us void do_read () { // Create another pointer to this session // - These pointers are useful to make sure there is always // some shared pointer pointing to this session object auto self ( shared_from_this ()); // Read some data from the client // - We read little by little to make sure everything is OK // - This is better than reading all at once // - We read max_length bytes at a time // - We can also use a future instead of a callback: // std::future<size_t> r = // socket_.async_read_some(asio::buffer(...), asio::use_future); socket_ . async_read_some ( asio :: buffer ( data_ , max_length ), [ this , self ]( std :: error_code ec , std :: size_t length ) { // If there was no error reading the message, // write a response to the client if ( ! ec ) { std :: cout << \"Client sent: \" << std :: endl ; std :: cout << data_ << std :: endl << std :: endl ; do_write ( length ); } }); } // NOLINTNEXTLINE(readability-convert-member-functions-to-static) void do_write ( std :: size_t length ) { // Create another shared pointer to this to make sure it does die auto self ( shared_from_this ()); // Write a response asynchronously // - In this example, we write the same data back to the client asio :: async_write ( socket_ , asio :: buffer ( data_ , length ), [ this , self ]( std :: error_code ec , std :: size_t /*length*/ ) { // If there is no error if ( ! ec ) { std :: cout << \"Server replied with: \" << std :: endl ; std :: cout << data_ << std :: endl << std :: endl ; // Starting reading from the client again do_read (); } }); } // Socket representing connection to client asio :: ip :: tcp :: socket socket_ ; // Max length of the messages static constexpr size_t max_length = 1024 ; // Array to keep messages char data_ [ max_length ]{}; }; // Class to manage the acceptor class server { public : // Construct server on a port // - The server just wraps the acceptor and starts a session whenever // the client connects server ( asio :: io_context & io_context , short port ) : acceptor_ ( io_context , asio :: ip :: tcp :: endpoint ( asio :: ip :: tcp :: v4 (), port )) { do_accept (); } private : // Listen for connection void do_accept () { std :: cout << \"Listening on http://localhost:\" << acceptor_ . local_endpoint (). port () << std :: endl ; // Wait for connection // - Wait for a connection // - Open http://localhost:8080 in your browser acceptor_ . async_accept ( [ this ]( std :: error_code ec , asio :: ip :: tcp :: socket socket ) { // If there is no error, create a socket and reply // - The session object wraps the a socket to create response // - The session will manage a single connection to a user if ( ! ec ) { // Start the session std :: make_shared < session > ( std :: move ( socket )) -> start (); } // Accept another connection // - The session will work asynchronously // - While the session will start to read the message, // the server already starts listening no another connection. do_accept (); }); } private /* members */ : // The only member we need is an acceptor for the server asio :: ip :: tcp :: acceptor acceptor_ ; }; int main () { try { // Create io_context as usual asio :: io_context io_context ; // We put all the logic inside a server object // - Nothing forbids us from organizing the server // in any other way. server s ( io_context , 8080 ); // Run the io_context // - The server async functions will queue tasks in the io_context // - This function runs the io_context while there's work to do // - There is always going to be work to do because the server // is always listening asio :: thread_pool pool ; for ( unsigned i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool , [ & ] { // We run the io_context from the threads // - This allows us the io_context to send work to whatever // thread seems best io_context . run (); }); } } catch ( std :: exception & e ) { // Report any exceptions std :: cerr << \"Exception: \" << e . what () << \" \\n \" ; } return 0 ; }","title":"Async Network"},{"location":"utilities/networking/build-script/","text":"Build script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ####################################################### ### External Libraries ### ####################################################### FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-18-1 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () ####################################################### ### Networking ### ####################################################### add_executable ( network network.cpp ) target_link_libraries ( network asio ) add_executable ( network_async network_async.cpp ) target_link_libraries ( network_async asio ) add_subdirectory ( server )","title":"Build script"},{"location":"utilities/networking/build-script/#build-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ####################################################### ### External Libraries ### ####################################################### FetchContent_Declare ( asio GIT_REPOSITORY https://github.com/chriskohlhoff/asio.git GIT_TAG asio-1-18-1 ) FetchContent_GetProperties ( asio ) if ( NOT asio_POPULATED ) FetchContent_Populate ( asio ) add_library ( asio INTERFACE ) target_include_directories ( asio INTERFACE ${ asio_SOURCE_DIR } /asio/include ) target_compile_definitions ( asio INTERFACE ASIO_STANDALONE ASIO_NO_DEPRECATED ) target_link_libraries ( asio INTERFACE Threads::Threads ) endif () ####################################################### ### Networking ### ####################################################### add_executable ( network network.cpp ) target_link_libraries ( network asio ) add_executable ( network_async network_async.cpp ) target_link_libraries ( network_async asio ) add_subdirectory ( server )","title":"Build script"},{"location":"utilities/networking/http-server/","text":"Http server main.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // // main.cpp // ~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"server.hpp\" #include <iostream> #include <string> int main ( int argc , char * argv []) { // - Move this to examples // - Replace these snippets with an http server library try { // Check command line arguments. if ( argc != 4 ) { std :: cout << \"Usage: http_server <address> <port> <doc_root> \\n \" ; std :: cout << \" For IPv4, try: \" ; std :: cout << \" receiver 0.0.0.0 80 . \\n \" ; std :: cout << \" For IPv6, try: \" ; std :: cout << \" receiver 0::0 80 . \\n \" ; } // Initialise the server std :: string address = argc > 1 ? argv [ 1 ] : \"0.0.0.0\" ; std :: string port = argc > 2 ? argv [ 2 ] : \"80\" ; std :: string doc_root = argc > 3 ? argv [ 3 ] : \".\" ; std :: cout << \"Server address: http://\" << address << \":\" << port << '\\n' ; http :: server :: server s ( address , port , doc_root ); // Run the server until stopped. s . run (); } catch ( std :: exception & e ) { std :: cerr << \"exception: \" << e . what () << \" \\n \" ; } return 0 ; } server.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // // server.hpp // ~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_SERVER_HPP #define HTTP_SERVER_HPP #include \"connection.hpp\" #include \"connection_manager.hpp\" #include \"request_handler.hpp\" #include <asio.hpp> #include <string> namespace http :: server { /// The top-level class of the HTTP server. class server { public : server ( const server & ) = delete ; server & operator = ( const server & ) = delete ; /// Construct the server to listen on the specified TCP address and /// port, and serve up files from the given directory. explicit server ( const std :: string & address , const std :: string & port , const std :: string & doc_root ); /// Run the server's io_context loop. void run (); private : /// Perform an asynchronous accept operation. void do_accept (); /// Wait for a request to stop the server. void do_await_stop (); /// The io_context used to perform asynchronous operations. asio :: io_context io_context_ ; /// Executor for the io context asio :: thread_pool pool_ ; /// The signal_set is used to register for process termination /// notifications. asio :: signal_set signals_ ; /// Acceptor used to listen for incoming connections. asio :: ip :: tcp :: acceptor acceptor_ ; /// The connection manager which owns all live connections. connection_manager connection_manager_ ; /// The handler for all incoming requests. request_handler request_handler_ ; void setup_signals (); void setup_acceptor ( const std :: string & address , const std :: string & port ); }; } // namespace http::server #endif // HTTP_SERVER_HPP connection_manager.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // // connection_manager.hpp // ~~~~~~~~~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_CONNECTION_MANAGER_HPP #define HTTP_CONNECTION_MANAGER_HPP #include \"connection.hpp\" #include <set> namespace http :: server { /// Manages open connections so that they may be cleanly stopped when /// the server needs to shut down. class connection_manager { public : connection_manager ( const connection_manager & ) = delete ; connection_manager & operator = ( const connection_manager & ) = delete ; /// Construct a connection manager. connection_manager (); /// Add the specified connection to the manager and start it. void start ( connection_ptr c ); /// Stop the specified connection. void stop ( connection_ptr c ); /// Stop all connections. void stop_all (); private : /// The managed connections. std :: set < connection_ptr > connections_ ; }; } // namespace http::server #endif // HTTP_CONNECTION_MANAGER_HPP connection.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // // connection.hpp // ~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_CONNECTION_HPP #define HTTP_CONNECTION_HPP #include \"reply.hpp\" #include \"request.hpp\" #include \"request_handler.hpp\" #include \"request_parser.hpp\" #include <array> #include <asio.hpp> #include <memory> namespace http :: server { class connection_manager ; /// Represents a single connection from a client. class connection : public std :: enable_shared_from_this < connection > { public : connection ( const connection & ) = delete ; connection & operator = ( const connection & ) = delete ; /// Construct a connection with the given socket. explicit connection ( asio :: ip :: tcp :: socket socket , connection_manager & manager , request_handler & handler ); /// Start the first asynchronous operation for the connection. void start (); /// Stop all asynchronous operations associated with the connection. void stop (); private : /// Perform an asynchronous read operation. void do_read (); /// Perform an asynchronous write operation. void do_write (); /// Socket for the connection. asio :: ip :: tcp :: socket socket_ ; /// The manager for this connection. connection_manager & connection_manager_ ; /// The handler used to process the incoming request. request_handler & request_handler_ ; /// Buffer for incoming data. std :: array < char , 8192 > buffer_ ; /// The incoming request. request request_ ; /// The parser for the incoming request. request_parser request_parser_ ; /// The reply to be sent back to the client. reply reply_ ; }; typedef std :: shared_ptr < connection > connection_ptr ; } // namespace http::server #endif // HTTP_CONNECTION_HPP header.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // // header.hpp // ~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_HEADER_HPP #define HTTP_HEADER_HPP #include <string> namespace http :: server { struct header { std :: string name ; std :: string value ; }; } // namespace http::server #endif // HTTP_HEADER_HPP reply.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // // reply.hpp // ~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_REPLY_HPP #define HTTP_REPLY_HPP #include \"header.hpp\" #include <asio.hpp> #include <string> #include <vector> namespace http :: server { /// A reply to be sent to a client. struct reply { /// The status of the reply. enum status_type { ok = 200 , created = 201 , accepted = 202 , no_content = 204 , multiple_choices = 300 , moved_permanently = 301 , moved_temporarily = 302 , not_modified = 304 , bad_request = 400 , unauthorized = 401 , forbidden = 403 , not_found = 404 , internal_server_error = 500 , not_implemented = 501 , bad_gateway = 502 , service_unavailable = 503 } status ; /// The headers to be included in the reply. std :: vector < header > headers ; /// The content to be sent in the reply. std :: string content ; /// Convert the reply into a vector of buffers. The buffers do not /// own the underlying memory blocks, therefore the reply object /// must remain valid and not be changed until the write operation /// has completed. std :: vector < asio :: const_buffer > to_buffers (); /// Get a stock reply. static reply stock_reply ( status_type status ); }; } // namespace http::server #endif // HTTP_REPLY_HPP request.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // // request.hpp // ~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_REQUEST_HPP #define HTTP_REQUEST_HPP #include \"header.hpp\" #include <string> #include <vector> namespace http :: server { /// A request received from a client. struct request { std :: string method ; std :: string uri ; int http_version_major ; int http_version_minor ; std :: vector < header > headers ; }; } // namespace http::server #endif // HTTP_REQUEST_HPP request_parser.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 // // request_parser.hpp // ~~~~~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_REQUEST_PARSER_HPP #define HTTP_REQUEST_PARSER_HPP #include <tuple> namespace http :: server { struct request ; /// Parser for incoming requests. class request_parser { public : /// Construct ready to parse the request method. request_parser (); /// Reset to initial parser state. void reset (); /// Result of parse. enum result_type { good , bad , indeterminate }; /// Parse some data. The enum return value is good when a complete /// request has been parsed, bad if the data is invalid, /// indeterminate when more data is required. The InputIterator /// return value indicates how much of the input has been consumed. template < typename InputIterator > std :: tuple < result_type , InputIterator > parse ( request & req , InputIterator begin , InputIterator end ) { while ( begin != end ) { result_type result = consume ( req , * begin ++ ); if ( result == good || result == bad ) return std :: make_tuple ( result , begin ); } return std :: make_tuple ( indeterminate , begin ); } private : /// Handle the next character of input. result_type consume ( request & req , char input ); /// Check if a byte is an HTTP character. static bool is_char ( int c ); /// Check if a byte is an HTTP control character. static bool is_ctl ( int c ); /// Check if a byte is defined as an HTTP tspecial character. static bool is_tspecial ( int c ); /// Check if a byte is a digit. static bool is_digit ( int c ); /// The current state of the parser. enum state { method_start , method , uri , http_version_h , http_version_t_1 , http_version_t_2 , http_version_p , http_version_slash , http_version_major_start , http_version_major , http_version_minor_start , http_version_minor , expecting_newline_1 , header_line_start , header_lws , header_name , space_before_header_value , header_value , expecting_newline_2 , expecting_newline_3 } state_ ; }; } // namespace http::server #endif // HTTP_REQUEST_PARSER_HPP mime_types.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // // mime_types.hpp // ~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_MIME_TYPES_HPP #define HTTP_MIME_TYPES_HPP #include <string> namespace http :: server :: mime_types { /// Convert a file extension into a MIME type. std :: string extension_to_type ( const std :: string & extension ); } // namespace http::server::mime_types #endif // HTTP_MIME_TYPES_HPP request_handler.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // // request_handler.hpp // ~~~~~~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_REQUEST_HANDLER_HPP #define HTTP_REQUEST_HANDLER_HPP #include <string> namespace http :: server { struct reply ; struct request ; /// The common handler for all incoming requests. class request_handler { public : request_handler ( const request_handler & ) = delete ; request_handler & operator = ( const request_handler & ) = delete ; /// Construct with a directory containing files to be served. explicit request_handler ( const std :: string & doc_root ); /// Handle a request and produce a reply. void handle_request ( const request & req , reply & rep ); private : /// The directory containing the files to be served. std :: string doc_root_ ; /// Perform URL-decoding on a string. Returns false if the encoding /// was invalid. static bool url_decode ( const std :: string & in , std :: string & out ); }; } // namespace http::server #endif // HTTP_REQUEST_HANDLER_HPP mime_types.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // // mime_types.cpp // ~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"mime_types.hpp\" namespace http :: server :: mime_types { constexpr struct mapping { const char * extension ; const char * mime_type ; } mappings [] = {{ \"gif\" , \"image/gif\" }, { \"htm\" , \"text/html\" }, { \"html\" , \"text/html\" }, { \"jpg\" , \"image/jpeg\" }, { \"png\" , \"image/png\" }}; std :: string extension_to_type ( const std :: string & extension ) { for ( mapping m : mappings ) { if ( m . extension == extension ) { return m . mime_type ; } } return \"text/plain\" ; } } // namespace http::server::mime_types request_parser.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 // // request_parser.cpp // ~~~~~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"request_parser.hpp\" #include \"request.hpp\" namespace http :: server { request_parser :: request_parser () : state_ ( method_start ) {} void request_parser :: reset () { state_ = method_start ; } request_parser :: result_type request_parser :: consume ( request & req , char input ) { switch ( state_ ) { case method_start : if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { state_ = method ; req . method . push_back ( input ); return indeterminate ; } case method : if ( input == ' ' ) { state_ = uri ; return indeterminate ; } else if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { req . method . push_back ( input ); return indeterminate ; } case uri : if ( input == ' ' ) { state_ = http_version_h ; return indeterminate ; } else if ( is_ctl ( input )) { return bad ; } else { req . uri . push_back ( input ); return indeterminate ; } case http_version_h : if ( input == 'H' ) { state_ = http_version_t_1 ; return indeterminate ; } else { return bad ; } case http_version_t_1 : if ( input == 'T' ) { state_ = http_version_t_2 ; return indeterminate ; } else { return bad ; } case http_version_t_2 : if ( input == 'T' ) { state_ = http_version_p ; return indeterminate ; } else { return bad ; } case http_version_p : if ( input == 'P' ) { state_ = http_version_slash ; return indeterminate ; } else { return bad ; } case http_version_slash : if ( input == '/' ) { req . http_version_major = 0 ; req . http_version_minor = 0 ; state_ = http_version_major_start ; return indeterminate ; } else { return bad ; } case http_version_major_start : if ( is_digit ( input )) { req . http_version_major = req . http_version_major * 10 + input - '0' ; state_ = http_version_major ; return indeterminate ; } else { return bad ; } case http_version_major : if ( input == '.' ) { state_ = http_version_minor_start ; return indeterminate ; } else if ( is_digit ( input )) { req . http_version_major = req . http_version_major * 10 + input - '0' ; return indeterminate ; } else { return bad ; } case http_version_minor_start : if ( is_digit ( input )) { req . http_version_minor = req . http_version_minor * 10 + input - '0' ; state_ = http_version_minor ; return indeterminate ; } else { return bad ; } case http_version_minor : if ( input == '\\r' ) { state_ = expecting_newline_1 ; return indeterminate ; } else if ( is_digit ( input )) { req . http_version_minor = req . http_version_minor * 10 + input - '0' ; return indeterminate ; } else { return bad ; } case expecting_newline_1 : if ( input == '\\n' ) { state_ = header_line_start ; return indeterminate ; } else { return bad ; } case header_line_start : if ( input == '\\r' ) { state_ = expecting_newline_3 ; return indeterminate ; } else if ( ! req . headers . empty () && ( input == ' ' || input == '\\t' )) { state_ = header_lws ; return indeterminate ; } else if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { req . headers . push_back ( header ()); req . headers . back (). name . push_back ( input ); state_ = header_name ; return indeterminate ; } case header_lws : if ( input == '\\r' ) { state_ = expecting_newline_2 ; return indeterminate ; } else if ( input == ' ' || input == '\\t' ) { return indeterminate ; } else if ( is_ctl ( input )) { return bad ; } else { state_ = header_value ; req . headers . back (). value . push_back ( input ); return indeterminate ; } case header_name : if ( input == ':' ) { state_ = space_before_header_value ; return indeterminate ; } else if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { req . headers . back (). name . push_back ( input ); return indeterminate ; } case space_before_header_value : if ( input == ' ' ) { state_ = header_value ; return indeterminate ; } else { return bad ; } case header_value : if ( input == '\\r' ) { state_ = expecting_newline_2 ; return indeterminate ; } else if ( is_ctl ( input )) { return bad ; } else { req . headers . back (). value . push_back ( input ); return indeterminate ; } case expecting_newline_2 : if ( input == '\\n' ) { state_ = header_line_start ; return indeterminate ; } else { return bad ; } case expecting_newline_3 : return ( input == '\\n' ) ? good : bad ; default : return bad ; } } bool request_parser :: is_char ( int c ) { return c >= 0 && c <= 127 ; } bool request_parser :: is_ctl ( int c ) { return ( c >= 0 && c <= 31 ) || ( c == 127 ); } bool request_parser :: is_tspecial ( int c ) { switch ( c ) { case '(' : case ')' : case '<' : case '>' : case '@' : case ',' : case ';' : case ':' : case '\\\\' : case '\"' : case '/' : case '[' : case ']' : case '?' : case '=' : case '{' : case '}' : case ' ' : case '\\t' : return true ; default : return false ; } } bool request_parser :: is_digit ( int c ) { return c >= '0' && c <= '9' ; } } // namespace http::server reply.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 // // reply.cpp // ~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"reply.hpp\" #include <string> namespace http :: server { namespace status_strings { const std :: string ok = \"HTTP/1.0 200 OK \\r\\n \" ; const std :: string created = \"HTTP/1.0 201 Created \\r\\n \" ; const std :: string accepted = \"HTTP/1.0 202 Accepted \\r\\n \" ; const std :: string no_content = \"HTTP/1.0 204 No Content \\r\\n \" ; const std :: string multiple_choices = \"HTTP/1.0 300 Multiple Choices \\r\\n \" ; const std :: string moved_permanently = \"HTTP/1.0 301 Moved Permanently \\r\\n \" ; const std :: string moved_temporarily = \"HTTP/1.0 302 Moved Temporarily \\r\\n \" ; const std :: string not_modified = \"HTTP/1.0 304 Not Modified \\r\\n \" ; const std :: string bad_request = \"HTTP/1.0 400 Bad Request \\r\\n \" ; const std :: string unauthorized = \"HTTP/1.0 401 Unauthorized \\r\\n \" ; const std :: string forbidden = \"HTTP/1.0 403 Forbidden \\r\\n \" ; const std :: string not_found = \"HTTP/1.0 404 Not Found \\r\\n \" ; const std :: string internal_server_error = \"HTTP/1.0 500 Internal Server Error \\r\\n \" ; const std :: string not_implemented = \"HTTP/1.0 501 Not Implemented \\r\\n \" ; const std :: string bad_gateway = \"HTTP/1.0 502 Bad Gateway \\r\\n \" ; const std :: string service_unavailable = \"HTTP/1.0 503 Service Unavailable \\r\\n \" ; asio :: const_buffer to_buffer ( reply :: status_type status ) { switch ( status ) { case reply :: ok : return asio :: buffer ( ok ); case reply :: created : return asio :: buffer ( created ); case reply :: accepted : return asio :: buffer ( accepted ); case reply :: no_content : return asio :: buffer ( no_content ); case reply :: multiple_choices : return asio :: buffer ( multiple_choices ); case reply :: moved_permanently : return asio :: buffer ( moved_permanently ); case reply :: moved_temporarily : return asio :: buffer ( moved_temporarily ); case reply :: not_modified : return asio :: buffer ( not_modified ); case reply :: bad_request : return asio :: buffer ( bad_request ); case reply :: unauthorized : return asio :: buffer ( unauthorized ); case reply :: forbidden : return asio :: buffer ( forbidden ); case reply :: not_found : return asio :: buffer ( not_found ); case reply :: internal_server_error : return asio :: buffer ( internal_server_error ); case reply :: not_implemented : return asio :: buffer ( not_implemented ); case reply :: bad_gateway : return asio :: buffer ( bad_gateway ); case reply :: service_unavailable : return asio :: buffer ( service_unavailable ); default : return asio :: buffer ( internal_server_error ); } } } // namespace status_strings namespace misc_strings { const char name_value_separator [] = { ':' , ' ' }; const char crlf [] = { '\\r' , '\\n' }; } // namespace misc_strings std :: vector < asio :: const_buffer > reply :: to_buffers () { std :: vector < asio :: const_buffer > buffers ; buffers . push_back ( status_strings :: to_buffer ( status )); for ( std :: size_t i = 0 ; i < headers . size (); ++ i ) { header & h = headers [ i ]; buffers . push_back ( asio :: buffer ( h . name )); buffers . push_back ( asio :: buffer ( misc_strings :: name_value_separator )); buffers . push_back ( asio :: buffer ( h . value )); buffers . push_back ( asio :: buffer ( misc_strings :: crlf )); } buffers . push_back ( asio :: buffer ( misc_strings :: crlf )); buffers . push_back ( asio :: buffer ( content )); return buffers ; } namespace stock_replies { namespace as_string { constexpr char ok [] = \"\" ; constexpr char created [] = \"<html>\" \"<head><title>Created</title></head>\" \"<body><h1>201 Created</h1></body>\" \"</html>\" ; constexpr char accepted [] = \"<html>\" \"<head><title>Accepted</title></head>\" \"<body><h1>202 Accepted</h1></body>\" \"</html>\" ; constexpr char no_content [] = \"<html>\" \"<head><title>No Content</title></head>\" \"<body><h1>204 Content</h1></body>\" \"</html>\" ; constexpr char multiple_choices [] = \"<html>\" \"<head><title>Multiple Choices</title></head>\" \"<body><h1>300 Multiple Choices</h1></body>\" \"</html>\" ; constexpr char moved_permanently [] = \"<html>\" \"<head><title>Moved Permanently</title></head>\" \"<body><h1>301 Moved Permanently</h1></body>\" \"</html>\" ; constexpr char moved_temporarily [] = \"<html>\" \"<head><title>Moved Temporarily</title></head>\" \"<body><h1>302 Moved Temporarily</h1></body>\" \"</html>\" ; constexpr char not_modified [] = \"<html>\" \"<head><title>Not Modified</title></head>\" \"<body><h1>304 Not Modified</h1></body>\" \"</html>\" ; constexpr char bad_request [] = \"<html>\" \"<head><title>Bad Request</title></head>\" \"<body><h1>400 Bad Request</h1></body>\" \"</html>\" ; constexpr char unauthorized [] = \"<html>\" \"<head><title>Unauthorized</title></head>\" \"<body><h1>401 Unauthorized</h1></body>\" \"</html>\" ; constexpr char forbidden [] = \"<html>\" \"<head><title>Forbidden</title></head>\" \"<body><h1>403 Forbidden</h1></body>\" \"</html>\" ; constexpr char not_found [] = \"<html>\" \"<head><title>Not Found</title></head>\" \"<body><h1>404 Not Found</h1></body>\" \"</html>\" ; constexpr char internal_server_error [] = \"<html>\" \"<head><title>Internal Server Error</title></head>\" \"<body><h1>500 Internal Server Error</h1></body>\" \"</html>\" ; constexpr char not_implemented [] = \"<html>\" \"<head><title>Not Implemented</title></head>\" \"<body><h1>501 Not Implemented</h1></body>\" \"</html>\" ; constexpr char bad_gateway [] = \"<html>\" \"<head><title>Bad Gateway</title></head>\" \"<body><h1>502 Bad Gateway</h1></body>\" \"</html>\" ; constexpr char service_unavailable [] = \"<html>\" \"<head><title>Service Unavailable</title></head>\" \"<body><h1>503 Service Unavailable</h1></body>\" \"</html>\" ; } // namespace as_string std :: string to_string ( reply :: status_type status ) { switch ( status ) { case reply :: ok : // NOLINT(bugprone-branch-clone) return as_string :: ok ; case reply :: created : return as_string :: created ; case reply :: accepted : return as_string :: accepted ; case reply :: no_content : return as_string :: no_content ; case reply :: multiple_choices : return as_string :: multiple_choices ; case reply :: moved_permanently : return as_string :: moved_permanently ; case reply :: moved_temporarily : return as_string :: moved_temporarily ; case reply :: not_modified : return as_string :: not_modified ; case reply :: bad_request : return as_string :: bad_request ; case reply :: unauthorized : return as_string :: unauthorized ; case reply :: forbidden : return as_string :: forbidden ; case reply :: not_found : return as_string :: not_found ; case reply :: internal_server_error : return as_string :: internal_server_error ; case reply :: not_implemented : return as_string :: not_implemented ; case reply :: bad_gateway : return as_string :: bad_gateway ; case reply :: service_unavailable : return as_string :: service_unavailable ; default : return as_string :: internal_server_error ; } } } // namespace stock_replies reply reply :: stock_reply ( reply :: status_type status ) { reply rep ; rep . status = status ; rep . headers . resize ( 2 ); rep . headers [ 0 ]. name = \"Content-Length\" ; rep . content = stock_replies :: to_string ( status ); rep . headers [ 0 ]. value = std :: to_string ( rep . content . size ()); rep . headers [ 1 ]. name = \"Content-Type\" ; rep . headers [ 1 ]. value = \"text/html\" ; return rep ; } } // namespace http::server request_handler.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 // // request_handler.cpp // ~~~~~~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"request_handler.hpp\" #include \"mime_types.hpp\" #include \"reply.hpp\" #include \"request.hpp\" #include <fstream> #include <sstream> #include <string> #include <utility> namespace http :: server { request_handler :: request_handler ( const std :: string & doc_root ) : doc_root_ ( doc_root ) {} void request_handler :: handle_request ( const request & req , reply & rep ) { // Decode url to path. std :: string request_path ; if ( ! url_decode ( req . uri , request_path )) { rep = reply :: stock_reply ( reply :: bad_request ); return ; } // Request path must be absolute and not contain \"..\". if ( request_path . empty () || request_path [ 0 ] != '/' || request_path . find ( \"..\" ) != std :: string :: npos ) { rep = reply :: stock_reply ( reply :: bad_request ); return ; } // If path ends in slash (i.e. is a directory) then add // \"index.html\". if ( request_path [ request_path . size () - 1 ] == '/' ) { request_path += \"index.html\" ; } // Determine the file extension. std :: size_t last_slash_pos = request_path . find_last_of ( \"/\" ); std :: size_t last_dot_pos = request_path . find_last_of ( \".\" ); std :: string extension ; if ( last_dot_pos != std :: string :: npos && last_dot_pos > last_slash_pos ) { extension = request_path . substr ( last_dot_pos + 1 ); } // Open the file to send back. std :: string full_path = doc_root_ + request_path ; std :: ifstream is ( full_path . c_str (), std :: ios :: in | std :: ios :: binary ); if ( ! is ) { rep = reply :: stock_reply ( reply :: not_found ); return ; } // Fill out the reply to be sent to the client. rep . status = reply :: ok ; char buf [ 512 ]; while ( is . read ( buf , sizeof ( buf )). gcount () > 0 ) rep . content . append ( buf , is . gcount ()); rep . headers . resize ( 2 ); rep . headers [ 0 ]. name = \"Content-Length\" ; rep . headers [ 0 ]. value = std :: to_string ( rep . content . size ()); rep . headers [ 1 ]. name = \"Content-Type\" ; rep . headers [ 1 ]. value = mime_types :: extension_to_type ( extension ); } bool request_handler :: url_decode ( const std :: string & in , std :: string & out ) { out . clear (); out . reserve ( in . size ()); for ( std :: size_t i = 0 ; i < in . size (); ++ i ) { if ( in [ i ] == '%' ) { if ( i + 3 <= in . size ()) { int value = 0 ; std :: istringstream is ( in . substr ( i + 1 , 2 )); if ( is >> std :: hex >> value ) { out += static_cast < char > ( value ); i += 2 ; } else { return false ; } } else { return false ; } } else if ( in [ i ] == '+' ) { out += ' ' ; } else { out += in [ i ]; } } return true ; } } // namespace http::server connection.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // // connection.cpp // ~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"connection.hpp\" #include \"connection_manager.hpp\" #include \"request_handler.hpp\" #include <utility> #include <vector> namespace http :: server { connection :: connection ( asio :: ip :: tcp :: socket socket , connection_manager & manager , request_handler & handler ) : socket_ ( std :: move ( socket )), connection_manager_ ( manager ), request_handler_ ( handler ) {} void connection :: start () { do_read (); } void connection :: stop () { socket_ . close (); } void connection :: do_read () { auto self ( shared_from_this ()); socket_ . async_read_some ( asio :: buffer ( buffer_ ), [ this , self ]( std :: error_code ec , std :: size_t bytes_transferred ) { if ( ! ec ) { request_parser :: result_type result ; std :: tie ( result , std :: ignore ) = request_parser_ . parse ( request_ , buffer_ . data (), buffer_ . data () + bytes_transferred ); if ( result == request_parser :: good ) { request_handler_ . handle_request ( request_ , reply_ ); do_write (); } else if ( result == request_parser :: bad ) { reply_ = reply :: stock_reply ( reply :: bad_request ); do_write (); } else { do_read (); } } else if ( ec != asio :: error :: operation_aborted ) { connection_manager_ . stop ( shared_from_this ()); } }); } void connection :: do_write () { auto self ( shared_from_this ()); asio :: async_write ( socket_ , reply_ . to_buffers (), [ this , self ]( std :: error_code ec , std :: size_t ) { if ( ! ec ) { // Initiate graceful connection closure. asio :: error_code ignored_ec ; socket_ . shutdown ( asio :: ip :: tcp :: socket :: shutdown_both , ignored_ec ); } if ( ec != asio :: error :: operation_aborted ) { connection_manager_ . stop ( shared_from_this ()); } }); } } // namespace http::server connection_manager.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // // connection_manager.cpp // ~~~~~~~~~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"connection_manager.hpp\" namespace http :: server { connection_manager :: connection_manager () = default ; void connection_manager :: start ( connection_ptr c ) { connections_ . insert ( c ); c -> start (); } void connection_manager :: stop ( connection_ptr c ) { connections_ . erase ( c ); c -> stop (); } void connection_manager :: stop_all () { for ( auto c : connections_ ) c -> stop (); connections_ . clear (); } } // namespace http::server server.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 // // server.cpp // ~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"server.hpp\" #include <csignal> #include <utility> namespace http :: server { server :: server ( const std :: string & address , const std :: string & port , const std :: string & doc_root ) : io_context_ ( 1 ), signals_ ( io_context_ ), acceptor_ ( io_context_ ), connection_manager_ (), request_handler_ ( doc_root ) { setup_signals (); setup_acceptor ( address , port ); } void server :: setup_acceptor ( const std :: string & address , const std :: string & port ) { // Open the acceptor with the option to // reuse the address (i.e. // SO_REUSEADDR). asio :: ip :: tcp :: resolver resolver ( io_context_ ); asio :: ip :: tcp :: endpoint endpoint = * resolver . resolve ( address , port ). begin (); acceptor_ . open ( endpoint . protocol ()); acceptor_ . set_option ( asio :: socket_base :: reuse_address ( true )); acceptor_ . bind ( endpoint ); acceptor_ . listen (); do_accept (); } void server :: setup_signals () { // Register to handle the signals that // indicate when the server // should exit. It is safe to register for the same signal multiple // times in a program, provided all registration for the specified // signal is made through Asio. signals_ . add ( SIGINT ); signals_ . add ( SIGTERM ); #if defined(SIGQUIT) signals_ . add ( SIGQUIT ); #endif // defined(SIGQUIT) do_await_stop (); } void server :: run () { // The io_context::run() call will block until all asynchronous // operations have finished. While the server is running, there is // always at least one asynchronous operation outstanding: the // asynchronous accept call waiting for new incoming connections. for ( size_t i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool_ , [ & ] { io_context_ . run (); }); } pool_ . join (); } void server :: do_accept () { acceptor_ . async_accept ([ this ]( std :: error_code ec , asio :: ip :: tcp :: socket socket ) { // Check whether the server was stopped by a signal before // this completion handler had a chance to run. if ( ! acceptor_ . is_open ()) { return ; } if ( ! ec ) { connection_manager_ . start ( std :: make_shared < connection > ( std :: move ( socket ), connection_manager_ , request_handler_ )); } do_accept (); }); } void server :: do_await_stop () { signals_ . async_wait ([ this ]( std :: error_code /*ec*/ , int /*signo*/ ) { // The server is stopped by cancelling all outstanding // asynchronous operations. Once all operations have finished // the io_context::run() call will exit. acceptor_ . close (); connection_manager_ . stop_all (); }); } } // namespace http::server","title":"Http server"},{"location":"utilities/networking/http-server/#http-server","text":"main.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // // main.cpp // ~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"server.hpp\" #include <iostream> #include <string> int main ( int argc , char * argv []) { // - Move this to examples // - Replace these snippets with an http server library try { // Check command line arguments. if ( argc != 4 ) { std :: cout << \"Usage: http_server <address> <port> <doc_root> \\n \" ; std :: cout << \" For IPv4, try: \" ; std :: cout << \" receiver 0.0.0.0 80 . \\n \" ; std :: cout << \" For IPv6, try: \" ; std :: cout << \" receiver 0::0 80 . \\n \" ; } // Initialise the server std :: string address = argc > 1 ? argv [ 1 ] : \"0.0.0.0\" ; std :: string port = argc > 2 ? argv [ 2 ] : \"80\" ; std :: string doc_root = argc > 3 ? argv [ 3 ] : \".\" ; std :: cout << \"Server address: http://\" << address << \":\" << port << '\\n' ; http :: server :: server s ( address , port , doc_root ); // Run the server until stopped. s . run (); } catch ( std :: exception & e ) { std :: cerr << \"exception: \" << e . what () << \" \\n \" ; } return 0 ; } server.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // // server.hpp // ~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_SERVER_HPP #define HTTP_SERVER_HPP #include \"connection.hpp\" #include \"connection_manager.hpp\" #include \"request_handler.hpp\" #include <asio.hpp> #include <string> namespace http :: server { /// The top-level class of the HTTP server. class server { public : server ( const server & ) = delete ; server & operator = ( const server & ) = delete ; /// Construct the server to listen on the specified TCP address and /// port, and serve up files from the given directory. explicit server ( const std :: string & address , const std :: string & port , const std :: string & doc_root ); /// Run the server's io_context loop. void run (); private : /// Perform an asynchronous accept operation. void do_accept (); /// Wait for a request to stop the server. void do_await_stop (); /// The io_context used to perform asynchronous operations. asio :: io_context io_context_ ; /// Executor for the io context asio :: thread_pool pool_ ; /// The signal_set is used to register for process termination /// notifications. asio :: signal_set signals_ ; /// Acceptor used to listen for incoming connections. asio :: ip :: tcp :: acceptor acceptor_ ; /// The connection manager which owns all live connections. connection_manager connection_manager_ ; /// The handler for all incoming requests. request_handler request_handler_ ; void setup_signals (); void setup_acceptor ( const std :: string & address , const std :: string & port ); }; } // namespace http::server #endif // HTTP_SERVER_HPP connection_manager.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // // connection_manager.hpp // ~~~~~~~~~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_CONNECTION_MANAGER_HPP #define HTTP_CONNECTION_MANAGER_HPP #include \"connection.hpp\" #include <set> namespace http :: server { /// Manages open connections so that they may be cleanly stopped when /// the server needs to shut down. class connection_manager { public : connection_manager ( const connection_manager & ) = delete ; connection_manager & operator = ( const connection_manager & ) = delete ; /// Construct a connection manager. connection_manager (); /// Add the specified connection to the manager and start it. void start ( connection_ptr c ); /// Stop the specified connection. void stop ( connection_ptr c ); /// Stop all connections. void stop_all (); private : /// The managed connections. std :: set < connection_ptr > connections_ ; }; } // namespace http::server #endif // HTTP_CONNECTION_MANAGER_HPP connection.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // // connection.hpp // ~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_CONNECTION_HPP #define HTTP_CONNECTION_HPP #include \"reply.hpp\" #include \"request.hpp\" #include \"request_handler.hpp\" #include \"request_parser.hpp\" #include <array> #include <asio.hpp> #include <memory> namespace http :: server { class connection_manager ; /// Represents a single connection from a client. class connection : public std :: enable_shared_from_this < connection > { public : connection ( const connection & ) = delete ; connection & operator = ( const connection & ) = delete ; /// Construct a connection with the given socket. explicit connection ( asio :: ip :: tcp :: socket socket , connection_manager & manager , request_handler & handler ); /// Start the first asynchronous operation for the connection. void start (); /// Stop all asynchronous operations associated with the connection. void stop (); private : /// Perform an asynchronous read operation. void do_read (); /// Perform an asynchronous write operation. void do_write (); /// Socket for the connection. asio :: ip :: tcp :: socket socket_ ; /// The manager for this connection. connection_manager & connection_manager_ ; /// The handler used to process the incoming request. request_handler & request_handler_ ; /// Buffer for incoming data. std :: array < char , 8192 > buffer_ ; /// The incoming request. request request_ ; /// The parser for the incoming request. request_parser request_parser_ ; /// The reply to be sent back to the client. reply reply_ ; }; typedef std :: shared_ptr < connection > connection_ptr ; } // namespace http::server #endif // HTTP_CONNECTION_HPP header.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // // header.hpp // ~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_HEADER_HPP #define HTTP_HEADER_HPP #include <string> namespace http :: server { struct header { std :: string name ; std :: string value ; }; } // namespace http::server #endif // HTTP_HEADER_HPP reply.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // // reply.hpp // ~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_REPLY_HPP #define HTTP_REPLY_HPP #include \"header.hpp\" #include <asio.hpp> #include <string> #include <vector> namespace http :: server { /// A reply to be sent to a client. struct reply { /// The status of the reply. enum status_type { ok = 200 , created = 201 , accepted = 202 , no_content = 204 , multiple_choices = 300 , moved_permanently = 301 , moved_temporarily = 302 , not_modified = 304 , bad_request = 400 , unauthorized = 401 , forbidden = 403 , not_found = 404 , internal_server_error = 500 , not_implemented = 501 , bad_gateway = 502 , service_unavailable = 503 } status ; /// The headers to be included in the reply. std :: vector < header > headers ; /// The content to be sent in the reply. std :: string content ; /// Convert the reply into a vector of buffers. The buffers do not /// own the underlying memory blocks, therefore the reply object /// must remain valid and not be changed until the write operation /// has completed. std :: vector < asio :: const_buffer > to_buffers (); /// Get a stock reply. static reply stock_reply ( status_type status ); }; } // namespace http::server #endif // HTTP_REPLY_HPP request.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // // request.hpp // ~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_REQUEST_HPP #define HTTP_REQUEST_HPP #include \"header.hpp\" #include <string> #include <vector> namespace http :: server { /// A request received from a client. struct request { std :: string method ; std :: string uri ; int http_version_major ; int http_version_minor ; std :: vector < header > headers ; }; } // namespace http::server #endif // HTTP_REQUEST_HPP request_parser.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 // // request_parser.hpp // ~~~~~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_REQUEST_PARSER_HPP #define HTTP_REQUEST_PARSER_HPP #include <tuple> namespace http :: server { struct request ; /// Parser for incoming requests. class request_parser { public : /// Construct ready to parse the request method. request_parser (); /// Reset to initial parser state. void reset (); /// Result of parse. enum result_type { good , bad , indeterminate }; /// Parse some data. The enum return value is good when a complete /// request has been parsed, bad if the data is invalid, /// indeterminate when more data is required. The InputIterator /// return value indicates how much of the input has been consumed. template < typename InputIterator > std :: tuple < result_type , InputIterator > parse ( request & req , InputIterator begin , InputIterator end ) { while ( begin != end ) { result_type result = consume ( req , * begin ++ ); if ( result == good || result == bad ) return std :: make_tuple ( result , begin ); } return std :: make_tuple ( indeterminate , begin ); } private : /// Handle the next character of input. result_type consume ( request & req , char input ); /// Check if a byte is an HTTP character. static bool is_char ( int c ); /// Check if a byte is an HTTP control character. static bool is_ctl ( int c ); /// Check if a byte is defined as an HTTP tspecial character. static bool is_tspecial ( int c ); /// Check if a byte is a digit. static bool is_digit ( int c ); /// The current state of the parser. enum state { method_start , method , uri , http_version_h , http_version_t_1 , http_version_t_2 , http_version_p , http_version_slash , http_version_major_start , http_version_major , http_version_minor_start , http_version_minor , expecting_newline_1 , header_line_start , header_lws , header_name , space_before_header_value , header_value , expecting_newline_2 , expecting_newline_3 } state_ ; }; } // namespace http::server #endif // HTTP_REQUEST_PARSER_HPP mime_types.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // // mime_types.hpp // ~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_MIME_TYPES_HPP #define HTTP_MIME_TYPES_HPP #include <string> namespace http :: server :: mime_types { /// Convert a file extension into a MIME type. std :: string extension_to_type ( const std :: string & extension ); } // namespace http::server::mime_types #endif // HTTP_MIME_TYPES_HPP request_handler.hpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // // request_handler.hpp // ~~~~~~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #ifndef HTTP_REQUEST_HANDLER_HPP #define HTTP_REQUEST_HANDLER_HPP #include <string> namespace http :: server { struct reply ; struct request ; /// The common handler for all incoming requests. class request_handler { public : request_handler ( const request_handler & ) = delete ; request_handler & operator = ( const request_handler & ) = delete ; /// Construct with a directory containing files to be served. explicit request_handler ( const std :: string & doc_root ); /// Handle a request and produce a reply. void handle_request ( const request & req , reply & rep ); private : /// The directory containing the files to be served. std :: string doc_root_ ; /// Perform URL-decoding on a string. Returns false if the encoding /// was invalid. static bool url_decode ( const std :: string & in , std :: string & out ); }; } // namespace http::server #endif // HTTP_REQUEST_HANDLER_HPP mime_types.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // // mime_types.cpp // ~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"mime_types.hpp\" namespace http :: server :: mime_types { constexpr struct mapping { const char * extension ; const char * mime_type ; } mappings [] = {{ \"gif\" , \"image/gif\" }, { \"htm\" , \"text/html\" }, { \"html\" , \"text/html\" }, { \"jpg\" , \"image/jpeg\" }, { \"png\" , \"image/png\" }}; std :: string extension_to_type ( const std :: string & extension ) { for ( mapping m : mappings ) { if ( m . extension == extension ) { return m . mime_type ; } } return \"text/plain\" ; } } // namespace http::server::mime_types request_parser.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 // // request_parser.cpp // ~~~~~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"request_parser.hpp\" #include \"request.hpp\" namespace http :: server { request_parser :: request_parser () : state_ ( method_start ) {} void request_parser :: reset () { state_ = method_start ; } request_parser :: result_type request_parser :: consume ( request & req , char input ) { switch ( state_ ) { case method_start : if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { state_ = method ; req . method . push_back ( input ); return indeterminate ; } case method : if ( input == ' ' ) { state_ = uri ; return indeterminate ; } else if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { req . method . push_back ( input ); return indeterminate ; } case uri : if ( input == ' ' ) { state_ = http_version_h ; return indeterminate ; } else if ( is_ctl ( input )) { return bad ; } else { req . uri . push_back ( input ); return indeterminate ; } case http_version_h : if ( input == 'H' ) { state_ = http_version_t_1 ; return indeterminate ; } else { return bad ; } case http_version_t_1 : if ( input == 'T' ) { state_ = http_version_t_2 ; return indeterminate ; } else { return bad ; } case http_version_t_2 : if ( input == 'T' ) { state_ = http_version_p ; return indeterminate ; } else { return bad ; } case http_version_p : if ( input == 'P' ) { state_ = http_version_slash ; return indeterminate ; } else { return bad ; } case http_version_slash : if ( input == '/' ) { req . http_version_major = 0 ; req . http_version_minor = 0 ; state_ = http_version_major_start ; return indeterminate ; } else { return bad ; } case http_version_major_start : if ( is_digit ( input )) { req . http_version_major = req . http_version_major * 10 + input - '0' ; state_ = http_version_major ; return indeterminate ; } else { return bad ; } case http_version_major : if ( input == '.' ) { state_ = http_version_minor_start ; return indeterminate ; } else if ( is_digit ( input )) { req . http_version_major = req . http_version_major * 10 + input - '0' ; return indeterminate ; } else { return bad ; } case http_version_minor_start : if ( is_digit ( input )) { req . http_version_minor = req . http_version_minor * 10 + input - '0' ; state_ = http_version_minor ; return indeterminate ; } else { return bad ; } case http_version_minor : if ( input == '\\r' ) { state_ = expecting_newline_1 ; return indeterminate ; } else if ( is_digit ( input )) { req . http_version_minor = req . http_version_minor * 10 + input - '0' ; return indeterminate ; } else { return bad ; } case expecting_newline_1 : if ( input == '\\n' ) { state_ = header_line_start ; return indeterminate ; } else { return bad ; } case header_line_start : if ( input == '\\r' ) { state_ = expecting_newline_3 ; return indeterminate ; } else if ( ! req . headers . empty () && ( input == ' ' || input == '\\t' )) { state_ = header_lws ; return indeterminate ; } else if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { req . headers . push_back ( header ()); req . headers . back (). name . push_back ( input ); state_ = header_name ; return indeterminate ; } case header_lws : if ( input == '\\r' ) { state_ = expecting_newline_2 ; return indeterminate ; } else if ( input == ' ' || input == '\\t' ) { return indeterminate ; } else if ( is_ctl ( input )) { return bad ; } else { state_ = header_value ; req . headers . back (). value . push_back ( input ); return indeterminate ; } case header_name : if ( input == ':' ) { state_ = space_before_header_value ; return indeterminate ; } else if ( ! is_char ( input ) || is_ctl ( input ) || is_tspecial ( input )) { return bad ; } else { req . headers . back (). name . push_back ( input ); return indeterminate ; } case space_before_header_value : if ( input == ' ' ) { state_ = header_value ; return indeterminate ; } else { return bad ; } case header_value : if ( input == '\\r' ) { state_ = expecting_newline_2 ; return indeterminate ; } else if ( is_ctl ( input )) { return bad ; } else { req . headers . back (). value . push_back ( input ); return indeterminate ; } case expecting_newline_2 : if ( input == '\\n' ) { state_ = header_line_start ; return indeterminate ; } else { return bad ; } case expecting_newline_3 : return ( input == '\\n' ) ? good : bad ; default : return bad ; } } bool request_parser :: is_char ( int c ) { return c >= 0 && c <= 127 ; } bool request_parser :: is_ctl ( int c ) { return ( c >= 0 && c <= 31 ) || ( c == 127 ); } bool request_parser :: is_tspecial ( int c ) { switch ( c ) { case '(' : case ')' : case '<' : case '>' : case '@' : case ',' : case ';' : case ':' : case '\\\\' : case '\"' : case '/' : case '[' : case ']' : case '?' : case '=' : case '{' : case '}' : case ' ' : case '\\t' : return true ; default : return false ; } } bool request_parser :: is_digit ( int c ) { return c >= '0' && c <= '9' ; } } // namespace http::server reply.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 // // reply.cpp // ~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"reply.hpp\" #include <string> namespace http :: server { namespace status_strings { const std :: string ok = \"HTTP/1.0 200 OK \\r\\n \" ; const std :: string created = \"HTTP/1.0 201 Created \\r\\n \" ; const std :: string accepted = \"HTTP/1.0 202 Accepted \\r\\n \" ; const std :: string no_content = \"HTTP/1.0 204 No Content \\r\\n \" ; const std :: string multiple_choices = \"HTTP/1.0 300 Multiple Choices \\r\\n \" ; const std :: string moved_permanently = \"HTTP/1.0 301 Moved Permanently \\r\\n \" ; const std :: string moved_temporarily = \"HTTP/1.0 302 Moved Temporarily \\r\\n \" ; const std :: string not_modified = \"HTTP/1.0 304 Not Modified \\r\\n \" ; const std :: string bad_request = \"HTTP/1.0 400 Bad Request \\r\\n \" ; const std :: string unauthorized = \"HTTP/1.0 401 Unauthorized \\r\\n \" ; const std :: string forbidden = \"HTTP/1.0 403 Forbidden \\r\\n \" ; const std :: string not_found = \"HTTP/1.0 404 Not Found \\r\\n \" ; const std :: string internal_server_error = \"HTTP/1.0 500 Internal Server Error \\r\\n \" ; const std :: string not_implemented = \"HTTP/1.0 501 Not Implemented \\r\\n \" ; const std :: string bad_gateway = \"HTTP/1.0 502 Bad Gateway \\r\\n \" ; const std :: string service_unavailable = \"HTTP/1.0 503 Service Unavailable \\r\\n \" ; asio :: const_buffer to_buffer ( reply :: status_type status ) { switch ( status ) { case reply :: ok : return asio :: buffer ( ok ); case reply :: created : return asio :: buffer ( created ); case reply :: accepted : return asio :: buffer ( accepted ); case reply :: no_content : return asio :: buffer ( no_content ); case reply :: multiple_choices : return asio :: buffer ( multiple_choices ); case reply :: moved_permanently : return asio :: buffer ( moved_permanently ); case reply :: moved_temporarily : return asio :: buffer ( moved_temporarily ); case reply :: not_modified : return asio :: buffer ( not_modified ); case reply :: bad_request : return asio :: buffer ( bad_request ); case reply :: unauthorized : return asio :: buffer ( unauthorized ); case reply :: forbidden : return asio :: buffer ( forbidden ); case reply :: not_found : return asio :: buffer ( not_found ); case reply :: internal_server_error : return asio :: buffer ( internal_server_error ); case reply :: not_implemented : return asio :: buffer ( not_implemented ); case reply :: bad_gateway : return asio :: buffer ( bad_gateway ); case reply :: service_unavailable : return asio :: buffer ( service_unavailable ); default : return asio :: buffer ( internal_server_error ); } } } // namespace status_strings namespace misc_strings { const char name_value_separator [] = { ':' , ' ' }; const char crlf [] = { '\\r' , '\\n' }; } // namespace misc_strings std :: vector < asio :: const_buffer > reply :: to_buffers () { std :: vector < asio :: const_buffer > buffers ; buffers . push_back ( status_strings :: to_buffer ( status )); for ( std :: size_t i = 0 ; i < headers . size (); ++ i ) { header & h = headers [ i ]; buffers . push_back ( asio :: buffer ( h . name )); buffers . push_back ( asio :: buffer ( misc_strings :: name_value_separator )); buffers . push_back ( asio :: buffer ( h . value )); buffers . push_back ( asio :: buffer ( misc_strings :: crlf )); } buffers . push_back ( asio :: buffer ( misc_strings :: crlf )); buffers . push_back ( asio :: buffer ( content )); return buffers ; } namespace stock_replies { namespace as_string { constexpr char ok [] = \"\" ; constexpr char created [] = \"<html>\" \"<head><title>Created</title></head>\" \"<body><h1>201 Created</h1></body>\" \"</html>\" ; constexpr char accepted [] = \"<html>\" \"<head><title>Accepted</title></head>\" \"<body><h1>202 Accepted</h1></body>\" \"</html>\" ; constexpr char no_content [] = \"<html>\" \"<head><title>No Content</title></head>\" \"<body><h1>204 Content</h1></body>\" \"</html>\" ; constexpr char multiple_choices [] = \"<html>\" \"<head><title>Multiple Choices</title></head>\" \"<body><h1>300 Multiple Choices</h1></body>\" \"</html>\" ; constexpr char moved_permanently [] = \"<html>\" \"<head><title>Moved Permanently</title></head>\" \"<body><h1>301 Moved Permanently</h1></body>\" \"</html>\" ; constexpr char moved_temporarily [] = \"<html>\" \"<head><title>Moved Temporarily</title></head>\" \"<body><h1>302 Moved Temporarily</h1></body>\" \"</html>\" ; constexpr char not_modified [] = \"<html>\" \"<head><title>Not Modified</title></head>\" \"<body><h1>304 Not Modified</h1></body>\" \"</html>\" ; constexpr char bad_request [] = \"<html>\" \"<head><title>Bad Request</title></head>\" \"<body><h1>400 Bad Request</h1></body>\" \"</html>\" ; constexpr char unauthorized [] = \"<html>\" \"<head><title>Unauthorized</title></head>\" \"<body><h1>401 Unauthorized</h1></body>\" \"</html>\" ; constexpr char forbidden [] = \"<html>\" \"<head><title>Forbidden</title></head>\" \"<body><h1>403 Forbidden</h1></body>\" \"</html>\" ; constexpr char not_found [] = \"<html>\" \"<head><title>Not Found</title></head>\" \"<body><h1>404 Not Found</h1></body>\" \"</html>\" ; constexpr char internal_server_error [] = \"<html>\" \"<head><title>Internal Server Error</title></head>\" \"<body><h1>500 Internal Server Error</h1></body>\" \"</html>\" ; constexpr char not_implemented [] = \"<html>\" \"<head><title>Not Implemented</title></head>\" \"<body><h1>501 Not Implemented</h1></body>\" \"</html>\" ; constexpr char bad_gateway [] = \"<html>\" \"<head><title>Bad Gateway</title></head>\" \"<body><h1>502 Bad Gateway</h1></body>\" \"</html>\" ; constexpr char service_unavailable [] = \"<html>\" \"<head><title>Service Unavailable</title></head>\" \"<body><h1>503 Service Unavailable</h1></body>\" \"</html>\" ; } // namespace as_string std :: string to_string ( reply :: status_type status ) { switch ( status ) { case reply :: ok : // NOLINT(bugprone-branch-clone) return as_string :: ok ; case reply :: created : return as_string :: created ; case reply :: accepted : return as_string :: accepted ; case reply :: no_content : return as_string :: no_content ; case reply :: multiple_choices : return as_string :: multiple_choices ; case reply :: moved_permanently : return as_string :: moved_permanently ; case reply :: moved_temporarily : return as_string :: moved_temporarily ; case reply :: not_modified : return as_string :: not_modified ; case reply :: bad_request : return as_string :: bad_request ; case reply :: unauthorized : return as_string :: unauthorized ; case reply :: forbidden : return as_string :: forbidden ; case reply :: not_found : return as_string :: not_found ; case reply :: internal_server_error : return as_string :: internal_server_error ; case reply :: not_implemented : return as_string :: not_implemented ; case reply :: bad_gateway : return as_string :: bad_gateway ; case reply :: service_unavailable : return as_string :: service_unavailable ; default : return as_string :: internal_server_error ; } } } // namespace stock_replies reply reply :: stock_reply ( reply :: status_type status ) { reply rep ; rep . status = status ; rep . headers . resize ( 2 ); rep . headers [ 0 ]. name = \"Content-Length\" ; rep . content = stock_replies :: to_string ( status ); rep . headers [ 0 ]. value = std :: to_string ( rep . content . size ()); rep . headers [ 1 ]. name = \"Content-Type\" ; rep . headers [ 1 ]. value = \"text/html\" ; return rep ; } } // namespace http::server request_handler.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 // // request_handler.cpp // ~~~~~~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"request_handler.hpp\" #include \"mime_types.hpp\" #include \"reply.hpp\" #include \"request.hpp\" #include <fstream> #include <sstream> #include <string> #include <utility> namespace http :: server { request_handler :: request_handler ( const std :: string & doc_root ) : doc_root_ ( doc_root ) {} void request_handler :: handle_request ( const request & req , reply & rep ) { // Decode url to path. std :: string request_path ; if ( ! url_decode ( req . uri , request_path )) { rep = reply :: stock_reply ( reply :: bad_request ); return ; } // Request path must be absolute and not contain \"..\". if ( request_path . empty () || request_path [ 0 ] != '/' || request_path . find ( \"..\" ) != std :: string :: npos ) { rep = reply :: stock_reply ( reply :: bad_request ); return ; } // If path ends in slash (i.e. is a directory) then add // \"index.html\". if ( request_path [ request_path . size () - 1 ] == '/' ) { request_path += \"index.html\" ; } // Determine the file extension. std :: size_t last_slash_pos = request_path . find_last_of ( \"/\" ); std :: size_t last_dot_pos = request_path . find_last_of ( \".\" ); std :: string extension ; if ( last_dot_pos != std :: string :: npos && last_dot_pos > last_slash_pos ) { extension = request_path . substr ( last_dot_pos + 1 ); } // Open the file to send back. std :: string full_path = doc_root_ + request_path ; std :: ifstream is ( full_path . c_str (), std :: ios :: in | std :: ios :: binary ); if ( ! is ) { rep = reply :: stock_reply ( reply :: not_found ); return ; } // Fill out the reply to be sent to the client. rep . status = reply :: ok ; char buf [ 512 ]; while ( is . read ( buf , sizeof ( buf )). gcount () > 0 ) rep . content . append ( buf , is . gcount ()); rep . headers . resize ( 2 ); rep . headers [ 0 ]. name = \"Content-Length\" ; rep . headers [ 0 ]. value = std :: to_string ( rep . content . size ()); rep . headers [ 1 ]. name = \"Content-Type\" ; rep . headers [ 1 ]. value = mime_types :: extension_to_type ( extension ); } bool request_handler :: url_decode ( const std :: string & in , std :: string & out ) { out . clear (); out . reserve ( in . size ()); for ( std :: size_t i = 0 ; i < in . size (); ++ i ) { if ( in [ i ] == '%' ) { if ( i + 3 <= in . size ()) { int value = 0 ; std :: istringstream is ( in . substr ( i + 1 , 2 )); if ( is >> std :: hex >> value ) { out += static_cast < char > ( value ); i += 2 ; } else { return false ; } } else { return false ; } } else if ( in [ i ] == '+' ) { out += ' ' ; } else { out += in [ i ]; } } return true ; } } // namespace http::server connection.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // // connection.cpp // ~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"connection.hpp\" #include \"connection_manager.hpp\" #include \"request_handler.hpp\" #include <utility> #include <vector> namespace http :: server { connection :: connection ( asio :: ip :: tcp :: socket socket , connection_manager & manager , request_handler & handler ) : socket_ ( std :: move ( socket )), connection_manager_ ( manager ), request_handler_ ( handler ) {} void connection :: start () { do_read (); } void connection :: stop () { socket_ . close (); } void connection :: do_read () { auto self ( shared_from_this ()); socket_ . async_read_some ( asio :: buffer ( buffer_ ), [ this , self ]( std :: error_code ec , std :: size_t bytes_transferred ) { if ( ! ec ) { request_parser :: result_type result ; std :: tie ( result , std :: ignore ) = request_parser_ . parse ( request_ , buffer_ . data (), buffer_ . data () + bytes_transferred ); if ( result == request_parser :: good ) { request_handler_ . handle_request ( request_ , reply_ ); do_write (); } else if ( result == request_parser :: bad ) { reply_ = reply :: stock_reply ( reply :: bad_request ); do_write (); } else { do_read (); } } else if ( ec != asio :: error :: operation_aborted ) { connection_manager_ . stop ( shared_from_this ()); } }); } void connection :: do_write () { auto self ( shared_from_this ()); asio :: async_write ( socket_ , reply_ . to_buffers (), [ this , self ]( std :: error_code ec , std :: size_t ) { if ( ! ec ) { // Initiate graceful connection closure. asio :: error_code ignored_ec ; socket_ . shutdown ( asio :: ip :: tcp :: socket :: shutdown_both , ignored_ec ); } if ( ec != asio :: error :: operation_aborted ) { connection_manager_ . stop ( shared_from_this ()); } }); } } // namespace http::server connection_manager.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // // connection_manager.cpp // ~~~~~~~~~~~~~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"connection_manager.hpp\" namespace http :: server { connection_manager :: connection_manager () = default ; void connection_manager :: start ( connection_ptr c ) { connections_ . insert ( c ); c -> start (); } void connection_manager :: stop ( connection_ptr c ) { connections_ . erase ( c ); c -> stop (); } void connection_manager :: stop_all () { for ( auto c : connections_ ) c -> stop (); connections_ . clear (); } } // namespace http::server server.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 // // server.cpp // ~~~~~~~~~~ // // Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com) // // Distributed under the Boost Software License, Version 1.0. (See accompanying // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) // #include \"server.hpp\" #include <csignal> #include <utility> namespace http :: server { server :: server ( const std :: string & address , const std :: string & port , const std :: string & doc_root ) : io_context_ ( 1 ), signals_ ( io_context_ ), acceptor_ ( io_context_ ), connection_manager_ (), request_handler_ ( doc_root ) { setup_signals (); setup_acceptor ( address , port ); } void server :: setup_acceptor ( const std :: string & address , const std :: string & port ) { // Open the acceptor with the option to // reuse the address (i.e. // SO_REUSEADDR). asio :: ip :: tcp :: resolver resolver ( io_context_ ); asio :: ip :: tcp :: endpoint endpoint = * resolver . resolve ( address , port ). begin (); acceptor_ . open ( endpoint . protocol ()); acceptor_ . set_option ( asio :: socket_base :: reuse_address ( true )); acceptor_ . bind ( endpoint ); acceptor_ . listen (); do_accept (); } void server :: setup_signals () { // Register to handle the signals that // indicate when the server // should exit. It is safe to register for the same signal multiple // times in a program, provided all registration for the specified // signal is made through Asio. signals_ . add ( SIGINT ); signals_ . add ( SIGTERM ); #if defined(SIGQUIT) signals_ . add ( SIGQUIT ); #endif // defined(SIGQUIT) do_await_stop (); } void server :: run () { // The io_context::run() call will block until all asynchronous // operations have finished. While the server is running, there is // always at least one asynchronous operation outstanding: the // asynchronous accept call waiting for new incoming connections. for ( size_t i = 0 ; i < std :: thread :: hardware_concurrency (); ++ i ) { asio :: post ( pool_ , [ & ] { io_context_ . run (); }); } pool_ . join (); } void server :: do_accept () { acceptor_ . async_accept ([ this ]( std :: error_code ec , asio :: ip :: tcp :: socket socket ) { // Check whether the server was stopped by a signal before // this completion handler had a chance to run. if ( ! acceptor_ . is_open ()) { return ; } if ( ! ec ) { connection_manager_ . start ( std :: make_shared < connection > ( std :: move ( socket ), connection_manager_ , request_handler_ )); } do_accept (); }); } void server :: do_await_stop () { signals_ . async_wait ([ this ]( std :: error_code /*ec*/ , int /*signo*/ ) { // The server is stopped by cancelling all outstanding // asynchronous operations. Once all operations have finished // the io_context::run() call will exit. acceptor_ . close (); connection_manager_ . stop_all (); }); } } // namespace http::server","title":"Http server"},{"location":"utilities/networking/network/","text":"Network 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \"asio.hpp\" #include <ctime> #include <iostream> #include <string> using namespace std ; // Create the string to be sent back to the client string make_daytime_string () { time_t now = time ( nullptr ); string r = ctime ( & now ); std :: cout << \"Time requested: \" << r ; return r ; } int main () { try { // Object for network input and output // - All networking programs at least one io_context // - I/O execution context represents your program's link to the // operating system's I/O services asio :: io_context io_context ; // Listen for connections // - Create the simplest server possible asio :: ip :: tcp :: endpoint ep ( asio :: ip :: tcp :: v4 (), 8080 ); asio :: ip :: tcp :: acceptor acceptor ( io_context , ep ); // For loop listening to connections from client // - It will handle one connection at a time // - See the async example for more than one connection at a time while ( true ) { // Connection socket // - Represents the connection to the client asio :: ip :: tcp :: socket socket ( io_context ); // Wait for connection // - Wait for a connection // - Use socket to represent the new connection // - Open http://localhost:8080 in your browser acceptor . accept ( socket ); // Create message to be returned // - The message is the current time string message = make_daytime_string (); // Write response to client // - Transfer this information to the client with the socket error_code error ; asio :: write ( socket , asio :: buffer ( message ), error ); // Check for errors if ( error ) { std :: cout << \"Error \" << error . value () << \": \" << error . message () << std :: endl ; } } } catch ( exception & e ) { // Handle any possible exceptions cerr << e . what () << endl ; } return 0 ; }","title":"Network"},{"location":"utilities/networking/network/#network","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \"asio.hpp\" #include <ctime> #include <iostream> #include <string> using namespace std ; // Create the string to be sent back to the client string make_daytime_string () { time_t now = time ( nullptr ); string r = ctime ( & now ); std :: cout << \"Time requested: \" << r ; return r ; } int main () { try { // Object for network input and output // - All networking programs at least one io_context // - I/O execution context represents your program's link to the // operating system's I/O services asio :: io_context io_context ; // Listen for connections // - Create the simplest server possible asio :: ip :: tcp :: endpoint ep ( asio :: ip :: tcp :: v4 (), 8080 ); asio :: ip :: tcp :: acceptor acceptor ( io_context , ep ); // For loop listening to connections from client // - It will handle one connection at a time // - See the async example for more than one connection at a time while ( true ) { // Connection socket // - Represents the connection to the client asio :: ip :: tcp :: socket socket ( io_context ); // Wait for connection // - Wait for a connection // - Use socket to represent the new connection // - Open http://localhost:8080 in your browser acceptor . accept ( socket ); // Create message to be returned // - The message is the current time string message = make_daytime_string (); // Write response to client // - Transfer this information to the client with the socket error_code error ; asio :: write ( socket , asio :: buffer ( message ), error ); // Check for errors if ( error ) { std :: cout << \"Error \" << error . value () << \": \" << error . message () << std :: endl ; } } } catch ( exception & e ) { // Handle any possible exceptions cerr << e . what () << endl ; } return 0 ; }","title":"Network"},{"location":"utilities/regular-expressions/build-script/","text":"Build script 1 add_executable ( regex regex.cpp )","title":"Build script"},{"location":"utilities/regular-expressions/build-script/#build-script","text":"1 add_executable ( regex regex.cpp )","title":"Build script"},{"location":"utilities/regular-expressions/regex/","text":"Regex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #include <iostream> #include <regex> #include <sstream> #include <string> using namespace std ; int main () { // Test single expression if ( regex_match ( \"subject\" , regex ( \"(sub)(.*)\" ))) { cout << \"subject matches expression (sub)(.*)\" << endl ; } // Test string const char cstr [] = \"subject\" ; string s ( \"subject\" ); regex e ( \"(sub)(.*)\" ); if ( regex_match ( s , e )) { cout << \"subject matches expression (sub)(.*)\" << endl ; } // Test range if ( regex_match ( s . begin (), s . end (), e )) { cout << \"subject matches expression (sub)(.*)\" << endl ; } // Get match results for char* // cmatch is the same as match_results<const char*> cm; cmatch cm ; regex_match ( cstr , cm , e ); cout << \"literal string with \" << cm . size () << \" matches\" << endl ; cout << \"The literal string matches were: \" ; for ( const auto & i : cm ) { cout << \"[\" << i << \"] \" ; } cout << endl ; // Get match results for string // same as match_results<string::const_iterator> sm; smatch sm ; regex_match ( s , sm , e ); cout << \"string object with \" << sm . size () << \" matches\" << endl ; cout << \"The string matches were: \" ; for ( const auto & i : sm ) { cout << \"[\" << i << \"] \" ; } cout << endl ; // Get match results for string range regex_match ( s . cbegin (), s . cend (), sm , e ); cout << sm . size () << \" matches\" << endl ; // Using flags to determine behavior regex_match ( cstr , cm , e , regex_constants :: match_default ); // Iterate substrings with matches std :: string ss = \"foo bar 123\" ; std :: regex r ( \"([a-zA-Z]+)|(d+)\" ); std :: sregex_iterator first_str_match = std :: sregex_iterator ( ss . begin (), ss . end (), r ); for ( auto i = first_str_match ; i != std :: sregex_iterator (); ++ i ) { std :: smatch m = * i ; std :: cout << \"Match value: \" << m . str () << \" at Position \" << m . position () << '\\n' ; for ( size_t index = 1 ; index < m . size (); ++ index ) { if ( ! m [ index ]. str (). empty ()) { std :: cout << \"Capture group ID: \" << index - 1 << std :: endl ; break ; } } } // Concatenate regexes: conjunction string var = \"first second third forth\" ; if ( regex_match ( var , sm , regex ( \"(.*) (.*) (.*) (.*)\" ))) { for ( size_t i = 1 ; i < sm . size (); i ++ ) { cout << \"Match \" << i << \": \" << sm [ i ] << \" at position \" << sm . position ( i ) << endl ; } } // Concatenate regexes: disjunction // This strategy does not work when there are internal capture groups var = \"user/32\" ; smatch sm2 ; auto implode = []( const std :: vector < std :: string > & strs , const std :: string & delim ) { std :: stringstream s ; copy ( strs . begin (), strs . end (), ostream_iterator < string > ( s , delim . c_str ())); return s . str (); }; std :: vector < std :: string > routes = { \"welcome\" , \"user/ \\\\ d+\" , \"post/[a-zA-Z]+\" , \"about\" }; regex disjunction ( \"(\" + implode ( routes , \")|(\" ) + \")\" ); if ( regex_match ( var , sm2 , disjunction , regex_constants :: match_not_null )) { for ( size_t index = 1 ; index < sm2 . size (); ++ index ) { if ( sm2 [ index ]. length () > 0 ) { std :: cout << \"Capture group index: \" << index - 1 << std :: endl ; std :: cout << var << \" matched route \" << routes [ index - 1 ] << std :: endl ; break ; } } } return 0 ; }","title":"Regex"},{"location":"utilities/regular-expressions/regex/#regex","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 #include <iostream> #include <regex> #include <sstream> #include <string> using namespace std ; int main () { // Test single expression if ( regex_match ( \"subject\" , regex ( \"(sub)(.*)\" ))) { cout << \"subject matches expression (sub)(.*)\" << endl ; } // Test string const char cstr [] = \"subject\" ; string s ( \"subject\" ); regex e ( \"(sub)(.*)\" ); if ( regex_match ( s , e )) { cout << \"subject matches expression (sub)(.*)\" << endl ; } // Test range if ( regex_match ( s . begin (), s . end (), e )) { cout << \"subject matches expression (sub)(.*)\" << endl ; } // Get match results for char* // cmatch is the same as match_results<const char*> cm; cmatch cm ; regex_match ( cstr , cm , e ); cout << \"literal string with \" << cm . size () << \" matches\" << endl ; cout << \"The literal string matches were: \" ; for ( const auto & i : cm ) { cout << \"[\" << i << \"] \" ; } cout << endl ; // Get match results for string // same as match_results<string::const_iterator> sm; smatch sm ; regex_match ( s , sm , e ); cout << \"string object with \" << sm . size () << \" matches\" << endl ; cout << \"The string matches were: \" ; for ( const auto & i : sm ) { cout << \"[\" << i << \"] \" ; } cout << endl ; // Get match results for string range regex_match ( s . cbegin (), s . cend (), sm , e ); cout << sm . size () << \" matches\" << endl ; // Using flags to determine behavior regex_match ( cstr , cm , e , regex_constants :: match_default ); // Iterate substrings with matches std :: string ss = \"foo bar 123\" ; std :: regex r ( \"([a-zA-Z]+)|(d+)\" ); std :: sregex_iterator first_str_match = std :: sregex_iterator ( ss . begin (), ss . end (), r ); for ( auto i = first_str_match ; i != std :: sregex_iterator (); ++ i ) { std :: smatch m = * i ; std :: cout << \"Match value: \" << m . str () << \" at Position \" << m . position () << '\\n' ; for ( size_t index = 1 ; index < m . size (); ++ index ) { if ( ! m [ index ]. str (). empty ()) { std :: cout << \"Capture group ID: \" << index - 1 << std :: endl ; break ; } } } // Concatenate regexes: conjunction string var = \"first second third forth\" ; if ( regex_match ( var , sm , regex ( \"(.*) (.*) (.*) (.*)\" ))) { for ( size_t i = 1 ; i < sm . size (); i ++ ) { cout << \"Match \" << i << \": \" << sm [ i ] << \" at position \" << sm . position ( i ) << endl ; } } // Concatenate regexes: disjunction // This strategy does not work when there are internal capture groups var = \"user/32\" ; smatch sm2 ; auto implode = []( const std :: vector < std :: string > & strs , const std :: string & delim ) { std :: stringstream s ; copy ( strs . begin (), strs . end (), ostream_iterator < string > ( s , delim . c_str ())); return s . str (); }; std :: vector < std :: string > routes = { \"welcome\" , \"user/ \\\\ d+\" , \"post/[a-zA-Z]+\" , \"about\" }; regex disjunction ( \"(\" + implode ( routes , \")|(\" ) + \")\" ); if ( regex_match ( var , sm2 , disjunction , regex_constants :: match_not_null )) { for ( size_t index = 1 ; index < sm2 . size (); ++ index ) { if ( sm2 [ index ]. length () > 0 ) { std :: cout << \"Capture group index: \" << index - 1 << std :: endl ; std :: cout << var << \" matched route \" << routes [ index - 1 ] << std :: endl ; break ; } } } return 0 ; }","title":"Regex"}]}